(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
  [2300],
  {
    519: (e, t, r) => {
      "use strict";
      r.d(t, { Q: () => a });
      let i = {
        transactionHash: /^0x(?:[A-Fa-f0-9]{64})$/u,
        signedMessage: /^0x(?:[a-fA-F0-9]{62,})$/u,
      };
      var s = r(45312),
        n = r(30596);
      let a = {
        checkIfAllowedToTriggerEmail() {
          let e = n.o.get(s.s1.LAST_EMAIL_LOGIN_TIME);
          if (e) {
            let t = Date.now() - Number(e);
            if (t < 3e4) {
              let e = Math.ceil((3e4 - t) / 1e3);
              throw Error(`Please try again after ${e} seconds`);
            }
          }
        },
        getTimeToNextEmailLogin() {
          let e = n.o.get(s.s1.LAST_EMAIL_LOGIN_TIME);
          if (e) {
            let t = Date.now() - Number(e);
            if (t < 3e4) return Math.ceil((3e4 - t) / 1e3);
          }
          return 0;
        },
        checkIfRequestExists: (e) =>
          s.Vl.NOT_SAFE_RPC_METHODS.includes(e.method) ||
          s.Vl.SAFE_RPC_METHODS.includes(e.method),
        getResponseType: (e) =>
          "string" == typeof e &&
          (e?.match(i.transactionHash) || e?.match(i.signedMessage))
            ? s.s1.RPC_RESPONSE_TYPE_TX
            : s.s1.RPC_RESPONSE_TYPE_OBJECT,
        checkIfRequestIsSafe: (e) => s.Vl.SAFE_RPC_METHODS.includes(e.method),
        isClient: "undefined" != typeof window,
      };
    },
    621: (e, t) => {
      "use strict";
      function r(e) {
        let t;
        return (
          "undefined" != typeof window &&
            void 0 !== window[e] &&
            (t = window[e]),
          t
        );
      }
      function i(e) {
        let t = r(e);
        if (!t) throw Error(`${e} is not defined in Window`);
        return t;
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.getLocalStorage =
          t.getLocalStorageOrThrow =
          t.getCrypto =
          t.getCryptoOrThrow =
          t.getLocation =
          t.getLocationOrThrow =
          t.getNavigator =
          t.getNavigatorOrThrow =
          t.getDocument =
          t.getDocumentOrThrow =
          t.getFromWindowOrThrow =
          t.getFromWindow =
            void 0),
        (t.getFromWindow = r),
        (t.getFromWindowOrThrow = i),
        (t.getDocumentOrThrow = function () {
          return i("document");
        }),
        (t.getDocument = function () {
          return r("document");
        }),
        (t.getNavigatorOrThrow = function () {
          return i("navigator");
        }),
        (t.getNavigator = function () {
          return r("navigator");
        }),
        (t.getLocationOrThrow = function () {
          return i("location");
        }),
        (t.getLocation = function () {
          return r("location");
        }),
        (t.getCryptoOrThrow = function () {
          return i("crypto");
        }),
        (t.getCrypto = function () {
          return r("crypto");
        }),
        (t.getLocalStorageOrThrow = function () {
          return i("localStorage");
        }),
        (t.getLocalStorage = function () {
          return r("localStorage");
        });
    },
    1072: (e) => {
      e.exports = function (e, t, r, i) {
        var s = r ? r.call(i, e, t) : void 0;
        if (void 0 !== s) return !!s;
        if (e === t) return !0;
        if ("object" != typeof e || !e || "object" != typeof t || !t) return !1;
        var n = Object.keys(e),
          a = Object.keys(t);
        if (n.length !== a.length) return !1;
        for (
          var o = Object.prototype.hasOwnProperty.bind(t), c = 0;
          c < n.length;
          c++
        ) {
          var l = n[c];
          if (!o(l)) return !1;
          var u = e[l],
            d = t[l];
          if (
            !1 === (s = r ? r.call(i, u, d, l) : void 0) ||
            (void 0 === s && u !== d)
          )
            return !1;
        }
        return !0;
      };
    },
    1405: (e, t, r) => {
      "use strict";
      function i(e, t) {
        let r = e.toString(),
          i = r.startsWith("-");
        i && (r = r.slice(1));
        let [s, n] = [
          (r = r.padStart(t, "0")).slice(0, r.length - t),
          r.slice(r.length - t),
        ];
        return (
          (n = n.replace(/(0+)$/, "")),
          `${i ? "-" : ""}${s || "0"}${n ? `.${n}` : ""}`
        );
      }
      r.d(t, { J: () => i });
    },
    2255: (e, t, r) => {
      "use strict";
      function i(e) {
        if (!Number.isSafeInteger(e) || e < 0)
          throw Error("positive integer expected, got " + e);
      }
      function s(e, ...t) {
        if (
          !(
            e instanceof Uint8Array ||
            (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
          )
        )
          throw Error("Uint8Array expected");
        if (t.length > 0 && !t.includes(e.length))
          throw Error(
            "Uint8Array expected of length " + t + ", got length=" + e.length
          );
      }
      function n(e) {
        if ("function" != typeof e || "function" != typeof e.create)
          throw Error("Hash should be wrapped by utils.wrapConstructor");
        i(e.outputLen), i(e.blockLen);
      }
      function a(e, t = !0) {
        if (e.destroyed) throw Error("Hash instance has been destroyed");
        if (t && e.finished)
          throw Error("Hash#digest() has already been called");
      }
      function o(e, t) {
        s(e);
        let r = t.outputLen;
        if (e.length < r)
          throw Error(
            "digestInto() expects output buffer of length at least " + r
          );
      }
      r.d(t, {
        CC: () => a,
        DO: () => s,
        Fe: () => i,
        Ht: () => o,
        sd: () => n,
      });
    },
    2568: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => l }), r(50254);
      var i = r(60500),
        s = r(90906),
        n = r(96641),
        a = r(45954),
        o = r(93813),
        c = r(27882);
      class l {
        constructor({ provider: e, namespace: t }) {
          (this.id = i.o.CONNECTOR_ID.WALLET_CONNECT),
            (this.name =
              o.L.ConnectorNamesMap[i.o.CONNECTOR_ID.WALLET_CONNECT]),
            (this.type = "WALLET_CONNECT"),
            (this.imageId =
              o.L.ConnectorImageIds[i.o.CONNECTOR_ID.WALLET_CONNECT]),
            (this.getCaipNetworks = s.W.getCaipNetworks.bind(s.W)),
            (this.caipNetworks = this.getCaipNetworks()),
            (this.provider = e),
            (this.chain = t);
        }
        get chains() {
          return this.getCaipNetworks();
        }
        async connectWalletConnect() {
          if (!(await this.authenticate())) {
            let e = this.getCaipNetworks(),
              t = n.H.state.universalProviderConfigOverride,
              r = c.kl.createNamespaces(e, t);
            await this.provider.connect({ optionalNamespaces: r });
          }
          return {
            clientId: await this.provider.client.core.crypto.getClientId(),
            session: this.provider.session,
          };
        }
        async disconnect() {
          await this.provider.disconnect();
        }
        async authenticate() {
          let e = this.chains.map((e) => e.caipNetworkId);
          return a.U.universalProviderAuthenticate({
            universalProvider: this.provider,
            chains: e,
            methods: u,
          });
        }
      }
      let u = [
        "eth_accounts",
        "eth_requestAccounts",
        "eth_sendRawTransaction",
        "eth_sign",
        "eth_signTransaction",
        "eth_signTypedData",
        "eth_signTypedData_v3",
        "eth_signTypedData_v4",
        "eth_sendTransaction",
        "personal_sign",
        "wallet_switchEthereumChain",
        "wallet_addEthereumChain",
        "wallet_getPermissions",
        "wallet_requestPermissions",
        "wallet_registerOnboarding",
        "wallet_watchAsset",
        "wallet_scanQRCode",
        "wallet_getCallsStatus",
        "wallet_sendCalls",
        "wallet_getCapabilities",
        "wallet_grantPermissions",
        "wallet_revokePermissions",
        "wallet_getAssets",
      ];
    },
    2767: (e, t, r) => {
      "use strict";
      r.d(t, {
        Vw: () => p,
        Fc: () => l,
        Id: () => h,
        O8: () => a,
        qv: () => c,
        po: () => g,
        Ow: () => o,
        ZJ: () => d,
        DH: () => n,
        ld: () => f,
      });
      let i =
        "object" == typeof globalThis && "crypto" in globalThis
          ? globalThis.crypto
          : void 0;
      var s = r(91281);
      function n(e) {
        return new Uint32Array(
          e.buffer,
          e.byteOffset,
          Math.floor(e.byteLength / 4)
        );
      }
      function a(e) {
        return new DataView(e.buffer, e.byteOffset, e.byteLength);
      }
      function o(e, t) {
        return (e << (32 - t)) | (e >>> t);
      }
      let c = 68 === new Uint8Array(new Uint32Array([0x11223344]).buffer)[0];
      function l(e) {
        for (let r = 0; r < e.length; r++) {
          var t;
          e[r] =
            (((t = e[r]) << 24) & 0xff000000) |
            ((t << 8) & 0xff0000) |
            ((t >>> 8) & 65280) |
            ((t >>> 24) & 255);
        }
      }
      (e, t) => t.toString(16).padStart(2, "0");
      let u = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      function d(e) {
        return (
          "string" == typeof e &&
            (e = (function (e) {
              if ("string" != typeof e)
                throw Error("utf8ToBytes expected string, got " + typeof e);
              return new Uint8Array(new TextEncoder().encode(e));
            })(e)),
          (0, s.DO)(e),
          e
        );
      }
      function h(...e) {
        let t = 0;
        for (let r = 0; r < e.length; r++) {
          let i = e[r];
          (0, s.DO)(i), (t += i.length);
        }
        let r = new Uint8Array(t);
        for (let t = 0, i = 0; t < e.length; t++) {
          let s = e[t];
          r.set(s, i), (i += s.length);
        }
        return r;
      }
      class p {
        clone() {
          return this._cloneInto();
        }
      }
      function f(e) {
        let t = (t) => e().update(d(t)).digest(),
          r = e();
        return (
          (t.outputLen = r.outputLen),
          (t.blockLen = r.blockLen),
          (t.create = () => e()),
          t
        );
      }
      function g(e = 32) {
        if (i && "function" == typeof i.getRandomValues)
          return i.getRandomValues(new Uint8Array(e));
        if (i && "function" == typeof i.randomBytes) return i.randomBytes(e);
        throw Error("crypto.getRandomValues must be defined");
      }
    },
    5517: (e, t, r) => {
      "use strict";
      r.d(t, { P: () => c });
      var i = r(43708),
        s = r(70799),
        n = r(35558);
      let a = Object.freeze({
          message: "",
          variant: "success",
          svg: void 0,
          open: !1,
          autoClose: !0,
        }),
        o = (0, i.BX)({ ...a }),
        c = {
          state: o,
          subscribeKey: (e, t) => (0, s.u$)(o, e, t),
          showLoading(e, t = {}) {
            this._showMessage({ message: e, variant: "loading", ...t });
          },
          showSuccess(e) {
            this._showMessage({ message: e, variant: "success" });
          },
          showSvg(e, t) {
            this._showMessage({ message: e, svg: t });
          },
          showError(e) {
            let t = n.w.parseError(e);
            this._showMessage({ message: t, variant: "error" });
          },
          hide() {
            (o.message = a.message),
              (o.variant = a.variant),
              (o.svg = a.svg),
              (o.open = a.open),
              (o.autoClose = a.autoClose);
          },
          _showMessage({
            message: e,
            svg: t,
            variant: r = "success",
            autoClose: i = a.autoClose,
          }) {
            o.open
              ? ((o.open = !1),
                setTimeout(() => {
                  (o.message = e),
                    (o.variant = r),
                    (o.svg = t),
                    (o.open = !0),
                    (o.autoClose = i);
                }, 150))
              : ((o.message = e),
                (o.variant = r),
                (o.svg = t),
                (o.open = !0),
                (o.autoClose = i));
          },
        };
    },
    5582: (e, t, r) => {
      "use strict";
      r.d(t, { i: () => s });
      var i = r(55458);
      let s = {
        cacheExpiry: {
          portfolio: 3e4,
          nativeBalance: 3e4,
          ens: 3e5,
          identity: 3e5,
        },
        isCacheExpired: (e, t) => Date.now() - e > t,
        getActiveNetworkProps() {
          let e = s.getActiveNamespace(),
            t = s.getActiveCaipNetworkId(),
            r = t ? t.split(":")[1] : void 0;
          return {
            namespace: e,
            caipNetworkId: t,
            chainId: r ? (isNaN(Number(r)) ? r : Number(r)) : void 0,
          };
        },
        setWalletConnectDeepLink({ name: e, href: t }) {
          try {
            i.Ud.setItem(
              i.Ws.DEEPLINK_CHOICE,
              JSON.stringify({ href: t, name: e })
            );
          } catch {
            console.info("Unable to set WalletConnect deep link");
          }
        },
        getWalletConnectDeepLink() {
          try {
            let e = i.Ud.getItem(i.Ws.DEEPLINK_CHOICE);
            if (e) return JSON.parse(e);
          } catch {
            console.info("Unable to get WalletConnect deep link");
          }
        },
        deleteWalletConnectDeepLink() {
          try {
            i.Ud.removeItem(i.Ws.DEEPLINK_CHOICE);
          } catch {
            console.info("Unable to delete WalletConnect deep link");
          }
        },
        setActiveNamespace(e) {
          try {
            i.Ud.setItem(i.Ws.ACTIVE_NAMESPACE, e);
          } catch {
            console.info("Unable to set active namespace");
          }
        },
        setActiveCaipNetworkId(e) {
          try {
            i.Ud.setItem(i.Ws.ACTIVE_CAIP_NETWORK_ID, e),
              s.setActiveNamespace(e.split(":")[0]);
          } catch {
            console.info("Unable to set active caip network id");
          }
        },
        getActiveCaipNetworkId() {
          try {
            return i.Ud.getItem(i.Ws.ACTIVE_CAIP_NETWORK_ID);
          } catch {
            console.info("Unable to get active caip network id");
            return;
          }
        },
        deleteActiveCaipNetworkId() {
          try {
            i.Ud.removeItem(i.Ws.ACTIVE_CAIP_NETWORK_ID);
          } catch {
            console.info("Unable to delete active caip network id");
          }
        },
        deleteConnectedConnectorId(e) {
          try {
            let t = (0, i.T8)(e);
            i.Ud.removeItem(t);
          } catch {
            console.info("Unable to delete connected connector id");
          }
        },
        setAppKitRecent(e) {
          try {
            let t = s.getRecentWallets();
            t.find((t) => t.id === e.id) ||
              (t.unshift(e),
              t.length > 2 && t.pop(),
              i.Ud.setItem(i.Ws.RECENT_WALLETS, JSON.stringify(t)));
          } catch {
            console.info("Unable to set AppKit recent");
          }
        },
        getRecentWallets() {
          try {
            let e = i.Ud.getItem(i.Ws.RECENT_WALLETS);
            return e ? JSON.parse(e) : [];
          } catch {
            console.info("Unable to get AppKit recent");
          }
          return [];
        },
        setConnectedConnectorId(e, t) {
          try {
            let r = (0, i.T8)(e);
            i.Ud.setItem(r, t);
          } catch {
            console.info("Unable to set Connected Connector Id");
          }
        },
        getActiveNamespace() {
          try {
            return i.Ud.getItem(i.Ws.ACTIVE_NAMESPACE);
          } catch {
            console.info("Unable to get active namespace");
          }
        },
        getConnectedConnectorId(e) {
          if (e)
            try {
              let t = (0, i.T8)(e);
              return i.Ud.getItem(t);
            } catch (t) {
              console.info(
                "Unable to get connected connector id in namespace ",
                e
              );
            }
        },
        setConnectedSocialProvider(e) {
          try {
            i.Ud.setItem(i.Ws.CONNECTED_SOCIAL, e);
          } catch {
            console.info("Unable to set connected social provider");
          }
        },
        getConnectedSocialProvider() {
          try {
            return i.Ud.getItem(i.Ws.CONNECTED_SOCIAL);
          } catch {
            console.info("Unable to get connected social provider");
          }
        },
        deleteConnectedSocialProvider() {
          try {
            i.Ud.removeItem(i.Ws.CONNECTED_SOCIAL);
          } catch {
            console.info("Unable to delete connected social provider");
          }
        },
        getConnectedSocialUsername() {
          try {
            return i.Ud.getItem(i.Ws.CONNECTED_SOCIAL_USERNAME);
          } catch {
            console.info("Unable to get connected social username");
          }
        },
        getStoredActiveCaipNetworkId() {
          let e = i.Ud.getItem(i.Ws.ACTIVE_CAIP_NETWORK_ID);
          return e?.split(":")?.[1];
        },
        setConnectionStatus(e) {
          try {
            i.Ud.setItem(i.Ws.CONNECTION_STATUS, e);
          } catch {
            console.info("Unable to set connection status");
          }
        },
        getConnectionStatus() {
          try {
            return i.Ud.getItem(i.Ws.CONNECTION_STATUS);
          } catch {
            return;
          }
        },
        getConnectedNamespaces() {
          try {
            let e = i.Ud.getItem(i.Ws.CONNECTED_NAMESPACES);
            if (!e?.length) return [];
            return e.split(",");
          } catch {
            return [];
          }
        },
        setConnectedNamespaces(e) {
          try {
            let t = Array.from(new Set(e));
            i.Ud.setItem(i.Ws.CONNECTED_NAMESPACES, t.join(","));
          } catch {
            console.info("Unable to set namespaces in storage");
          }
        },
        addConnectedNamespace(e) {
          try {
            let t = s.getConnectedNamespaces();
            t.includes(e) || (t.push(e), s.setConnectedNamespaces(t));
          } catch {
            console.info("Unable to add connected namespace");
          }
        },
        removeConnectedNamespace(e) {
          try {
            let t = s.getConnectedNamespaces(),
              r = t.indexOf(e);
            r > -1 && (t.splice(r, 1), s.setConnectedNamespaces(t));
          } catch {
            console.info("Unable to remove connected namespace");
          }
        },
        getTelegramSocialProvider() {
          try {
            return i.Ud.getItem(i.Ws.TELEGRAM_SOCIAL_PROVIDER);
          } catch {
            return console.info("Unable to get telegram social provider"), null;
          }
        },
        setTelegramSocialProvider(e) {
          try {
            i.Ud.setItem(i.Ws.TELEGRAM_SOCIAL_PROVIDER, e);
          } catch {
            console.info("Unable to set telegram social provider");
          }
        },
        removeTelegramSocialProvider() {
          try {
            i.Ud.removeItem(i.Ws.TELEGRAM_SOCIAL_PROVIDER);
          } catch {
            console.info("Unable to remove telegram social provider");
          }
        },
        getBalanceCache() {
          let e = {};
          try {
            let t = i.Ud.getItem(i.Ws.PORTFOLIO_CACHE);
            e = t ? JSON.parse(t) : {};
          } catch {
            console.info("Unable to get balance cache");
          }
          return e;
        },
        removeAddressFromBalanceCache(e) {
          try {
            let t = s.getBalanceCache();
            i.Ud.setItem(
              i.Ws.PORTFOLIO_CACHE,
              JSON.stringify({ ...t, [e]: void 0 })
            );
          } catch {
            console.info("Unable to remove address from balance cache", e);
          }
        },
        getBalanceCacheForCaipAddress(e) {
          try {
            let t = s.getBalanceCache()[e];
            if (
              t &&
              !this.isCacheExpired(t.timestamp, this.cacheExpiry.portfolio)
            )
              return t.balance;
            s.removeAddressFromBalanceCache(e);
          } catch {
            console.info("Unable to get balance cache for address", e);
          }
        },
        updateBalanceCache(e) {
          try {
            let t = s.getBalanceCache();
            (t[e.caipAddress] = e),
              i.Ud.setItem(i.Ws.PORTFOLIO_CACHE, JSON.stringify(t));
          } catch {
            console.info("Unable to update balance cache", e);
          }
        },
        getNativeBalanceCache() {
          let e = {};
          try {
            let t = i.Ud.getItem(i.Ws.NATIVE_BALANCE_CACHE);
            e = t ? JSON.parse(t) : {};
          } catch {
            console.info("Unable to get balance cache");
          }
          return e;
        },
        removeAddressFromNativeBalanceCache(e) {
          try {
            let t = s.getBalanceCache();
            i.Ud.setItem(
              i.Ws.NATIVE_BALANCE_CACHE,
              JSON.stringify({ ...t, [e]: void 0 })
            );
          } catch {
            console.info("Unable to remove address from balance cache", e);
          }
        },
        getNativeBalanceCacheForCaipAddress(e) {
          try {
            let t = s.getNativeBalanceCache()[e];
            if (
              t &&
              !this.isCacheExpired(t.timestamp, this.cacheExpiry.nativeBalance)
            )
              return t;
            console.info("Discarding cache for address", e),
              s.removeAddressFromBalanceCache(e);
          } catch {
            console.info("Unable to get balance cache for address", e);
          }
        },
        updateNativeBalanceCache(e) {
          try {
            let t = s.getNativeBalanceCache();
            (t[e.caipAddress] = e),
              i.Ud.setItem(i.Ws.NATIVE_BALANCE_CACHE, JSON.stringify(t));
          } catch {
            console.info("Unable to update balance cache", e);
          }
        },
        getEnsCache() {
          let e = {};
          try {
            let t = i.Ud.getItem(i.Ws.ENS_CACHE);
            e = t ? JSON.parse(t) : {};
          } catch {
            console.info("Unable to get ens name cache");
          }
          return e;
        },
        getEnsFromCacheForAddress(e) {
          try {
            let t = s.getEnsCache()[e];
            if (t && !this.isCacheExpired(t.timestamp, this.cacheExpiry.ens))
              return t.ens;
            s.removeEnsFromCache(e);
          } catch {
            console.info("Unable to get ens name from cache", e);
          }
        },
        updateEnsCache(e) {
          try {
            let t = s.getEnsCache();
            (t[e.address] = e), i.Ud.setItem(i.Ws.ENS_CACHE, JSON.stringify(t));
          } catch {
            console.info("Unable to update ens name cache", e);
          }
        },
        removeEnsFromCache(e) {
          try {
            let t = s.getEnsCache();
            i.Ud.setItem(i.Ws.ENS_CACHE, JSON.stringify({ ...t, [e]: void 0 }));
          } catch {
            console.info("Unable to remove ens name from cache", e);
          }
        },
        getIdentityCache() {
          let e = {};
          try {
            let t = i.Ud.getItem(i.Ws.IDENTITY_CACHE);
            e = t ? JSON.parse(t) : {};
          } catch {
            console.info("Unable to get identity cache");
          }
          return e;
        },
        getIdentityFromCacheForAddress(e) {
          try {
            let t = s.getIdentityCache()[e];
            if (
              t &&
              !this.isCacheExpired(t.timestamp, this.cacheExpiry.identity)
            )
              return t.identity;
            s.removeIdentityFromCache(e);
          } catch {
            console.info("Unable to get identity from cache", e);
          }
        },
        updateIdentityCache(e) {
          try {
            let t = s.getIdentityCache();
            (t[e.address] = { identity: e.identity, timestamp: e.timestamp }),
              i.Ud.setItem(i.Ws.IDENTITY_CACHE, JSON.stringify(t));
          } catch {
            console.info("Unable to update identity cache", e);
          }
        },
        removeIdentityFromCache(e) {
          try {
            let t = s.getIdentityCache();
            i.Ud.setItem(
              i.Ws.IDENTITY_CACHE,
              JSON.stringify({ ...t, [e]: void 0 })
            );
          } catch {
            console.info("Unable to remove identity from cache", e);
          }
        },
        clearAddressCache() {
          try {
            i.Ud.removeItem(i.Ws.PORTFOLIO_CACHE),
              i.Ud.removeItem(i.Ws.NATIVE_BALANCE_CACHE),
              i.Ud.removeItem(i.Ws.ENS_CACHE),
              i.Ud.removeItem(i.Ws.IDENTITY_CACHE);
          } catch {
            console.info("Unable to clear address cache");
          }
        },
        setPreferredAccountTypes(e) {
          try {
            i.Ud.setItem(i.Ws.PREFERRED_ACCOUNT_TYPES, JSON.stringify(e));
          } catch {
            console.info("Unable to set preferred account types", e);
          }
        },
        getPreferredAccountTypes() {
          try {
            let e = i.Ud.getItem(i.Ws.PREFERRED_ACCOUNT_TYPES);
            if (!e) return {};
            return JSON.parse(e);
          } catch {
            console.info("Unable to get preferred account types");
          }
          return {};
        },
        setConnections(e, t) {
          try {
            let r = { ...s.getConnections(), [t]: e };
            i.Ud.setItem(i.Ws.CONNECTIONS, JSON.stringify(r));
          } catch (e) {
            console.error("Unable to sync connections to storage", e);
          }
        },
        getConnections() {
          try {
            let e = i.Ud.getItem(i.Ws.CONNECTIONS);
            if (!e) return {};
            return JSON.parse(e);
          } catch (e) {
            return (
              console.error("Unable to get connections from storage", e), {}
            );
          }
        },
      };
    },
    6193: (e, t, r) => {
      "use strict";
      let i;
      r.d(t, { x: () => y });
      var s = r(43708),
        n = r(70799),
        a = r(35558),
        o = r(5582),
        c = r(92555),
        l = r(11076),
        u = r(90906),
        d = r(54252),
        h = r(32836),
        p = r(33806),
        f = r(19628),
        g = r(47584);
      let m = (0, s.BX)({
          connections: new Map(),
          wcError: !1,
          buffering: !1,
          status: "disconnected",
        }),
        y = (0, c.X)({
          state: m,
          subscribeKey: (e, t) => (0, n.u$)(m, e, t),
          _getClient: () => m._client,
          setClient(e) {
            m._client = (0, s.KR)(e);
          },
          async connectWalletConnect() {
            if (a.w.isTelegram() || (a.w.isSafari() && a.w.isIos())) {
              if (i) {
                await i, (i = void 0);
                return;
              }
              if (!a.w.isPairingExpired(m?.wcPairingExpiry)) {
                let e = m.wcUri;
                m.wcUri = e;
                return;
              }
              (i = y
                ._getClient()
                ?.connectWalletConnect?.()
                .catch(() => void 0)),
                (y.state.status = "connecting"),
                await i,
                (i = void 0),
                (m.wcPairingExpiry = void 0),
                (y.state.status = "connected");
            } else await y._getClient()?.connectWalletConnect?.();
          },
          async connectExternal(e, t, r = !0) {
            await y._getClient()?.connectExternal?.(e),
              r && u.W.setActiveNamespace(t);
          },
          async reconnectExternal(e) {
            await y._getClient()?.reconnectExternal?.(e);
            let t = e.chain || u.W.state.activeChain;
            t && d.a.setConnectorId(e.id, t);
          },
          async setPreferredAccountType(e, t) {
            p.W.setLoading(!0, u.W.state.activeChain);
            let r = d.a.getAuthConnector();
            r &&
              (l.U.setPreferredAccountType(e, t),
              await r.provider.setPreferredAccount(e),
              o.i.setPreferredAccountTypes(
                l.U.state.preferredAccountTypes ?? { [t]: e }
              ),
              await y.reconnectExternal(r),
              p.W.setLoading(!1, u.W.state.activeChain),
              h.E.sendEvent({
                type: "track",
                event: "SET_PREFERRED_ACCOUNT_TYPE",
                properties: {
                  accountType: e,
                  network: u.W.state.activeCaipNetwork?.caipNetworkId || "",
                },
              }));
          },
          signMessage: async (e) => y._getClient()?.signMessage(e),
          parseUnits: (e, t) => y._getClient()?.parseUnits(e, t),
          formatUnits: (e, t) => y._getClient()?.formatUnits(e, t),
          sendTransaction: async (e) => y._getClient()?.sendTransaction(e),
          getCapabilities: async (e) => y._getClient()?.getCapabilities(e),
          grantPermissions: async (e) => y._getClient()?.grantPermissions(e),
          walletGetAssets: async (e) =>
            y._getClient()?.walletGetAssets(e) ?? {},
          estimateGas: async (e) => y._getClient()?.estimateGas(e),
          writeContract: async (e) => y._getClient()?.writeContract(e),
          getEnsAddress: async (e) => y._getClient()?.getEnsAddress(e),
          getEnsAvatar: async (e) => y._getClient()?.getEnsAvatar(e),
          checkInstalled: (e) => y._getClient()?.checkInstalled?.(e) || !1,
          resetWcConnection() {
            (m.wcUri = void 0),
              (m.wcPairingExpiry = void 0),
              (m.wcLinking = void 0),
              (m.recentWallet = void 0),
              (m.status = "disconnected"),
              g.W.resetTransactions(),
              o.i.deleteWalletConnectDeepLink();
          },
          resetUri() {
            (m.wcUri = void 0), (m.wcPairingExpiry = void 0), (i = void 0);
          },
          finalizeWcConnection() {
            let { wcLinking: e, recentWallet: t } = y.state;
            e && o.i.setWalletConnectDeepLink(e),
              t && o.i.setAppKitRecent(t),
              h.E.sendEvent({
                type: "track",
                event: "CONNECT_SUCCESS",
                properties: {
                  method: e ? "mobile" : "qrcode",
                  name: f.I.state.data?.wallet?.name || "Unknown",
                },
              });
          },
          setWcBasic(e) {
            m.wcBasic = e;
          },
          setUri(e) {
            (m.wcUri = e), (m.wcPairingExpiry = a.w.getPairingExpiry());
          },
          setWcLinking(e) {
            m.wcLinking = e;
          },
          setWcError(e) {
            (m.wcError = e), (m.buffering = !1);
          },
          setRecentWallet(e) {
            m.recentWallet = e;
          },
          setBuffering(e) {
            m.buffering = e;
          },
          setStatus(e) {
            m.status = e;
          },
          async disconnect(e) {
            try {
              await y._getClient()?.disconnect(e);
            } catch (e) {
              throw new c.A("Failed to disconnect", "INTERNAL_SDK_ERROR", e);
            }
          },
          setConnections(e, t) {
            m.connections.set(t, e);
          },
          switchAccount({ connection: e, address: t, namespace: r }) {
            if (d.a.state.activeConnectorIds[r] === e.connectorId) {
              let e = u.W.state.activeCaipNetwork;
              if (e) {
                let i = `${r}:${e.id}:${t}`;
                l.U.setCaipAddress(i, r);
              } else
                console.warn(`No current network found for namespace "${r}"`);
            } else {
              let t = d.a.getConnector(e.connectorId);
              t
                ? y.connectExternal(t, r)
                : console.warn(`No connector found for namespace "${r}"`);
            }
          },
        });
    },
    6420: function (e) {
      e.exports = function (e, t, r) {
        r.updateLocale = function (e, t) {
          var i = r.Ls[e];
          if (i)
            return (
              (t ? Object.keys(t) : []).forEach(function (e) {
                i[e] = t[e];
              }),
              i
            );
        };
      };
    },
    6784: (e, t, r) => {
      "use strict";
      r.d(t, { II: () => d, v_: () => c, wm: () => u });
      var i = r(50920),
        s = r(21239),
        n = r(73504),
        a = r(52020);
      function o(e) {
        return Math.min(1e3 * 2 ** e, 3e4);
      }
      function c(e) {
        return (e ?? "online") !== "online" || s.t.isOnline();
      }
      var l = class extends Error {
        constructor(e) {
          super("CancelledError"),
            (this.revert = e?.revert),
            (this.silent = e?.silent);
        }
      };
      function u(e) {
        return e instanceof l;
      }
      function d(e) {
        let t,
          r = !1,
          u = 0,
          d = !1,
          h = (0, n.T)(),
          p = () =>
            i.m.isFocused() &&
            ("always" === e.networkMode || s.t.isOnline()) &&
            e.canRun(),
          f = () => c(e.networkMode) && e.canRun(),
          g = (r) => {
            d || ((d = !0), e.onSuccess?.(r), t?.(), h.resolve(r));
          },
          m = (r) => {
            d || ((d = !0), e.onError?.(r), t?.(), h.reject(r));
          },
          y = () =>
            new Promise((r) => {
              (t = (e) => {
                (d || p()) && r(e);
              }),
                e.onPause?.();
            }).then(() => {
              (t = void 0), d || e.onContinue?.();
            }),
          b = () => {
            let t;
            if (d) return;
            let i = 0 === u ? e.initialPromise : void 0;
            try {
              t = i ?? e.fn();
            } catch (e) {
              t = Promise.reject(e);
            }
            Promise.resolve(t)
              .then(g)
              .catch((t) => {
                if (d) return;
                let i = e.retry ?? 3 * !a.S$,
                  s = e.retryDelay ?? o,
                  n = "function" == typeof s ? s(u, t) : s,
                  c =
                    !0 === i ||
                    ("number" == typeof i && u < i) ||
                    ("function" == typeof i && i(u, t));
                if (r || !c) return void m(t);
                u++,
                  e.onFail?.(u, t),
                  (0, a.yy)(n)
                    .then(() => (p() ? void 0 : y()))
                    .then(() => {
                      r ? m(t) : b();
                    });
              });
          };
        return {
          promise: h,
          cancel: (t) => {
            d || (m(new l(t)), e.abort?.());
          },
          continue: () => (t?.(), h),
          cancelRetry: () => {
            r = !0;
          },
          continueRetry: () => {
            r = !1;
          },
          canStart: f,
          start: () => (f() ? b() : y().then(b), h),
        };
      }
    },
    7165: (e, t, r) => {
      "use strict";
      r.d(t, { jG: () => s });
      var i = (e) => setTimeout(e, 0),
        s = (function () {
          let e = [],
            t = 0,
            r = (e) => {
              e();
            },
            s = (e) => {
              e();
            },
            n = i,
            a = (i) => {
              t
                ? e.push(i)
                : n(() => {
                    r(i);
                  });
            },
            o = () => {
              let t = e;
              (e = []),
                t.length &&
                  n(() => {
                    s(() => {
                      t.forEach((e) => {
                        r(e);
                      });
                    });
                  });
            };
          return {
            batch: (e) => {
              let r;
              t++;
              try {
                r = e();
              } finally {
                --t || o();
              }
              return r;
            },
            batchCalls:
              (e) =>
              (...t) => {
                a(() => {
                  e(...t);
                });
              },
            schedule: a,
            setNotifyFunction: (e) => {
              r = e;
            },
            setBatchNotifyFunction: (e) => {
              s = e;
            },
            setScheduler: (e) => {
              n = e;
            },
          };
        })();
    },
    7441: (e, t, r) => {
      "use strict";
      r.d(t, { C: () => n });
      let i = "2.29.2",
        s = {
          getDocsUrl: ({ docsBaseUrl: e, docsPath: t = "", docsSlug: r }) =>
            t ? `${e ?? "https://viem.sh"}${t}${r ? `#${r}` : ""}` : void 0,
          version: `viem@${i}`,
        };
      class n extends Error {
        constructor(e, t = {}) {
          let r =
              t.cause instanceof n
                ? t.cause.details
                : t.cause?.message
                ? t.cause.message
                : t.details,
            a = (t.cause instanceof n && t.cause.docsPath) || t.docsPath,
            o = s.getDocsUrl?.({ ...t, docsPath: a });
          super(
            [
              e || "An error occurred.",
              "",
              ...(t.metaMessages ? [...t.metaMessages, ""] : []),
              ...(o ? [`Docs: ${o}`] : []),
              ...(r ? [`Details: ${r}`] : []),
              ...(s.version ? [`Version: ${s.version}`] : []),
            ].join("\n"),
            t.cause ? { cause: t.cause } : void 0
          ),
            Object.defineProperty(this, "details", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "docsPath", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "metaMessages", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "shortMessage", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "version", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "BaseError",
            }),
            (this.details = r),
            (this.docsPath = a),
            (this.metaMessages = t.metaMessages),
            (this.name = t.name ?? this.name),
            (this.shortMessage = e),
            (this.version = i);
        }
        walk(e) {
          return (function e(t, r) {
            return r?.(t)
              ? t
              : t && "object" == typeof t && "cause" in t && void 0 !== t.cause
              ? e(t.cause, r)
              : r
              ? null
              : t;
          })(this, e);
        }
      }
    },
    7478: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => l });
      var i = r(43708),
        s = r(22492),
        n = r(92555),
        a = r(54252);
      let o = (0, i.BX)({
          themeMode: "dark",
          themeVariables: {},
          w3mThemeVariables: void 0,
        }),
        c = {
          state: o,
          subscribe: (e) => (0, i.B1)(o, () => e(o)),
          setThemeMode(e) {
            o.themeMode = e;
            try {
              let t = a.a.getAuthConnector();
              if (t) {
                let r = c.getSnapshot().themeVariables;
                t.provider.syncTheme({
                  themeMode: e,
                  themeVariables: r,
                  w3mThemeVariables: (0, s.o)(r, e),
                });
              }
            } catch {
              console.info("Unable to sync theme to auth connector");
            }
          },
          setThemeVariables(e) {
            o.themeVariables = { ...o.themeVariables, ...e };
            try {
              let e = a.a.getAuthConnector();
              if (e) {
                let t = c.getSnapshot().themeVariables;
                e.provider.syncTheme({
                  themeVariables: t,
                  w3mThemeVariables: (0, s.o)(o.themeVariables, o.themeMode),
                });
              }
            } catch {
              console.info("Unable to sync theme to auth connector");
            }
          },
          getSnapshot: () => (0, i.P9)(o),
        },
        l = (0, n.X)(c);
    },
    7488: (e, t, r) => {
      "use strict";
      var i = r(49509);
      function s() {
        return (
          "undefined" == typeof document &&
          "undefined" != typeof navigator &&
          "ReactNative" === navigator.product
        );
      }
      function n() {
        return (
          void 0 !== i && void 0 !== i.versions && void 0 !== i.versions.node
        );
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.isBrowser = t.isNode = t.isReactNative = void 0),
        (t.isReactNative = s),
        (t.isNode = n),
        (t.isBrowser = function () {
          return !s() && !n();
        });
    },
    7599: (e, t, r) => {
      var i =
          ("undefined" != typeof globalThis && globalThis) ||
          ("undefined" != typeof self && self) ||
          (void 0 !== r.g && r.g),
        s = (function () {
          function e() {
            (this.fetch = !1), (this.DOMException = i.DOMException);
          }
          return (e.prototype = i), new e();
        })();
      !(function (e) {
        !(function (t) {
          var i =
              (void 0 !== e && e) ||
              ("undefined" != typeof self && self) ||
              (void 0 !== r.g && r.g) ||
              {},
            s = {
              searchParams: "URLSearchParams" in i,
              iterable: "Symbol" in i && "iterator" in Symbol,
              blob:
                "FileReader" in i &&
                "Blob" in i &&
                (function () {
                  try {
                    return new Blob(), !0;
                  } catch (e) {
                    return !1;
                  }
                })(),
              formData: "FormData" in i,
              arrayBuffer: "ArrayBuffer" in i,
            };
          if (s.arrayBuffer)
            var n = [
                "[object Int8Array]",
                "[object Uint8Array]",
                "[object Uint8ClampedArray]",
                "[object Int16Array]",
                "[object Uint16Array]",
                "[object Int32Array]",
                "[object Uint32Array]",
                "[object Float32Array]",
                "[object Float64Array]",
              ],
              a =
                ArrayBuffer.isView ||
                function (e) {
                  return e && n.indexOf(Object.prototype.toString.call(e)) > -1;
                };
          function o(e) {
            if (
              ("string" != typeof e && (e = String(e)),
              /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(e) || "" === e)
            )
              throw TypeError(
                'Invalid character in header field name: "' + e + '"'
              );
            return e.toLowerCase();
          }
          function c(e) {
            return "string" != typeof e && (e = String(e)), e;
          }
          function l(e) {
            var t = {
              next: function () {
                var t = e.shift();
                return { done: void 0 === t, value: t };
              },
            };
            return (
              s.iterable &&
                (t[Symbol.iterator] = function () {
                  return t;
                }),
              t
            );
          }
          function u(e) {
            (this.map = {}),
              e instanceof u
                ? e.forEach(function (e, t) {
                    this.append(t, e);
                  }, this)
                : Array.isArray(e)
                ? e.forEach(function (e) {
                    if (2 != e.length)
                      throw TypeError(
                        "Headers constructor: expected name/value pair to be length 2, found" +
                          e.length
                      );
                    this.append(e[0], e[1]);
                  }, this)
                : e &&
                  Object.getOwnPropertyNames(e).forEach(function (t) {
                    this.append(t, e[t]);
                  }, this);
          }
          function d(e) {
            if (!e._noBody) {
              if (e.bodyUsed) return Promise.reject(TypeError("Already read"));
              e.bodyUsed = !0;
            }
          }
          function h(e) {
            return new Promise(function (t, r) {
              (e.onload = function () {
                t(e.result);
              }),
                (e.onerror = function () {
                  r(e.error);
                });
            });
          }
          function p(e) {
            var t = new FileReader(),
              r = h(t);
            return t.readAsArrayBuffer(e), r;
          }
          function f(e) {
            if (e.slice) return e.slice(0);
            var t = new Uint8Array(e.byteLength);
            return t.set(new Uint8Array(e)), t.buffer;
          }
          function g() {
            return (
              (this.bodyUsed = !1),
              (this._initBody = function (e) {
                if (((this.bodyUsed = this.bodyUsed), (this._bodyInit = e), e))
                  if ("string" == typeof e) this._bodyText = e;
                  else if (s.blob && Blob.prototype.isPrototypeOf(e))
                    this._bodyBlob = e;
                  else if (s.formData && FormData.prototype.isPrototypeOf(e))
                    this._bodyFormData = e;
                  else if (
                    s.searchParams &&
                    URLSearchParams.prototype.isPrototypeOf(e)
                  )
                    this._bodyText = e.toString();
                  else {
                    var t;
                    s.arrayBuffer &&
                    s.blob &&
                    (t = e) &&
                    DataView.prototype.isPrototypeOf(t)
                      ? ((this._bodyArrayBuffer = f(e.buffer)),
                        (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                      : s.arrayBuffer &&
                        (ArrayBuffer.prototype.isPrototypeOf(e) || a(e))
                      ? (this._bodyArrayBuffer = f(e))
                      : (this._bodyText = e =
                          Object.prototype.toString.call(e));
                  }
                else (this._noBody = !0), (this._bodyText = "");
                !this.headers.get("content-type") &&
                  ("string" == typeof e
                    ? this.headers.set(
                        "content-type",
                        "text/plain;charset=UTF-8"
                      )
                    : this._bodyBlob && this._bodyBlob.type
                    ? this.headers.set("content-type", this._bodyBlob.type)
                    : s.searchParams &&
                      URLSearchParams.prototype.isPrototypeOf(e) &&
                      this.headers.set(
                        "content-type",
                        "application/x-www-form-urlencoded;charset=UTF-8"
                      ));
              }),
              s.blob &&
                (this.blob = function () {
                  var e = d(this);
                  if (e) return e;
                  if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                  if (this._bodyArrayBuffer)
                    return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                  if (!this._bodyFormData)
                    return Promise.resolve(new Blob([this._bodyText]));
                  throw Error("could not read FormData body as blob");
                }),
              (this.arrayBuffer = function () {
                if (this._bodyArrayBuffer) {
                  var e = d(this);
                  return (
                    e ||
                    (ArrayBuffer.isView(this._bodyArrayBuffer)
                      ? Promise.resolve(
                          this._bodyArrayBuffer.buffer.slice(
                            this._bodyArrayBuffer.byteOffset,
                            this._bodyArrayBuffer.byteOffset +
                              this._bodyArrayBuffer.byteLength
                          )
                        )
                      : Promise.resolve(this._bodyArrayBuffer))
                  );
                }
                if (s.blob) return this.blob().then(p);
                throw Error("could not read as ArrayBuffer");
              }),
              (this.text = function () {
                var e,
                  t,
                  r,
                  i,
                  s,
                  n = d(this);
                if (n) return n;
                if (this._bodyBlob)
                  return (
                    (e = this._bodyBlob),
                    (r = h((t = new FileReader()))),
                    (s = (i = /charset=([A-Za-z0-9_-]+)/.exec(e.type))
                      ? i[1]
                      : "utf-8"),
                    t.readAsText(e, s),
                    r
                  );
                if (this._bodyArrayBuffer)
                  return Promise.resolve(
                    (function (e) {
                      for (
                        var t = new Uint8Array(e), r = Array(t.length), i = 0;
                        i < t.length;
                        i++
                      )
                        r[i] = String.fromCharCode(t[i]);
                      return r.join("");
                    })(this._bodyArrayBuffer)
                  );
                if (!this._bodyFormData) return Promise.resolve(this._bodyText);
                throw Error("could not read FormData body as text");
              }),
              s.formData &&
                (this.formData = function () {
                  return this.text().then(b);
                }),
              (this.json = function () {
                return this.text().then(JSON.parse);
              }),
              this
            );
          }
          (u.prototype.append = function (e, t) {
            (e = o(e)), (t = c(t));
            var r = this.map[e];
            this.map[e] = r ? r + ", " + t : t;
          }),
            (u.prototype.delete = function (e) {
              delete this.map[o(e)];
            }),
            (u.prototype.get = function (e) {
              return (e = o(e)), this.has(e) ? this.map[e] : null;
            }),
            (u.prototype.has = function (e) {
              return this.map.hasOwnProperty(o(e));
            }),
            (u.prototype.set = function (e, t) {
              this.map[o(e)] = c(t);
            }),
            (u.prototype.forEach = function (e, t) {
              for (var r in this.map)
                this.map.hasOwnProperty(r) && e.call(t, this.map[r], r, this);
            }),
            (u.prototype.keys = function () {
              var e = [];
              return (
                this.forEach(function (t, r) {
                  e.push(r);
                }),
                l(e)
              );
            }),
            (u.prototype.values = function () {
              var e = [];
              return (
                this.forEach(function (t) {
                  e.push(t);
                }),
                l(e)
              );
            }),
            (u.prototype.entries = function () {
              var e = [];
              return (
                this.forEach(function (t, r) {
                  e.push([r, t]);
                }),
                l(e)
              );
            }),
            s.iterable && (u.prototype[Symbol.iterator] = u.prototype.entries);
          var m = [
            "CONNECT",
            "DELETE",
            "GET",
            "HEAD",
            "OPTIONS",
            "PATCH",
            "POST",
            "PUT",
            "TRACE",
          ];
          function y(e, t) {
            if (!(this instanceof y))
              throw TypeError(
                'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
              );
            var r,
              s,
              n = (t = t || {}).body;
            if (e instanceof y) {
              if (e.bodyUsed) throw TypeError("Already read");
              (this.url = e.url),
                (this.credentials = e.credentials),
                t.headers || (this.headers = new u(e.headers)),
                (this.method = e.method),
                (this.mode = e.mode),
                (this.signal = e.signal),
                n ||
                  null == e._bodyInit ||
                  ((n = e._bodyInit), (e.bodyUsed = !0));
            } else this.url = String(e);
            if (
              ((this.credentials =
                t.credentials || this.credentials || "same-origin"),
              (t.headers || !this.headers) && (this.headers = new u(t.headers)),
              (this.method =
                ((s = (r = t.method || this.method || "GET").toUpperCase()),
                m.indexOf(s) > -1 ? s : r)),
              (this.mode = t.mode || this.mode || null),
              (this.signal =
                t.signal ||
                this.signal ||
                (function () {
                  if ("AbortController" in i)
                    return new AbortController().signal;
                })()),
              (this.referrer = null),
              ("GET" === this.method || "HEAD" === this.method) && n)
            )
              throw TypeError("Body not allowed for GET or HEAD requests");
            if (
              (this._initBody(n),
              ("GET" === this.method || "HEAD" === this.method) &&
                ("no-store" === t.cache || "no-cache" === t.cache))
            ) {
              var a = /([?&])_=[^&]*/;
              a.test(this.url)
                ? (this.url = this.url.replace(
                    a,
                    "$1_=" + new Date().getTime()
                  ))
                : (this.url +=
                    (/\?/.test(this.url) ? "&" : "?") +
                    "_=" +
                    new Date().getTime());
            }
          }
          function b(e) {
            var t = new FormData();
            return (
              e
                .trim()
                .split("&")
                .forEach(function (e) {
                  if (e) {
                    var r = e.split("="),
                      i = r.shift().replace(/\+/g, " "),
                      s = r.join("=").replace(/\+/g, " ");
                    t.append(decodeURIComponent(i), decodeURIComponent(s));
                  }
                }),
              t
            );
          }
          function w(e, t) {
            if (!(this instanceof w))
              throw TypeError(
                'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
              );
            if (
              (t || (t = {}),
              (this.type = "default"),
              (this.status = void 0 === t.status ? 200 : t.status),
              this.status < 200 || this.status > 599)
            )
              throw RangeError(
                "Failed to construct 'Response': The status provided (0) is outside the range [200, 599]."
              );
            (this.ok = this.status >= 200 && this.status < 300),
              (this.statusText =
                void 0 === t.statusText ? "" : "" + t.statusText),
              (this.headers = new u(t.headers)),
              (this.url = t.url || ""),
              this._initBody(e);
          }
          (y.prototype.clone = function () {
            return new y(this, { body: this._bodyInit });
          }),
            g.call(y.prototype),
            g.call(w.prototype),
            (w.prototype.clone = function () {
              return new w(this._bodyInit, {
                status: this.status,
                statusText: this.statusText,
                headers: new u(this.headers),
                url: this.url,
              });
            }),
            (w.error = function () {
              var e = new w(null, { status: 200, statusText: "" });
              return (e.ok = !1), (e.status = 0), (e.type = "error"), e;
            });
          var v = [301, 302, 303, 307, 308];
          (w.redirect = function (e, t) {
            if (-1 === v.indexOf(t)) throw RangeError("Invalid status code");
            return new w(null, { status: t, headers: { location: e } });
          }),
            (t.DOMException = i.DOMException);
          try {
            new t.DOMException();
          } catch (e) {
            (t.DOMException = function (e, t) {
              (this.message = e), (this.name = t);
              var r = Error(e);
              this.stack = r.stack;
            }),
              (t.DOMException.prototype = Object.create(Error.prototype)),
              (t.DOMException.prototype.constructor = t.DOMException);
          }
          function E(e, r) {
            return new Promise(function (n, a) {
              var l = new y(e, r);
              if (l.signal && l.signal.aborted)
                return a(new t.DOMException("Aborted", "AbortError"));
              var d = new XMLHttpRequest();
              function h() {
                d.abort();
              }
              if (
                ((d.onload = function () {
                  var e,
                    t,
                    r = {
                      statusText: d.statusText,
                      headers:
                        ((e = d.getAllResponseHeaders() || ""),
                        (t = new u()),
                        e
                          .replace(/\r?\n[\t ]+/g, " ")
                          .split("\r")
                          .map(function (e) {
                            return 0 === e.indexOf("\n")
                              ? e.substr(1, e.length)
                              : e;
                          })
                          .forEach(function (e) {
                            var r = e.split(":"),
                              i = r.shift().trim();
                            if (i) {
                              var s = r.join(":").trim();
                              try {
                                t.append(i, s);
                              } catch (e) {
                                console.warn("Response " + e.message);
                              }
                            }
                          }),
                        t),
                    };
                  0 === l.url.indexOf("file://") &&
                  (d.status < 200 || d.status > 599)
                    ? (r.status = 200)
                    : (r.status = d.status),
                    (r.url =
                      "responseURL" in d
                        ? d.responseURL
                        : r.headers.get("X-Request-URL"));
                  var i = "response" in d ? d.response : d.responseText;
                  setTimeout(function () {
                    n(new w(i, r));
                  }, 0);
                }),
                (d.onerror = function () {
                  setTimeout(function () {
                    a(TypeError("Network request failed"));
                  }, 0);
                }),
                (d.ontimeout = function () {
                  setTimeout(function () {
                    a(TypeError("Network request timed out"));
                  }, 0);
                }),
                (d.onabort = function () {
                  setTimeout(function () {
                    a(new t.DOMException("Aborted", "AbortError"));
                  }, 0);
                }),
                d.open(
                  l.method,
                  (function (e) {
                    try {
                      return "" === e && i.location.href ? i.location.href : e;
                    } catch (t) {
                      return e;
                    }
                  })(l.url),
                  !0
                ),
                "include" === l.credentials
                  ? (d.withCredentials = !0)
                  : "omit" === l.credentials && (d.withCredentials = !1),
                "responseType" in d &&
                  (s.blob
                    ? (d.responseType = "blob")
                    : s.arrayBuffer && (d.responseType = "arraybuffer")),
                r &&
                  "object" == typeof r.headers &&
                  !(
                    r.headers instanceof u ||
                    (i.Headers && r.headers instanceof i.Headers)
                  ))
              ) {
                var p = [];
                Object.getOwnPropertyNames(r.headers).forEach(function (e) {
                  p.push(o(e)), d.setRequestHeader(e, c(r.headers[e]));
                }),
                  l.headers.forEach(function (e, t) {
                    -1 === p.indexOf(t) && d.setRequestHeader(t, e);
                  });
              } else
                l.headers.forEach(function (e, t) {
                  d.setRequestHeader(t, e);
                });
              l.signal &&
                (l.signal.addEventListener("abort", h),
                (d.onreadystatechange = function () {
                  4 === d.readyState &&
                    l.signal.removeEventListener("abort", h);
                })),
                d.send(void 0 === l._bodyInit ? null : l._bodyInit);
            });
          }
          (E.polyfill = !0),
            i.fetch ||
              ((i.fetch = E),
              (i.Headers = u),
              (i.Request = y),
              (i.Response = w)),
            (t.Headers = u),
            (t.Request = y),
            (t.Response = w),
            (t.fetch = E),
            Object.defineProperty(t, "__esModule", { value: !0 });
        })({});
      })(s),
        (s.fetch.ponyfill = !0),
        delete s.fetch.polyfill;
      var n = i.fetch ? i : s;
      ((t = n.fetch).default = n.fetch),
        (t.fetch = n.fetch),
        (t.Headers = n.Headers),
        (t.Request = n.Request),
        (t.Response = n.Response),
        (e.exports = t);
    },
    7610: (e, t) => {
      (t.read = function (e, t, r, i, s) {
        var n,
          a,
          o = 8 * s - i - 1,
          c = (1 << o) - 1,
          l = c >> 1,
          u = -7,
          d = r ? s - 1 : 0,
          h = r ? -1 : 1,
          p = e[t + d];
        for (
          d += h, n = p & ((1 << -u) - 1), p >>= -u, u += o;
          u > 0;
          n = 256 * n + e[t + d], d += h, u -= 8
        );
        for (
          a = n & ((1 << -u) - 1), n >>= -u, u += i;
          u > 0;
          a = 256 * a + e[t + d], d += h, u -= 8
        );
        if (0 === n) n = 1 - l;
        else {
          if (n === c) return a ? NaN : (1 / 0) * (p ? -1 : 1);
          (a += Math.pow(2, i)), (n -= l);
        }
        return (p ? -1 : 1) * a * Math.pow(2, n - i);
      }),
        (t.write = function (e, t, r, i, s, n) {
          var a,
            o,
            c,
            l = 8 * n - s - 1,
            u = (1 << l) - 1,
            d = u >> 1,
            h = 5960464477539062e-23 * (23 === s),
            p = i ? 0 : n - 1,
            f = i ? 1 : -1,
            g = +(t < 0 || (0 === t && 1 / t < 0));
          for (
            isNaN((t = Math.abs(t))) || t === 1 / 0
              ? ((o = +!!isNaN(t)), (a = u))
              : ((a = Math.floor(Math.log(t) / Math.LN2)),
                t * (c = Math.pow(2, -a)) < 1 && (a--, (c *= 2)),
                a + d >= 1 ? (t += h / c) : (t += h * Math.pow(2, 1 - d)),
                t * c >= 2 && (a++, (c /= 2)),
                a + d >= u
                  ? ((o = 0), (a = u))
                  : a + d >= 1
                  ? ((o = (t * c - 1) * Math.pow(2, s)), (a += d))
                  : ((o = t * Math.pow(2, d - 1) * Math.pow(2, s)), (a = 0)));
            s >= 8;
            e[r + p] = 255 & o, p += f, o /= 256, s -= 8
          );
          for (
            a = (a << s) | o, l += s;
            l > 0;
            e[r + p] = 255 & a, p += f, a /= 256, l -= 8
          );
          e[r + p - f] |= 128 * g;
        });
    },
    10231: (e, t, r) => {
      "use strict";
      async function i(e) {
        return new Promise((t) => setTimeout(t, e));
      }
      r.d(t, { u: () => i });
    },
    10351: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      let i = r(86313);
      i.__exportStar(r(27104), t), i.__exportStar(r(40052), t);
    },
    11076: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => d });
      var i = r(43708),
        s = r(76610),
        n = r(35558),
        a = r(92555),
        o = r(11501),
        c = r(90906),
        l = r(5517);
      let u = (0, i.BX)({
          currentTab: 0,
          tokenBalance: [],
          smartAccountDeployed: !1,
          addressLabels: new Map(),
          allAccounts: [],
        }),
        d = (0, a.X)({
          state: u,
          replaceState(e) {
            e && Object.assign(u, (0, i.KR)(e));
          },
          subscribe: (e) =>
            c.W.subscribeChainProp("accountState", (t) => {
              if (t) return e(t);
            }),
          subscribeKey(e, t, r) {
            let i;
            return c.W.subscribeChainProp(
              "accountState",
              (r) => {
                if (r) {
                  let s = r[e];
                  i !== s && ((i = s), t(s));
                }
              },
              r
            );
          },
          setStatus(e, t) {
            c.W.setAccountProp("status", e, t);
          },
          getCaipAddress: (e) => c.W.getAccountProp("caipAddress", e),
          setCaipAddress(e, t) {
            let r = e ? n.w.getPlainAddress(e) : void 0;
            t === c.W.state.activeChain && (c.W.state.activeCaipAddress = e),
              c.W.setAccountProp("caipAddress", e, t),
              c.W.setAccountProp("address", r, t);
          },
          setBalance(e, t, r) {
            c.W.setAccountProp("balance", e, r),
              c.W.setAccountProp("balanceSymbol", t, r);
          },
          setProfileName(e, t) {
            c.W.setAccountProp("profileName", e, t);
          },
          setProfileImage(e, t) {
            c.W.setAccountProp("profileImage", e, t);
          },
          setUser(e, t) {
            c.W.setAccountProp("user", e, t);
          },
          setAddressExplorerUrl(e, t) {
            c.W.setAccountProp("addressExplorerUrl", e, t);
          },
          setSmartAccountDeployed(e, t) {
            c.W.setAccountProp("smartAccountDeployed", e, t);
          },
          setCurrentTab(e) {
            c.W.setAccountProp("currentTab", e, c.W.state.activeChain);
          },
          setTokenBalance(e, t) {
            e && c.W.setAccountProp("tokenBalance", e, t);
          },
          setShouldUpdateToAddress(e, t) {
            c.W.setAccountProp("shouldUpdateToAddress", e, t);
          },
          setAllAccounts(e, t) {
            c.W.setAccountProp("allAccounts", e, t);
          },
          addAddressLabel(e, t, r) {
            let i = c.W.getAccountProp("addressLabels", r) || new Map();
            i.set(e, t), c.W.setAccountProp("addressLabels", i, r);
          },
          removeAddressLabel(e, t) {
            let r = c.W.getAccountProp("addressLabels", t) || new Map();
            r.delete(e), c.W.setAccountProp("addressLabels", r, t);
          },
          setConnectedWalletInfo(e, t) {
            c.W.setAccountProp("connectedWalletInfo", e, t, !1);
          },
          setPreferredAccountType(e, t) {
            c.W.setAccountProp(
              "preferredAccountTypes",
              { ...u.preferredAccountTypes, [t]: e },
              t
            );
          },
          setPreferredAccountTypes(e) {
            u.preferredAccountTypes = e;
          },
          setSocialProvider(e, t) {
            e && c.W.setAccountProp("socialProvider", e, t);
          },
          setSocialWindow(e, t) {
            c.W.setAccountProp("socialWindow", e ? (0, i.KR)(e) : void 0, t);
          },
          setFarcasterUrl(e, t) {
            c.W.setAccountProp("farcasterUrl", e, t);
          },
          async fetchTokenBalance(e) {
            u.balanceLoading = !0;
            let t = c.W.state.activeCaipNetwork?.caipNetworkId,
              r = c.W.state.activeCaipNetwork?.chainNamespace,
              i = c.W.state.activeCaipAddress,
              a = i ? n.w.getPlainAddress(i) : void 0;
            if (
              u.lastRetry &&
              !n.w.isAllowedRetry(u.lastRetry, 30 * s.oU.ONE_SEC_MS)
            )
              return (u.balanceLoading = !1), [];
            try {
              if (a && t && r) {
                let e = (await o.T.getBalance(a, t)).balances.filter(
                  (e) => "0" !== e.quantity.decimals
                );
                return (
                  d.setTokenBalance(e, r),
                  (u.lastRetry = void 0),
                  (u.balanceLoading = !1),
                  e
                );
              }
            } catch (t) {
              (u.lastRetry = Date.now()),
                e?.(t),
                l.P.showError("Token Balance Unavailable");
            } finally {
              u.balanceLoading = !1;
            }
            return [];
          },
          resetAccount(e) {
            c.W.resetAccount(e);
          },
        });
    },
    11501: (e, t, r) => {
      "use strict";
      r.d(t, { T: () => g });
      var i = r(43708),
        s = r(76610),
        n = r(35558),
        a = r(43359),
        o = r(5582),
        c = r(11076),
        l = r(90906),
        u = r(96641),
        d = r(5517);
      let h = {
          purchaseCurrencies: [
            {
              id: "2b92315d-eab7-5bef-84fa-089a131333f5",
              name: "USD Coin",
              symbol: "USDC",
              networks: [
                {
                  name: "ethereum-mainnet",
                  display_name: "Ethereum",
                  chain_id: "1",
                  contract_address:
                    "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
                },
                {
                  name: "polygon-mainnet",
                  display_name: "Polygon",
                  chain_id: "137",
                  contract_address:
                    "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
                },
              ],
            },
            {
              id: "2b92315d-eab7-5bef-84fa-089a131333f5",
              name: "Ether",
              symbol: "ETH",
              networks: [
                {
                  name: "ethereum-mainnet",
                  display_name: "Ethereum",
                  chain_id: "1",
                  contract_address:
                    "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
                },
                {
                  name: "polygon-mainnet",
                  display_name: "Polygon",
                  chain_id: "137",
                  contract_address:
                    "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
                },
              ],
            },
          ],
          paymentCurrencies: [
            {
              id: "USD",
              payment_method_limits: [
                { id: "card", min: "10.00", max: "7500.00" },
                { id: "ach_bank_account", min: "10.00", max: "25000.00" },
              ],
            },
            {
              id: "EUR",
              payment_method_limits: [
                { id: "card", min: "10.00", max: "7500.00" },
                { id: "ach_bank_account", min: "10.00", max: "25000.00" },
              ],
            },
          ],
        },
        p = n.w.getBlockchainApiUrl(),
        f = (0, i.BX)({
          clientId: null,
          api: new a.Z({ baseUrl: p, clientId: null }),
          supportedChains: { http: [], ws: [] },
        }),
        g = {
          state: f,
          async get(e) {
            let { st: t, sv: r } = g.getSdkProperties(),
              i = u.H.state.projectId,
              s = { ...(e.params || {}), st: t, sv: r, projectId: i };
            return f.api.get({ ...e, params: s });
          },
          getSdkProperties() {
            let { sdkType: e, sdkVersion: t } = u.H.state;
            return { st: e || "unknown", sv: t || "unknown" };
          },
          async isNetworkSupported(e) {
            if (!e) return !1;
            try {
              f.supportedChains.http.length || (await g.getSupportedNetworks());
            } catch (e) {
              return !1;
            }
            return f.supportedChains.http.includes(e);
          },
          async getSupportedNetworks() {
            try {
              let e = await g.get({ path: "v1/supported-chains" });
              return (f.supportedChains = e), e;
            } catch {
              return f.supportedChains;
            }
          },
          async fetchIdentity({ address: e, caipNetworkId: t }) {
            if (!(await g.isNetworkSupported(t)))
              return { avatar: "", name: "" };
            let r = o.i.getIdentityFromCacheForAddress(e);
            if (r) return r;
            let i = await g.get({
              path: `/v1/identity/${e}`,
              params: {
                sender: l.W.state.activeCaipAddress
                  ? n.w.getPlainAddress(l.W.state.activeCaipAddress)
                  : void 0,
              },
            });
            return (
              o.i.updateIdentityCache({
                address: e,
                identity: i,
                timestamp: Date.now(),
              }),
              i
            );
          },
          fetchTransactions: async ({
            account: e,
            cursor: t,
            onramp: r,
            signal: i,
            cache: s,
            chainId: n,
          }) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({
                  path: `/v1/account/${e}/history`,
                  params: { cursor: t, onramp: r, chainId: n },
                  signal: i,
                  cache: s,
                })
              : { data: [], next: void 0 },
          fetchSwapQuote: async ({
            amount: e,
            userAddress: t,
            from: r,
            to: i,
            gasPrice: s,
          }) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({
                  path: "/v1/convert/quotes",
                  headers: { "Content-Type": "application/json" },
                  params: {
                    amount: e,
                    userAddress: t,
                    from: r,
                    to: i,
                    gasPrice: s,
                  },
                })
              : { quotes: [] },
          fetchSwapTokens: async ({ chainId: e }) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({ path: "/v1/convert/tokens", params: { chainId: e } })
              : { tokens: [] },
          fetchTokenPrice: async ({ addresses: e }) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? f.api.post({
                  path: "/v1/fungible/price",
                  body: {
                    currency: "usd",
                    addresses: e,
                    projectId: u.H.state.projectId,
                  },
                  headers: { "Content-Type": "application/json" },
                })
              : { fungibles: [] },
          fetchSwapAllowance: async ({ tokenAddress: e, userAddress: t }) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({
                  path: "/v1/convert/allowance",
                  params: { tokenAddress: e, userAddress: t },
                  headers: { "Content-Type": "application/json" },
                })
              : { allowance: "0" },
          async fetchGasPrice({ chainId: e }) {
            let { st: t, sv: r } = g.getSdkProperties();
            if (
              !(await g.isNetworkSupported(
                l.W.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              throw Error("Network not supported for Gas Price");
            return g.get({
              path: "/v1/convert/gas-price",
              headers: { "Content-Type": "application/json" },
              params: { chainId: e, st: t, sv: r },
            });
          },
          async generateSwapCalldata({
            amount: e,
            from: t,
            to: r,
            userAddress: i,
            disableEstimate: n,
          }) {
            if (
              !(await g.isNetworkSupported(
                l.W.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              throw Error("Network not supported for Swaps");
            return f.api.post({
              path: "/v1/convert/build-transaction",
              headers: { "Content-Type": "application/json" },
              body: {
                amount: e,
                eip155: { slippage: s.oU.CONVERT_SLIPPAGE_TOLERANCE },
                projectId: u.H.state.projectId,
                from: t,
                to: r,
                userAddress: i,
                disableEstimate: n,
              },
            });
          },
          async generateApproveCalldata({ from: e, to: t, userAddress: r }) {
            let { st: i, sv: s } = g.getSdkProperties();
            if (
              !(await g.isNetworkSupported(
                l.W.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              throw Error("Network not supported for Swaps");
            return g.get({
              path: "/v1/convert/build-approve",
              headers: { "Content-Type": "application/json" },
              params: { userAddress: r, from: e, to: t, st: i, sv: s },
            });
          },
          async getBalance(e, t, r) {
            let { st: i, sv: s } = g.getSdkProperties();
            if (
              !(await g.isNetworkSupported(
                l.W.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              return (
                d.P.showError("Token Balance Unavailable"), { balances: [] }
              );
            let n = `${t}:${e}`,
              a = o.i.getBalanceCacheForCaipAddress(n);
            if (a) return a;
            let c = await g.get({
              path: `/v1/account/${e}/balance`,
              params: {
                currency: "usd",
                chainId: t,
                forceUpdate: r,
                st: i,
                sv: s,
              },
            });
            return (
              o.i.updateBalanceCache({
                caipAddress: n,
                balance: c,
                timestamp: Date.now(),
              }),
              c
            );
          },
          lookupEnsName: async (e) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({
                  path: `/v1/profile/account/${e}`,
                  params: { apiVersion: "2" },
                })
              : { addresses: {}, attributes: [] },
          reverseLookupEnsName: async ({ address: e }) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({
                  path: `/v1/profile/reverse/${e}`,
                  params: { sender: c.U.state.address, apiVersion: "2" },
                })
              : [],
          getEnsNameSuggestions: async (e) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({
                  path: `/v1/profile/suggestions/${e}`,
                  params: { zone: "reown.id" },
                })
              : { suggestions: [] },
          registerEnsName: async ({
            coinType: e,
            address: t,
            message: r,
            signature: i,
          }) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? f.api.post({
                  path: "/v1/profile/account",
                  body: { coin_type: e, address: t, message: r, signature: i },
                  headers: { "Content-Type": "application/json" },
                })
              : { success: !1 },
          generateOnRampURL: async ({
            destinationWallets: e,
            partnerUserId: t,
            defaultNetwork: r,
            purchaseAmount: i,
            paymentAmount: s,
          }) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? (
                  await f.api.post({
                    path: "/v1/generators/onrampurl",
                    params: { projectId: u.H.state.projectId },
                    body: {
                      destinationWallets: e,
                      defaultNetwork: r,
                      partnerUserId: t,
                      defaultExperience: "buy",
                      presetCryptoAmount: i,
                      presetFiatAmount: s,
                    },
                  })
                ).url
              : "",
          async getOnrampOptions() {
            if (
              !(await g.isNetworkSupported(
                l.W.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              return { paymentCurrencies: [], purchaseCurrencies: [] };
            try {
              return await g.get({ path: "/v1/onramp/options" });
            } catch (e) {
              return h;
            }
          },
          async getOnrampQuote({
            purchaseCurrency: e,
            paymentCurrency: t,
            amount: r,
            network: i,
          }) {
            try {
              if (
                !(await g.isNetworkSupported(
                  l.W.state.activeCaipNetwork?.caipNetworkId
                ))
              )
                return null;
              return await f.api.post({
                path: "/v1/onramp/quote",
                params: { projectId: u.H.state.projectId },
                body: {
                  purchaseCurrency: e,
                  paymentCurrency: t,
                  amount: r,
                  network: i,
                },
              });
            } catch (e) {
              return {
                coinbaseFee: { amount: r, currency: t.id },
                networkFee: { amount: r, currency: t.id },
                paymentSubtotal: { amount: r, currency: t.id },
                paymentTotal: { amount: r, currency: t.id },
                purchaseAmount: { amount: r, currency: t.id },
                quoteId: "mocked-quote-id",
              };
            }
          },
          getSmartSessions: async (e) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({ path: `/v1/sessions/${e}` })
              : [],
          revokeSmartSession: async (e, t, r) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? f.api.post({
                  path: `/v1/sessions/${e}/revoke`,
                  params: { projectId: u.H.state.projectId },
                  body: { pci: t, signature: r },
                })
              : { success: !1 },
          setClientId(e) {
            (f.clientId = e), (f.api = new a.Z({ baseUrl: p, clientId: e }));
          },
        };
    },
    16784: (e, t, r) => {
      "use strict";
      let i = r(68928);
      e.exports = n;
      let s =
        (function () {
          function e(e) {
            return void 0 !== e && e;
          }
          try {
            if ("undefined" != typeof globalThis) return globalThis;
            return (
              Object.defineProperty(Object.prototype, "globalThis", {
                get: function () {
                  return (
                    delete Object.prototype.globalThis, (this.globalThis = this)
                  );
                },
                configurable: !0,
              }),
              globalThis
            );
          } catch (t) {
            return e(self) || e(window) || e(this) || {};
          }
        })().console || {};
      function n(e) {
        var t, r;
        (e = e || {}).browser = e.browser || {};
        let i = e.browser.transmit;
        if (i && "function" != typeof i.send)
          throw Error("pino: transmit option must have a send function");
        let u = e.browser.write || s;
        e.browser.write && (e.browser.asObject = !0);
        let d = e.serializers || {},
          g =
            ((t = e.browser.serialize),
            Array.isArray(t)
              ? t.filter(function (e) {
                  return "!stdSerializers.err" !== e;
                })
              : !0 === t && Object.keys(d)),
          m = e.browser.serialize;
        Array.isArray(e.browser.serialize) &&
          e.browser.serialize.indexOf("!stdSerializers.err") > -1 &&
          (m = !1),
          "function" == typeof u &&
            (u.error = u.fatal = u.warn = u.info = u.debug = u.trace = u),
          !1 === e.enabled && (e.level = "silent");
        let y = e.level || "info",
          b = Object.create(u);
        b.log || (b.log = h),
          Object.defineProperty(b, "levelVal", {
            get: function () {
              return "silent" === this.level
                ? 1 / 0
                : this.levels.values[this.level];
            },
          }),
          Object.defineProperty(b, "level", {
            get: function () {
              return this._level;
            },
            set: function (e) {
              if ("silent" !== e && !this.levels.values[e])
                throw Error("unknown level " + e);
              (this._level = e),
                a(w, b, "error", "log"),
                a(w, b, "fatal", "error"),
                a(w, b, "warn", "error"),
                a(w, b, "info", "log"),
                a(w, b, "debug", "log"),
                a(w, b, "trace", "log");
            },
          });
        let w = {
          transmit: i,
          serialize: g,
          asObject: e.browser.asObject,
          levels: ["error", "fatal", "warn", "info", "debug", "trace"],
          timestamp:
            "function" == typeof (r = e).timestamp
              ? r.timestamp
              : !1 === r.timestamp
              ? p
              : f,
        };
        return (
          (b.levels = n.levels),
          (b.level = y),
          (b.setMaxListeners =
            b.getMaxListeners =
            b.emit =
            b.addListener =
            b.on =
            b.prependListener =
            b.once =
            b.prependOnceListener =
            b.removeListener =
            b.removeAllListeners =
            b.listeners =
            b.listenerCount =
            b.eventNames =
            b.write =
            b.flush =
              h),
          (b.serializers = d),
          (b._serialize = g),
          (b._stdErrSerialize = m),
          (b.child = function (t, r) {
            if (!t) throw Error("missing bindings for child Pino");
            (r = r || {}),
              g && t.serializers && (r.serializers = t.serializers);
            let s = r.serializers;
            if (g && s) {
              var n = Object.assign({}, d, s),
                a = !0 === e.browser.serialize ? Object.keys(n) : g;
              delete t.serializers, o([t], a, n, this._stdErrSerialize);
            }
            function u(e) {
              (this._childLevel = (0 | e._childLevel) + 1),
                (this.error = c(e, t, "error")),
                (this.fatal = c(e, t, "fatal")),
                (this.warn = c(e, t, "warn")),
                (this.info = c(e, t, "info")),
                (this.debug = c(e, t, "debug")),
                (this.trace = c(e, t, "trace")),
                n && ((this.serializers = n), (this._serialize = a)),
                i && (this._logEvent = l([].concat(e._logEvent.bindings, t)));
            }
            return (u.prototype = this), new u(this);
          }),
          i && (b._logEvent = l()),
          b
        );
      }
      function a(e, t, r, a) {
        let c = Object.getPrototypeOf(t);
        (t[r] =
          t.levelVal > t.levels.values[r]
            ? h
            : c[r]
            ? c[r]
            : s[r] || s[a] || h),
          (function (e, t, r) {
            if (e.transmit || t[r] !== h) {
              var a;
              t[r] =
                ((a = t[r]),
                function () {
                  let c = e.timestamp(),
                    u = Array(arguments.length),
                    d =
                      Object.getPrototypeOf && Object.getPrototypeOf(this) === s
                        ? s
                        : this;
                  for (var h = 0; h < u.length; h++) u[h] = arguments[h];
                  if (
                    (e.serialize &&
                      !e.asObject &&
                      o(
                        u,
                        this._serialize,
                        this.serializers,
                        this._stdErrSerialize
                      ),
                    e.asObject
                      ? a.call(
                          d,
                          (function (e, t, r, s) {
                            e._serialize &&
                              o(
                                r,
                                e._serialize,
                                e.serializers,
                                e._stdErrSerialize
                              );
                            let a = r.slice(),
                              c = a[0],
                              l = {};
                            s && (l.time = s), (l.level = n.levels.values[t]);
                            let u = (0 | e._childLevel) + 1;
                            if (
                              (u < 1 && (u = 1),
                              null !== c && "object" == typeof c)
                            ) {
                              for (; u-- && "object" == typeof a[0]; )
                                Object.assign(l, a.shift());
                              c = a.length ? i(a.shift(), a) : void 0;
                            } else
                              "string" == typeof c && (c = i(a.shift(), a));
                            return void 0 !== c && (l.msg = c), l;
                          })(this, r, u, c)
                        )
                      : a.apply(d, u),
                    e.transmit)
                  ) {
                    let i = e.transmit.level || t.level,
                      s = n.levels.values[i],
                      a = n.levels.values[r];
                    if (a < s) return;
                    !(function (e, t, r) {
                      let i = t.send,
                        s = t.ts,
                        n = t.methodLevel,
                        a = t.methodValue,
                        c = t.val,
                        u = e._logEvent.bindings;
                      o(
                        r,
                        e._serialize || Object.keys(e.serializers),
                        e.serializers,
                        void 0 === e._stdErrSerialize || e._stdErrSerialize
                      ),
                        (e._logEvent.ts = s),
                        (e._logEvent.messages = r.filter(function (e) {
                          return -1 === u.indexOf(e);
                        })),
                        (e._logEvent.level.label = n),
                        (e._logEvent.level.value = a),
                        i(n, e._logEvent, c),
                        (e._logEvent = l(u));
                    })(
                      this,
                      {
                        ts: c,
                        methodLevel: r,
                        methodValue: a,
                        transmitLevel: i,
                        transmitValue:
                          n.levels.values[e.transmit.level || t.level],
                        send: e.transmit.send,
                        val: t.levelVal,
                      },
                      u
                    );
                  }
                });
            }
          })(e, t, r);
      }
      function o(e, t, r, i) {
        for (let s in e)
          if (i && e[s] instanceof Error) e[s] = n.stdSerializers.err(e[s]);
          else if ("object" == typeof e[s] && !Array.isArray(e[s]))
            for (let i in e[s])
              t && t.indexOf(i) > -1 && i in r && (e[s][i] = r[i](e[s][i]));
      }
      function c(e, t, r) {
        return function () {
          let i = Array(1 + arguments.length);
          i[0] = t;
          for (var s = 1; s < i.length; s++) i[s] = arguments[s - 1];
          return e[r].apply(this, i);
        };
      }
      function l(e) {
        return {
          ts: 0,
          messages: [],
          bindings: e || [],
          level: { label: "", value: 0 },
        };
      }
      function u() {
        return {};
      }
      function d(e) {
        return e;
      }
      function h() {}
      function p() {
        return !1;
      }
      function f() {
        return Date.now();
      }
      (n.levels = {
        values: {
          fatal: 60,
          error: 50,
          warn: 40,
          info: 30,
          debug: 20,
          trace: 10,
        },
        labels: {
          10: "trace",
          20: "debug",
          30: "info",
          40: "warn",
          50: "error",
          60: "fatal",
        },
      }),
        (n.stdSerializers = {
          mapHttpRequest: u,
          mapHttpResponse: u,
          wrapRequestSerializer: d,
          wrapResponseSerializer: d,
          wrapErrorSerializer: d,
          req: u,
          res: u,
          err: function (e) {
            let t = {
              type: e.constructor.name,
              msg: e.message,
              stack: e.stack,
            };
            for (let r in e) void 0 === t[r] && (t[r] = e[r]);
            return t;
          },
        }),
        (n.stdTimeFunctions = Object.assign(
          {},
          {
            nullTime: p,
            epochTime: f,
            unixTime: function () {
              return Math.round(Date.now() / 1e3);
            },
            isoTime: function () {
              return new Date(Date.now()).toISOString();
            },
          }
        ));
    },
    18224: (e, t, r) => {
      "use strict";
      function i(e) {
        return e.state.chainId;
      }
      r.d(t, { i: () => a });
      var s = r(12115),
        n = r(53031);
      function a() {
        let e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          t = (0, n.U)(e);
        return (0, s.useSyncExternalStore)(
          (e) =>
            (function (e, t) {
              let { onChange: r } = t;
              return e.subscribe((e) => e.chainId, r);
            })(t, { onChange: e }),
          () => i(t),
          () => i(t)
        );
      }
    },
    18227: (e, t, r) => {
      "use strict";
      r.d(t, { S: () => f });
      var i = "[big.js] ",
        s = i + "Invalid ",
        n = s + "decimal places",
        a = s + "rounding mode",
        o = i + "Division by zero",
        c = {},
        l = void 0,
        u = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
      function d(e, t, r, i) {
        var s = e.c;
        if (
          (r === l && (r = e.constructor.RM),
          0 !== r && 1 !== r && 2 !== r && 3 !== r)
        )
          throw Error(a);
        if (t < 1)
          (i =
            (3 === r && (i || !!s[0])) ||
            (0 === t &&
              ((1 === r && s[0] >= 5) ||
                (2 === r && (s[0] > 5 || (5 === s[0] && (i || s[1] !== l))))))),
            (s.length = 1),
            i ? ((e.e = e.e - t + 1), (s[0] = 1)) : (s[0] = e.e = 0);
        else if (t < s.length) {
          if (
            ((i =
              (1 === r && s[t] >= 5) ||
              (2 === r &&
                (s[t] > 5 ||
                  (5 === s[t] && (i || s[t + 1] !== l || 1 & s[t - 1])))) ||
              (3 === r && (i || !!s[0]))),
            (s.length = t),
            i)
          ) {
            for (; ++s[--t] > 9; )
              if (((s[t] = 0), 0 === t)) {
                ++e.e, s.unshift(1);
                break;
              }
          }
          for (t = s.length; !s[--t]; ) s.pop();
        }
        return e;
      }
      function h(e, t, r) {
        var i = e.e,
          s = e.c.join(""),
          n = s.length;
        if (t)
          s =
            s.charAt(0) +
            (n > 1 ? "." + s.slice(1) : "") +
            (i < 0 ? "e" : "e+") +
            i;
        else if (i < 0) {
          for (; ++i; ) s = "0" + s;
          s = "0." + s;
        } else if (i > 0)
          if (++i > n) for (i -= n; i--; ) s += "0";
          else i < n && (s = s.slice(0, i) + "." + s.slice(i));
        else n > 1 && (s = s.charAt(0) + "." + s.slice(1));
        return e.s < 0 && r ? "-" + s : s;
      }
      (c.abs = function () {
        var e = new this.constructor(this);
        return (e.s = 1), e;
      }),
        (c.cmp = function (e) {
          var t,
            r = this.c,
            i = (e = new this.constructor(e)).c,
            s = this.s,
            n = e.s,
            a = this.e,
            o = e.e;
          if (!r[0] || !i[0]) return r[0] ? s : i[0] ? -n : 0;
          if (s != n) return s;
          if (((t = s < 0), a != o)) return (a > o) ^ t ? 1 : -1;
          for (s = -1, n = (a = r.length) < (o = i.length) ? a : o; ++s < n; )
            if (r[s] != i[s]) return (r[s] > i[s]) ^ t ? 1 : -1;
          return a == o ? 0 : (a > o) ^ t ? 1 : -1;
        }),
        (c.div = function (e) {
          var t = this.constructor,
            r = this.c,
            i = (e = new t(e)).c,
            s = this.s == e.s ? 1 : -1,
            a = t.DP;
          if (a !== ~~a || a < 0 || a > 1e6) throw Error(n);
          if (!i[0]) throw Error(o);
          if (!r[0]) return (e.s = s), (e.c = [(e.e = 0)]), e;
          var c,
            u,
            h,
            p,
            f,
            g = i.slice(),
            m = (c = i.length),
            y = r.length,
            b = r.slice(0, c),
            w = b.length,
            v = e,
            E = (v.c = []),
            _ = 0,
            C = a + (v.e = this.e - e.e) + 1;
          for (v.s = s, s = C < 0 ? 0 : C, g.unshift(0); w++ < c; ) b.push(0);
          do {
            for (h = 0; h < 10; h++) {
              if (c != (w = b.length)) p = c > w ? 1 : -1;
              else
                for (f = -1, p = 0; ++f < c; )
                  if (i[f] != b[f]) {
                    p = i[f] > b[f] ? 1 : -1;
                    break;
                  }
              if (p < 0) {
                for (u = w == c ? i : g; w; ) {
                  if (b[--w] < u[w]) {
                    for (f = w; f && !b[--f]; ) b[f] = 9;
                    --b[f], (b[w] += 10);
                  }
                  b[w] -= u[w];
                }
                for (; !b[0]; ) b.shift();
              } else break;
            }
            (E[_++] = p ? h : ++h),
              b[0] && p ? (b[w] = r[m] || 0) : (b = [r[m]]);
          } while ((m++ < y || b[0] !== l) && s--);
          return (
            !E[0] && 1 != _ && (E.shift(), v.e--, C--),
            _ > C && d(v, C, t.RM, b[0] !== l),
            v
          );
        }),
        (c.eq = function (e) {
          return 0 === this.cmp(e);
        }),
        (c.gt = function (e) {
          return this.cmp(e) > 0;
        }),
        (c.gte = function (e) {
          return this.cmp(e) > -1;
        }),
        (c.lt = function (e) {
          return 0 > this.cmp(e);
        }),
        (c.lte = function (e) {
          return 1 > this.cmp(e);
        }),
        (c.minus = c.sub =
          function (e) {
            var t,
              r,
              i,
              s,
              n = this.constructor,
              a = this.s,
              o = (e = new n(e)).s;
            if (a != o) return (e.s = -o), this.plus(e);
            var c = this.c.slice(),
              l = this.e,
              u = e.c,
              d = e.e;
            if (!c[0] || !u[0])
              return (
                u[0] ? (e.s = -o) : c[0] ? (e = new n(this)) : (e.s = 1), e
              );
            if ((a = l - d)) {
              for (
                (s = a < 0) ? ((a = -a), (i = c)) : ((d = l), (i = u)),
                  i.reverse(),
                  o = a;
                o--;

              )
                i.push(0);
              i.reverse();
            } else
              for (
                r = ((s = c.length < u.length) ? c : u).length, a = o = 0;
                o < r;
                o++
              )
                if (c[o] != u[o]) {
                  s = c[o] < u[o];
                  break;
                }
            if (
              (s && ((i = c), (c = u), (u = i), (e.s = -e.s)),
              (o = (r = u.length) - (t = c.length)) > 0)
            )
              for (; o--; ) c[t++] = 0;
            for (o = t; r > a; ) {
              if (c[--r] < u[r]) {
                for (t = r; t && !c[--t]; ) c[t] = 9;
                --c[t], (c[r] += 10);
              }
              c[r] -= u[r];
            }
            for (; 0 === c[--o]; ) c.pop();
            for (; 0 === c[0]; ) c.shift(), --d;
            return (
              c[0] || ((e.s = 1), (c = [(d = 0)])), (e.c = c), (e.e = d), e
            );
          }),
        (c.mod = function (e) {
          var t,
            r = this,
            i = r.constructor,
            s = r.s,
            n = (e = new i(e)).s;
          if (!e.c[0]) throw Error(o);
          return ((r.s = e.s = 1), (t = 1 == e.cmp(r)), (r.s = s), (e.s = n), t)
            ? new i(r)
            : ((s = i.DP),
              (n = i.RM),
              (i.DP = i.RM = 0),
              (r = r.div(e)),
              (i.DP = s),
              (i.RM = n),
              this.minus(r.times(e)));
        }),
        (c.neg = function () {
          var e = new this.constructor(this);
          return (e.s = -e.s), e;
        }),
        (c.plus = c.add =
          function (e) {
            var t,
              r,
              i,
              s = this.constructor;
            if (((e = new s(e)), this.s != e.s))
              return (e.s = -e.s), this.minus(e);
            var n = this.e,
              a = this.c,
              o = e.e,
              c = e.c;
            if (!a[0] || !c[0])
              return c[0] || (a[0] ? (e = new s(this)) : (e.s = this.s)), e;
            if (((a = a.slice()), (t = n - o))) {
              for (
                t > 0 ? ((o = n), (i = c)) : ((t = -t), (i = a)), i.reverse();
                t--;

              )
                i.push(0);
              i.reverse();
            }
            for (
              a.length - c.length < 0 && ((i = c), (c = a), (a = i)),
                t = c.length,
                r = 0;
              t;
              a[t] %= 10
            )
              r = ((a[--t] = a[t] + c[t] + r) / 10) | 0;
            for (r && (a.unshift(r), ++o), t = a.length; 0 === a[--t]; )
              a.pop();
            return (e.c = a), (e.e = o), e;
          }),
        (c.pow = function (e) {
          var t = this,
            r = new t.constructor("1"),
            i = r,
            n = e < 0;
          if (e !== ~~e || e < -1e6 || e > 1e6) throw Error(s + "exponent");
          for (n && (e = -e); 1 & e && (i = i.times(t)), (e >>= 1); )
            t = t.times(t);
          return n ? r.div(i) : i;
        }),
        (c.prec = function (e, t) {
          if (e !== ~~e || e < 1 || e > 1e6) throw Error(s + "precision");
          return d(new this.constructor(this), e, t);
        }),
        (c.round = function (e, t) {
          if (e === l) e = 0;
          else if (e !== ~~e || e < -1e6 || e > 1e6) throw Error(n);
          return d(new this.constructor(this), e + this.e + 1, t);
        }),
        (c.sqrt = function () {
          var e,
            t,
            r,
            s = this.constructor,
            n = this.s,
            a = this.e,
            o = new s("0.5");
          if (!this.c[0]) return new s(this);
          if (n < 0) throw Error(i + "No square root");
          0 === (n = Math.sqrt(+h(this, !0, !0))) || n === 1 / 0
            ? (((t = this.c.join("")).length + a) & 1 || (t += "0"),
              (a = (((a + 1) / 2) | 0) - (a < 0 || 1 & a)),
              (e = new s(
                ((n = Math.sqrt(t)) == 1 / 0
                  ? "5e"
                  : (n = n.toExponential()).slice(0, n.indexOf("e") + 1)) + a
              )))
            : (e = new s(n + "")),
            (a = e.e + (s.DP += 4));
          do (r = e), (e = o.times(r.plus(this.div(r))));
          while (r.c.slice(0, a).join("") !== e.c.slice(0, a).join(""));
          return d(e, (s.DP -= 4) + e.e + 1, s.RM);
        }),
        (c.times = c.mul =
          function (e) {
            var t,
              r = this.constructor,
              i = this.c,
              s = (e = new r(e)).c,
              n = i.length,
              a = s.length,
              o = this.e,
              c = e.e;
            if (((e.s = this.s == e.s ? 1 : -1), !i[0] || !s[0]))
              return (e.c = [(e.e = 0)]), e;
            for (
              e.e = o + c,
                n < a && ((t = i), (i = s), (s = t), (c = n), (n = a), (a = c)),
                t = Array((c = n + a));
              c--;

            )
              t[c] = 0;
            for (o = a; o--; ) {
              for (a = 0, c = n + o; c > o; )
                (a = t[c] + s[o] * i[c - o - 1] + a),
                  (t[c--] = a % 10),
                  (a = (a / 10) | 0);
              t[c] = a;
            }
            for (a ? ++e.e : t.shift(), o = t.length; !t[--o]; ) t.pop();
            return (e.c = t), e;
          }),
        (c.toExponential = function (e, t) {
          var r = this,
            i = r.c[0];
          if (e !== l) {
            if (e !== ~~e || e < 0 || e > 1e6) throw Error(n);
            for (r = d(new r.constructor(r), ++e, t); r.c.length < e; )
              r.c.push(0);
          }
          return h(r, !0, !!i);
        }),
        (c.toFixed = function (e, t) {
          var r = this,
            i = r.c[0];
          if (e !== l) {
            if (e !== ~~e || e < 0 || e > 1e6) throw Error(n);
            for (
              r = d(new r.constructor(r), e + r.e + 1, t), e = e + r.e + 1;
              r.c.length < e;

            )
              r.c.push(0);
          }
          return h(r, !1, !!i);
        }),
        (c[Symbol.for("nodejs.util.inspect.custom")] =
          c.toJSON =
          c.toString =
            function () {
              var e = this.constructor;
              return h(this, this.e <= e.NE || this.e >= e.PE, !!this.c[0]);
            }),
        (c.toNumber = function () {
          var e = +h(this, !0, !0);
          if (!0 === this.constructor.strict && !this.eq(e.toString()))
            throw Error(i + "Imprecise conversion");
          return e;
        }),
        (c.toPrecision = function (e, t) {
          var r = this,
            i = r.constructor,
            n = r.c[0];
          if (e !== l) {
            if (e !== ~~e || e < 1 || e > 1e6) throw Error(s + "precision");
            for (r = d(new i(r), e, t); r.c.length < e; ) r.c.push(0);
          }
          return h(r, e <= r.e || r.e <= i.NE || r.e >= i.PE, !!n);
        }),
        (c.valueOf = function () {
          var e = this.constructor;
          if (!0 === e.strict) throw Error(i + "valueOf disallowed");
          return h(this, this.e <= e.NE || this.e >= e.PE, !0);
        });
      var p = (function e() {
        function t(r) {
          if (!(this instanceof t)) return r === l ? e() : new t(r);
          if (r instanceof t)
            (this.s = r.s), (this.e = r.e), (this.c = r.c.slice());
          else {
            if ("string" != typeof r) {
              if (!0 === t.strict && "bigint" != typeof r)
                throw TypeError(s + "value");
              r = 0 === r && 1 / r < 0 ? "-0" : String(r);
            }
            !(function (e, t) {
              var r, i, n;
              if (!u.test(t)) throw Error(s + "number");
              for (
                e.s = "-" == t.charAt(0) ? ((t = t.slice(1)), -1) : 1,
                  (r = t.indexOf(".")) > -1 && (t = t.replace(".", "")),
                  (i = t.search(/e/i)) > 0
                    ? (r < 0 && (r = i),
                      (r += +t.slice(i + 1)),
                      (t = t.substring(0, i)))
                    : r < 0 && (r = t.length),
                  n = t.length,
                  i = 0;
                i < n && "0" == t.charAt(i);

              )
                ++i;
              if (i == n) e.c = [(e.e = 0)];
              else {
                for (; n > 0 && "0" == t.charAt(--n); );
                for (e.e = r - i - 1, e.c = [], r = 0; i <= n; )
                  e.c[r++] = +t.charAt(i++);
              }
            })(this, r);
          }
          this.constructor = t;
        }
        return (
          (t.prototype = c),
          (t.DP = 20),
          (t.RM = 1),
          (t.NE = -7),
          (t.PE = 21),
          (t.strict = !1),
          (t.roundDown = 0),
          (t.roundHalfUp = 1),
          (t.roundHalfEven = 2),
          (t.roundUp = 3),
          t
        );
      })();
      let f = {
        bigNumber: (e) => new p(e ? e : 0),
        multiply(e, t) {
          if (void 0 === e || void 0 === t) return new p(0);
          let r = new p(e),
            i = new p(t);
          return r.times(i);
        },
        formatNumberToLocalString: (e, t = 2) =>
          void 0 === e
            ? "0.00"
            : "number" == typeof e
            ? e.toLocaleString("en-US", {
                maximumFractionDigits: t,
                minimumFractionDigits: t,
              })
            : parseFloat(e).toLocaleString("en-US", {
                maximumFractionDigits: t,
                minimumFractionDigits: t,
              }),
        parseLocalStringToNumber: (e) =>
          void 0 === e ? 0 : parseFloat(e.replace(/,/gu, "")),
      };
    },
    19405: (e, t, r) => {
      "use strict";
      function i(e) {
        return "string" == typeof e ? { address: e, type: "json-rpc" } : e;
      }
      r.d(t, { J: () => i });
    },
    19628: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => h });
      var i = r(43708),
        s = r(70799),
        n = r(92555),
        a = r(11076),
        o = r(90906),
        c = r(54252),
        l = r(33806),
        u = r(96641);
      let d = (0, i.BX)({
          view: "Connect",
          history: ["Connect"],
          transactionStack: [],
        }),
        h = (0, n.X)({
          state: d,
          subscribeKey: (e, t) => (0, s.u$)(d, e, t),
          pushTransactionStack(e) {
            d.transactionStack.push(e);
          },
          popTransactionStack(e) {
            let t = d.transactionStack.pop();
            if (!t) return;
            let { onSuccess: r, onError: i, onCancel: s } = t;
            switch (e) {
              case "success":
                r?.();
                break;
              case "error":
                i?.(), h.goBack();
                break;
              case "cancel":
                s?.(), h.goBack();
            }
          },
          push(e, t) {
            e !== d.view && ((d.view = e), d.history.push(e), (d.data = t));
          },
          reset(e, t) {
            (d.view = e), (d.history = [e]), (d.data = t);
          },
          replace(e, t) {
            d.history.at(-1) !== e &&
              ((d.view = e),
              (d.history[d.history.length - 1] = e),
              (d.data = t));
          },
          goBack() {
            let e = o.W.state.activeCaipAddress,
              t = "ConnectingFarcaster" === h.state.view,
              r = !e && t;
            if (d.history.length > 1) {
              d.history.pop();
              let [t] = d.history.slice(-1);
              t && (e && "Connect" === t ? (d.view = "Account") : (d.view = t));
            } else l.W.close();
            d.data?.wallet && (d.data.wallet = void 0),
              setTimeout(() => {
                if (r) {
                  a.U.setFarcasterUrl(void 0, o.W.state.activeChain);
                  let e = c.a.getAuthConnector();
                  e?.provider?.reload();
                  let t = (0, i.P9)(u.H.state);
                  e?.provider?.syncDappData?.({
                    metadata: t.metadata,
                    sdkVersion: t.sdkVersion,
                    projectId: t.projectId,
                    sdkType: t.sdkType,
                  });
                }
              }, 100);
          },
          goBackToIndex(e) {
            if (d.history.length > 1) {
              d.history = d.history.slice(0, e + 1);
              let [t] = d.history.slice(-1);
              t && (d.view = t);
            }
          },
          goBackOrCloseModal() {
            h.state.history.length > 1 ? h.goBack() : l.W.close();
          },
        });
    },
    19655: (e, t, r) => {
      "use strict";
      r.d(t, {
        D5: () => I,
        U5: () => A,
        h6: () => s.a,
        iP: () => _,
        oI: () => C,
      });
      var i = r(16784),
        s = r.n(i),
        n = r(71075);
      let a = { level: "info" },
        o = "custom_context";
      class c {
        constructor(e) {
          (this.nodeValue = e),
            (this.sizeInBytes = new TextEncoder().encode(
              this.nodeValue
            ).length),
            (this.next = null);
        }
        get value() {
          return this.nodeValue;
        }
        get size() {
          return this.sizeInBytes;
        }
      }
      class l {
        constructor(e) {
          (this.head = null),
            (this.tail = null),
            (this.lengthInNodes = 0),
            (this.maxSizeInBytes = e),
            (this.sizeInBytes = 0);
        }
        append(e) {
          let t = new c(e);
          if (t.size > this.maxSizeInBytes)
            throw Error(
              `[LinkedList] Value too big to insert into list: ${e} with size ${t.size}`
            );
          for (; this.size + t.size > this.maxSizeInBytes; ) this.shift();
          this.head ? this.tail && (this.tail.next = t) : (this.head = t),
            (this.tail = t),
            this.lengthInNodes++,
            (this.sizeInBytes += t.size);
        }
        shift() {
          if (!this.head) return;
          let e = this.head;
          (this.head = this.head.next),
            this.head || (this.tail = null),
            this.lengthInNodes--,
            (this.sizeInBytes -= e.size);
        }
        toArray() {
          let e = [],
            t = this.head;
          for (; null !== t; ) e.push(t.value), (t = t.next);
          return e;
        }
        get length() {
          return this.lengthInNodes;
        }
        get size() {
          return this.sizeInBytes;
        }
        toOrderedArray() {
          return Array.from(this);
        }
        [Symbol.iterator]() {
          let e = this.head;
          return {
            next: () => {
              if (!e) return { done: !0, value: null };
              let t = e.value;
              return (e = e.next), { done: !1, value: t };
            },
          };
        }
      }
      class u {
        constructor(e, t = 1024e3) {
          (this.level = e ?? "error"),
            (this.levelValue = i.levels.values[this.level]),
            (this.MAX_LOG_SIZE_IN_BYTES = t),
            (this.logs = new l(this.MAX_LOG_SIZE_IN_BYTES));
        }
        forwardToConsole(e, t) {
          t === i.levels.values.error
            ? console.error(e)
            : t === i.levels.values.warn
            ? console.warn(e)
            : t === i.levels.values.debug
            ? console.debug(e)
            : t === i.levels.values.trace
            ? console.trace(e)
            : console.log(e);
        }
        appendToLogs(e) {
          this.logs.append(
            (0, n.h)({ timestamp: new Date().toISOString(), log: e })
          );
          let t = "string" == typeof e ? JSON.parse(e).level : e.level;
          t >= this.levelValue && this.forwardToConsole(e, t);
        }
        getLogs() {
          return this.logs;
        }
        clearLogs() {
          this.logs = new l(this.MAX_LOG_SIZE_IN_BYTES);
        }
        getLogArray() {
          return Array.from(this.logs);
        }
        logsToBlob(e) {
          let t = this.getLogArray();
          return (
            t.push((0, n.h)({ extraMetadata: e })),
            new Blob(t, { type: "application/json" })
          );
        }
      }
      class d {
        constructor(e, t = 1024e3) {
          this.baseChunkLogger = new u(e, t);
        }
        write(e) {
          this.baseChunkLogger.appendToLogs(e);
        }
        getLogs() {
          return this.baseChunkLogger.getLogs();
        }
        clearLogs() {
          this.baseChunkLogger.clearLogs();
        }
        getLogArray() {
          return this.baseChunkLogger.getLogArray();
        }
        logsToBlob(e) {
          return this.baseChunkLogger.logsToBlob(e);
        }
        downloadLogsBlobInBrowser(e) {
          let t = URL.createObjectURL(this.logsToBlob(e)),
            r = document.createElement("a");
          (r.href = t),
            (r.download = `walletconnect-logs-${new Date().toISOString()}.txt`),
            document.body.appendChild(r),
            r.click(),
            document.body.removeChild(r),
            URL.revokeObjectURL(t);
        }
      }
      class h {
        constructor(e, t = 1024e3) {
          this.baseChunkLogger = new u(e, t);
        }
        write(e) {
          this.baseChunkLogger.appendToLogs(e);
        }
        getLogs() {
          return this.baseChunkLogger.getLogs();
        }
        clearLogs() {
          this.baseChunkLogger.clearLogs();
        }
        getLogArray() {
          return this.baseChunkLogger.getLogArray();
        }
        logsToBlob(e) {
          return this.baseChunkLogger.logsToBlob(e);
        }
      }
      var p = Object.defineProperty,
        f = Object.defineProperties,
        g = Object.getOwnPropertyDescriptors,
        m = Object.getOwnPropertySymbols,
        y = Object.prototype.hasOwnProperty,
        b = Object.prototype.propertyIsEnumerable,
        w = (e, t, r) =>
          t in e
            ? p(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        v = (e, t) => {
          for (var r in t || (t = {})) y.call(t, r) && w(e, r, t[r]);
          if (m) for (var r of m(t)) b.call(t, r) && w(e, r, t[r]);
          return e;
        },
        E = (e, t) => f(e, g(t));
      function _(e) {
        return E(v({}, e), { level: e?.level || a.level });
      }
      function C(e, t = o) {
        return typeof e.bindings > "u"
          ? (function (e, t = o) {
              return e[t] || "";
            })(e, t)
          : e.bindings().context || "";
      }
      function A(e, t, r = o) {
        let i = (function (e, t, r = o) {
          let i = C(e, r);
          return i.trim() ? `${i}/${t}` : t;
        })(e, t, r);
        return (function (e, t, r = o) {
          return (e[r] = t), e;
        })(e.child({ context: i }), i, r);
      }
      function I(e) {
        return "u" > typeof e.loggerOverride &&
          "string" != typeof e.loggerOverride
          ? { logger: e.loggerOverride, chunkLoggerController: null }
          : "u" > typeof window
          ? (function (e) {
              var t, r;
              let i = new d(
                null == (t = e.opts) ? void 0 : t.level,
                e.maxSizeInBytes
              );
              return {
                logger: s()(
                  E(v({}, e.opts), {
                    level: "trace",
                    browser: E(
                      v({}, null == (r = e.opts) ? void 0 : r.browser),
                      { write: (e) => i.write(e) }
                    ),
                  })
                ),
                chunkLoggerController: i,
              };
            })(e)
          : (function (e) {
              var t;
              let r = new h(
                null == (t = e.opts) ? void 0 : t.level,
                e.maxSizeInBytes
              );
              return {
                logger: s()(E(v({}, e.opts), { level: "trace" }), r),
                chunkLoggerController: r,
              };
            })(e);
      }
    },
    20294: (e) => {
      "use strict";
      e.exports = function () {
        throw Error(
          "ws does not work in the browser. Browser clients must use the native WebSocket object"
        );
      };
    },
    21239: (e, t, r) => {
      "use strict";
      r.d(t, { t: () => n });
      var i = r(25910),
        s = r(52020),
        n = new (class extends i.Q {
          #e = !0;
          #t;
          #r;
          constructor() {
            super(),
              (this.#r = (e) => {
                if (!s.S$ && window.addEventListener) {
                  let t = () => e(!0),
                    r = () => e(!1);
                  return (
                    window.addEventListener("online", t, !1),
                    window.addEventListener("offline", r, !1),
                    () => {
                      window.removeEventListener("online", t),
                        window.removeEventListener("offline", r);
                    }
                  );
                }
              });
          }
          onSubscribe() {
            this.#t || this.setEventListener(this.#r);
          }
          onUnsubscribe() {
            this.hasListeners() || (this.#t?.(), (this.#t = void 0));
          }
          setEventListener(e) {
            (this.#r = e),
              this.#t?.(),
              (this.#t = e(this.setOnline.bind(this)));
          }
          setOnline(e) {
            this.#e !== e &&
              ((this.#e = e),
              this.listeners.forEach((t) => {
                t(e);
              }));
          }
          isOnline() {
            return this.#e;
          }
        })();
    },
    22492: (e, t, r) => {
      "use strict";
      function i(e, t) {
        return "light" === t
          ? {
              "--w3m-accent": e?.["--w3m-accent"] || "hsla(231, 100%, 70%, 1)",
              "--w3m-background": "#fff",
            }
          : {
              "--w3m-accent": e?.["--w3m-accent"] || "hsla(230, 100%, 67%, 1)",
              "--w3m-background": "#121313",
            };
      }
      r.d(t, { o: () => i });
    },
    23140: (e, t, r) => {
      "use strict";
      r.d(t, { y: () => s });
      var i = r(99836);
      let s = {
        getCaipTokens(e) {
          if (!e) return;
          let t = {};
          return (
            Object.entries(e).forEach(([e, r]) => {
              t[`${i.o.EIP155}:${e}`] = r;
            }),
            t
          );
        },
        isLowerCaseMatch: (e, t) => e?.toLowerCase() === t?.toLowerCase(),
      };
    },
    24259: (e, t, r) => {
      "use strict";
      r.d(t, { r: () => l });
      var i = r(30832),
        s = r(32107),
        n = r(99758),
        a = r(6420);
      i.extend(n), i.extend(a);
      let o = {
          ...s,
          name: "en-web3-modal",
          relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "%d sec",
            m: "1 min",
            mm: "%d min",
            h: "1 hr",
            hh: "%d hrs",
            d: "1 d",
            dd: "%d d",
            M: "1 mo",
            MM: "%d mo",
            y: "1 yr",
            yy: "%d yr",
          },
        },
        c = [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December",
        ];
      i.locale("en-web3-modal", o);
      let l = {
        getMonthNameByIndex: (e) => c[e],
        getYear: (e = new Date().toISOString()) => i(e).year(),
        getRelativeDateFromNow: (e) => i(e).locale("en-web3-modal").fromNow(!0),
        formatDate: (e, t = "DD MMM") => i(e).format(t),
      };
    },
    25910: (e, t, r) => {
      "use strict";
      r.d(t, { Q: () => i });
      var i = class {
        constructor() {
          (this.listeners = new Set()),
            (this.subscribe = this.subscribe.bind(this));
        }
        subscribe(e) {
          return (
            this.listeners.add(e),
            this.onSubscribe(),
            () => {
              this.listeners.delete(e), this.onUnsubscribe();
            }
          );
        }
        hasListeners() {
          return this.listeners.size > 0;
        }
        onSubscribe() {}
        onUnsubscribe() {}
      };
    },
    26128: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => s });
      var i = r(49509);
      let s = {
        ACCOUNT_TABS: [
          { label: "Tokens" },
          { label: "NFTs" },
          { label: "Activity" },
        ],
        SECURE_SITE_ORIGIN:
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_SECURE_SITE_ORIGIN
            : void 0) || "https://secure.walletconnect.org",
        VIEW_DIRECTION: { Next: "next", Prev: "prev" },
        DEFAULT_CONNECT_METHOD_ORDER: ["email", "social", "wallet"],
        ANIMATION_DURATIONS: {
          HeaderText: 120,
          ModalHeight: 150,
          ViewTransition: 150,
        },
      };
    },
    26343: (e, t, r) => {
      "use strict";
      r.d(t, { L: () => s });
      var i = r(60500);
      let s = {
        caipNetworkIdToNumber: (e) => (e ? Number(e.split(":")[1]) : void 0),
        parseEvmChainId(e) {
          return "string" == typeof e ? this.caipNetworkIdToNumber(e) : e;
        },
        getNetworksByNamespace: (e, t) =>
          e?.filter((e) => e.chainNamespace === t) || [],
        getFirstNetworkByNamespace(e, t) {
          return this.getNetworksByNamespace(e, t)[0];
        },
        getNetworkNameByCaipNetworkId(e, t) {
          if (!t) return;
          let r = e.find((e) => e.caipNetworkId === t);
          if (r) return r.name;
          let [s] = t.split(":");
          return i.o.CHAIN_NAME_MAP?.[s] || void 0;
        },
      };
    },
    26607: (e, t, r) => {
      "use strict";
      r.d(t, {
        Vw: () => p,
        Fc: () => l,
        Id: () => h,
        O8: () => a,
        qv: () => c,
        po: () => g,
        Ow: () => o,
        ZJ: () => d,
        DH: () => n,
        ld: () => f,
      });
      let i =
        "object" == typeof globalThis && "crypto" in globalThis
          ? globalThis.crypto
          : void 0;
      var s = r(2255);
      function n(e) {
        return new Uint32Array(
          e.buffer,
          e.byteOffset,
          Math.floor(e.byteLength / 4)
        );
      }
      function a(e) {
        return new DataView(e.buffer, e.byteOffset, e.byteLength);
      }
      function o(e, t) {
        return (e << (32 - t)) | (e >>> t);
      }
      let c = 68 === new Uint8Array(new Uint32Array([0x11223344]).buffer)[0];
      function l(e) {
        for (let r = 0; r < e.length; r++) {
          var t;
          e[r] =
            (((t = e[r]) << 24) & 0xff000000) |
            ((t << 8) & 0xff0000) |
            ((t >>> 8) & 65280) |
            ((t >>> 24) & 255);
        }
      }
      "function" == typeof Uint8Array.from([]).toHex && Uint8Array.fromHex,
        (e, t) => t.toString(16).padStart(2, "0");
      let u = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      function d(e) {
        return (
          "string" == typeof e &&
            (e = (function (e) {
              if ("string" != typeof e)
                throw Error("utf8ToBytes expected string, got " + typeof e);
              return new Uint8Array(new TextEncoder().encode(e));
            })(e)),
          (0, s.DO)(e),
          e
        );
      }
      function h(...e) {
        let t = 0;
        for (let r = 0; r < e.length; r++) {
          let i = e[r];
          (0, s.DO)(i), (t += i.length);
        }
        let r = new Uint8Array(t);
        for (let t = 0, i = 0; t < e.length; t++) {
          let s = e[t];
          r.set(s, i), (i += s.length);
        }
        return r;
      }
      class p {
        clone() {
          return this._cloneInto();
        }
      }
      function f(e) {
        let t = (t) => e().update(d(t)).digest(),
          r = e();
        return (
          (t.outputLen = r.outputLen),
          (t.blockLen = r.blockLen),
          (t.create = () => e()),
          t
        );
      }
      function g(e = 32) {
        if (i && "function" == typeof i.getRandomValues)
          return i.getRandomValues(new Uint8Array(e));
        if (i && "function" == typeof i.randomBytes)
          return Uint8Array.from(i.randomBytes(e));
        throw Error("crypto.getRandomValues must be defined");
      }
    },
    26715: (e, t, r) => {
      "use strict";
      r.d(t, { Ht: () => o, jE: () => a });
      var i = r(12115),
        s = r(95155),
        n = i.createContext(void 0),
        a = (e) => {
          let t = i.useContext(n);
          if (e) return e;
          if (!t)
            throw Error(
              "No QueryClient set, use QueryClientProvider to set one"
            );
          return t;
        },
        o = (e) => {
          let { client: t, children: r } = e;
          return (
            i.useEffect(
              () => (
                t.mount(),
                () => {
                  t.unmount();
                }
              ),
              [t]
            ),
            (0, s.jsx)(n.Provider, { value: t, children: r })
          );
        };
    },
    27104: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.delay = void 0),
        (t.delay = function (e) {
          return new Promise((t) => {
            setTimeout(() => {
              t(!0);
            }, e);
          });
        });
    },
    27493: (e, t, r) => {
      "use strict";
      r.d(t, { IQ: () => u, ME: () => l, Sl: () => o, uU: () => c });
      var i = r(94201),
        s = r(87094),
        n = r(54335),
        a = r(80844);
      function o(e, { size: t }) {
        if ((0, s.E)(e) > t)
          throw new i.u({ givenSize: (0, s.E)(e), maxSize: t });
      }
      function c(e, t = {}) {
        let { signed: r } = t;
        t.size && o(e, { size: t.size });
        let i = BigInt(e);
        if (!r) return i;
        let s = (e.length - 2) / 2;
        return i <= (1n << (8n * BigInt(s) - 1n)) - 1n
          ? i
          : i - BigInt(`0x${"f".padStart(2 * s, "f")}`) - 1n;
      }
      function l(e, t = {}) {
        return Number(c(e, t));
      }
      function u(e, t = {}) {
        let r = (0, a.aT)(e);
        return (
          t.size &&
            (o(r, { size: t.size }), (r = (0, n.B)(r, { dir: "right" }))),
          new TextDecoder().decode(r)
        );
      }
    },
    27882: (e, t, r) => {
      "use strict";
      r.d(t, { E1: () => i.E, kl: () => o });
      var i = r(28362),
        s = r(76631),
        n = r(41757);
      let a = {
          solana: [
            "solana_signMessage",
            "solana_signTransaction",
            "solana_requestAccounts",
            "solana_getAccounts",
            "solana_signAllTransactions",
            "solana_signAndSendTransaction",
          ],
          eip155: [
            "eth_accounts",
            "eth_requestAccounts",
            "eth_sendRawTransaction",
            "eth_sign",
            "eth_signTransaction",
            "eth_signTypedData",
            "eth_signTypedData_v3",
            "eth_signTypedData_v4",
            "eth_sendTransaction",
            "personal_sign",
            "wallet_switchEthereumChain",
            "wallet_addEthereumChain",
            "wallet_getPermissions",
            "wallet_requestPermissions",
            "wallet_registerOnboarding",
            "wallet_watchAsset",
            "wallet_scanQRCode",
            "wallet_getCallsStatus",
            "wallet_showCallsStatus",
            "wallet_sendCalls",
            "wallet_getCapabilities",
            "wallet_grantPermissions",
            "wallet_revokePermissions",
            "wallet_getAssets",
          ],
          bip122: [
            "sendTransfer",
            "signMessage",
            "signPsbt",
            "getAccountAddresses",
          ],
        },
        o = {
          getMethodsByChainNamespace: (e) => a[e] || [],
          createDefaultNamespace(e) {
            return {
              methods: this.getMethodsByChainNamespace(e),
              events: ["accountsChanged", "chainChanged"],
              chains: [],
              rpcMap: {},
            };
          },
          applyNamespaceOverrides(e, t) {
            if (!t) return { ...e };
            let r = { ...e },
              i = new Set();
            if (
              (t.methods && Object.keys(t.methods).forEach((e) => i.add(e)),
              t.chains && Object.keys(t.chains).forEach((e) => i.add(e)),
              t.events && Object.keys(t.events).forEach((e) => i.add(e)),
              t.rpcMap &&
                Object.keys(t.rpcMap).forEach((e) => {
                  let [t] = e.split(":");
                  t && i.add(t);
                }),
              i.forEach((e) => {
                r[e] || (r[e] = this.createDefaultNamespace(e));
              }),
              t.methods &&
                Object.entries(t.methods).forEach(([e, t]) => {
                  r[e] && (r[e].methods = t);
                }),
              t.chains &&
                Object.entries(t.chains).forEach(([e, t]) => {
                  r[e] && (r[e].chains = t);
                }),
              t.events &&
                Object.entries(t.events).forEach(([e, t]) => {
                  r[e] && (r[e].events = t);
                }),
              t.rpcMap)
            ) {
              let e = new Set();
              Object.entries(t.rpcMap).forEach(([t, i]) => {
                let [s, n] = t.split(":");
                s &&
                  n &&
                  r[s] &&
                  (r[s].rpcMap || (r[s].rpcMap = {}),
                  e.has(s) || ((r[s].rpcMap = {}), e.add(s)),
                  (r[s].rpcMap[n] = i));
              });
            }
            return r;
          },
          createNamespaces(e, t) {
            let r = e.reduce((e, t) => {
              let { id: r, chainNamespace: i, rpcUrls: s } = t,
                a = s.default.http[0];
              e[i] || (e[i] = this.createDefaultNamespace(i));
              let o = `${i}:${r}`,
                c = e[i];
              switch ((c.chains.push(o), o)) {
                case n.tWt.caipNetworkId:
                  c.chains.push(n.tWt.deprecatedCaipNetworkId);
                  break;
                case n.Rn0.caipNetworkId:
                  c.chains.push(n.Rn0.deprecatedCaipNetworkId);
              }
              return c?.rpcMap && a && (c.rpcMap[r] = a), e;
            }, {});
            return this.applyNamespaceOverrides(r, t);
          },
          resolveReownName: async (e) => {
            let t = await s.f.resolveName(e),
              r = Object.values(t?.addresses) || [];
            return r[0]?.address || !1;
          },
          getChainsFromNamespaces: (e = {}) =>
            Object.values(e).flatMap((e) =>
              Array.from(
                new Set([
                  ...(e.chains || []),
                  ...e.accounts.map((e) => {
                    let [t, r] = e.split(":");
                    return `${t}:${r}`;
                  }),
                ])
              )
            ),
          isSessionEventData: (e) =>
            "object" == typeof e &&
            null !== e &&
            "id" in e &&
            "topic" in e &&
            "params" in e &&
            "object" == typeof e.params &&
            null !== e.params &&
            "chainId" in e.params &&
            "event" in e.params &&
            "object" == typeof e.params.event &&
            null !== e.params.event,
          isOriginAllowed(e, t, r) {
            for (let i of [...t, ...r])
              if (i.includes("*")) {
                let t = i.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
                if (RegExp(`^${t.replace(/\\\*/gu, ".*")}$`, "u").test(e))
                  return !0;
              } else
                try {
                  if (new URL(i).origin === e) return !0;
                } catch (t) {
                  if (i === e) return !0;
                }
            return !1;
          },
        };
    },
    28094: (e, t, r) => {
      "use strict";
      t.g = void 0;
      let i = r(621);
      t.g = function () {
        let e, t, r;
        try {
          (e = i.getDocumentOrThrow()), (t = i.getLocationOrThrow());
        } catch (e) {
          return null;
        }
        function s(...t) {
          let r = e.getElementsByTagName("meta");
          for (let e = 0; e < r.length; e++) {
            let i = r[e],
              s = ["itemprop", "property", "name"]
                .map((e) => i.getAttribute(e))
                .filter((e) => !!e && t.includes(e));
            if (s.length && s) {
              let e = i.getAttribute("content");
              if (e) return e;
            }
          }
          return "";
        }
        let n =
            ((r = s("name", "og:site_name", "og:title", "twitter:title")) ||
              (r = e.title),
            r),
          a = s(
            "description",
            "og:description",
            "twitter:description",
            "keywords"
          ),
          o = t.origin;
        return {
          description: a,
          url: o,
          icons: (function () {
            let r = e.getElementsByTagName("link"),
              i = [];
            for (let e = 0; e < r.length; e++) {
              let s = r[e],
                n = s.getAttribute("rel");
              if (n && n.toLowerCase().indexOf("icon") > -1) {
                let e = s.getAttribute("href");
                if (e)
                  if (
                    -1 === e.toLowerCase().indexOf("https:") &&
                    -1 === e.toLowerCase().indexOf("http:") &&
                    0 !== e.indexOf("//")
                  ) {
                    let r = t.protocol + "//" + t.host;
                    if (0 === e.indexOf("/")) r += e;
                    else {
                      let i = t.pathname.split("/");
                      i.pop(), (r += i.join("/") + "/" + e);
                    }
                    i.push(r);
                  } else if (0 === e.indexOf("//")) {
                    let r = t.protocol + e;
                    i.push(r);
                  } else i.push(e);
              }
            }
            return i;
          })(),
          name: n,
        };
      };
    },
    28307: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => i });
      let i = {
        EmbeddedWalletAbortController: new AbortController(),
        UniversalProviderErrors: {
          UNAUTHORIZED_DOMAIN_NOT_ALLOWED: {
            message: "Unauthorized: origin not allowed",
            alertErrorKey: "INVALID_APP_CONFIGURATION",
          },
          JWT_VALIDATION_ERROR: {
            message: "JWT validation error: JWT Token is not yet valid",
            alertErrorKey: "JWT_TOKEN_NOT_VALID",
          },
          INVALID_KEY: {
            message: "Unauthorized: invalid key",
            alertErrorKey: "INVALID_PROJECT_ID",
          },
        },
        ALERT_ERRORS: {
          SWITCH_NETWORK_NOT_FOUND: {
            shortMessage: "Network Not Found",
            longMessage:
              "Network not found - please make sure it is included in 'networks' array in createAppKit function",
          },
          INVALID_APP_CONFIGURATION: {
            shortMessage: "Invalid App Configuration",
            longMessage: () =>
              `Origin ${
                "undefined" != typeof window ? window.origin : "unknown"
              } not found on Allowlist - update configuration on cloud.reown.com`,
          },
          IFRAME_LOAD_FAILED: {
            shortMessage: "Network Error - Could not load embedded wallet",
            longMessage: () =>
              "There was an issue loading the embedded wallet. Please try again later.",
          },
          IFRAME_REQUEST_TIMEOUT: {
            shortMessage: "Embedded Wallet Request Timed Out",
            longMessage: () =>
              "There was an issue doing the request to the embedded wallet. Please try again later.",
          },
          UNVERIFIED_DOMAIN: {
            shortMessage: "Invalid App Configuration",
            longMessage: () =>
              "There was an issue loading the embedded wallet. Please verify that your domain is allowed at cloud.reown.com",
          },
          JWT_TOKEN_NOT_VALID: {
            shortMessage: "Session Expired",
            longMessage:
              "Invalid session found on UniversalProvider - please check your time settings and connect again",
          },
          INVALID_PROJECT_ID: {
            shortMessage: "Invalid App Configuration",
            longMessage: "Invalid Project ID - update configuration",
          },
          PROJECT_ID_NOT_CONFIGURED: {
            shortMessage: "Project ID Not Configured",
            longMessage:
              "Project ID Not Configured - update configuration on cloud.reown.com",
          },
        },
      };
    },
    28312: (e, t, r) => {
      "use strict";
      r.d(t, {
        WF: () => a,
        AH: () => i.AH,
        qy: () => s.qy,
        JW: () => s.JW,
        iz: () => i.iz,
      });
      var i = r(30572),
        s = r(77508);
      let n = globalThis;
      class a extends i.mN {
        constructor() {
          super(...arguments),
            (this.renderOptions = { host: this }),
            (this._$Do = void 0);
        }
        createRenderRoot() {
          let e = super.createRenderRoot();
          return (this.renderOptions.renderBefore ??= e.firstChild), e;
        }
        update(e) {
          let t = this.render();
          this.hasUpdated ||
            (this.renderOptions.isConnected = this.isConnected),
            super.update(e),
            (this._$Do = (0, s.XX)(t, this.renderRoot, this.renderOptions));
        }
        connectedCallback() {
          super.connectedCallback(), this._$Do?.setConnected(!0);
        }
        disconnectedCallback() {
          super.disconnectedCallback(), this._$Do?.setConnected(!1);
        }
        render() {
          return s.c0;
        }
      }
      (a._$litElement$ = !0),
        (a.finalized = !0),
        n.litElementHydrateSupport?.({ LitElement: a });
      let o = n.litElementPolyfillSupport;
      o?.({ LitElement: a }), (n.litElementVersions ??= []).push("4.2.0");
    },
    28362: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => i });
      let i = {
        ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
        ERROR_CODE_DEFAULT: 5e3,
        ERROR_INVALID_CHAIN_ID: 32603,
        DEFAULT_ALLOWED_ANCESTORS: [
          "http://localhost:*",
          "https://*.pages.dev",
          "https://*.vercel.app",
          "https://*.ngrok-free.app",
          "https://secure-mobile.walletconnect.com",
          "https://secure-mobile.walletconnect.org",
        ],
      };
    },
    29386: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => o });
      var i = r(43708),
        s = r(70799);
      let n = {
          eip155: void 0,
          solana: void 0,
          polkadot: void 0,
          bip122: void 0,
          cosmos: void 0,
        },
        a = (0, i.BX)({ providers: { ...n }, providerIds: { ...n } }),
        o = {
          state: a,
          subscribeKey: (e, t) => (0, s.u$)(a, e, t),
          subscribe: (e) =>
            (0, i.B1)(a, () => {
              e(a);
            }),
          subscribeProviders: (e) =>
            (0, i.B1)(a.providers, () => e(a.providers)),
          setProvider(e, t) {
            t && (a.providers[e] = (0, i.KR)(t));
          },
          getProvider: (e) => a.providers[e],
          setProviderId(e, t) {
            t && (a.providerIds[e] = t);
          },
          getProviderId(e) {
            if (e) return a.providerIds[e];
          },
          reset() {
            (a.providers = { ...n }), (a.providerIds = { ...n });
          },
          resetChain(e) {
            (a.providers[e] = void 0), (a.providerIds[e] = void 0);
          },
        };
    },
    30572: (e, t, r) => {
      "use strict";
      r.d(t, {
        mN: () => S,
        AH: () => l,
        W3: () => C,
        Ec: () => A,
        iz: () => c,
      });
      let i = globalThis,
        s =
          i.ShadowRoot &&
          (void 0 === i.ShadyCSS || i.ShadyCSS.nativeShadow) &&
          "adoptedStyleSheets" in Document.prototype &&
          "replace" in CSSStyleSheet.prototype,
        n = Symbol(),
        a = new WeakMap();
      class o {
        constructor(e, t, r) {
          if (((this._$cssResult$ = !0), r !== n))
            throw Error(
              "CSSResult is not constructable. Use `unsafeCSS` or `css` instead."
            );
          (this.cssText = e), (this.t = t);
        }
        get styleSheet() {
          let e = this.o,
            t = this.t;
          if (s && void 0 === e) {
            let r = void 0 !== t && 1 === t.length;
            r && (e = a.get(t)),
              void 0 === e &&
                ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText),
                r && a.set(t, e));
          }
          return e;
        }
        toString() {
          return this.cssText;
        }
      }
      let c = (e) => new o("string" == typeof e ? e : e + "", void 0, n),
        l = (e, ...t) =>
          new o(
            1 === e.length
              ? e[0]
              : t.reduce(
                  (t, r, i) =>
                    t +
                    ((e) => {
                      if (!0 === e._$cssResult$) return e.cssText;
                      if ("number" == typeof e) return e;
                      throw Error(
                        "Value passed to 'css' function must be a 'css' function result: " +
                          e +
                          ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security."
                      );
                    })(r) +
                    e[i + 1],
                  e[0]
                ),
            e,
            n
          ),
        u = (e, t) => {
          if (s)
            e.adoptedStyleSheets = t.map((e) =>
              e instanceof CSSStyleSheet ? e : e.styleSheet
            );
          else
            for (let r of t) {
              let t = document.createElement("style"),
                s = i.litNonce;
              void 0 !== s && t.setAttribute("nonce", s),
                (t.textContent = r.cssText),
                e.appendChild(t);
            }
        },
        d = s
          ? (e) => e
          : (e) =>
              e instanceof CSSStyleSheet
                ? ((e) => {
                    let t = "";
                    for (let r of e.cssRules) t += r.cssText;
                    return c(t);
                  })(e)
                : e,
        {
          is: h,
          defineProperty: p,
          getOwnPropertyDescriptor: f,
          getOwnPropertyNames: g,
          getOwnPropertySymbols: m,
          getPrototypeOf: y,
        } = Object,
        b = globalThis,
        w = b.trustedTypes,
        v = w ? w.emptyScript : "",
        E = b.reactiveElementPolyfillSupport,
        _ = (e, t) => e,
        C = {
          toAttribute(e, t) {
            switch (t) {
              case Boolean:
                e = e ? v : null;
                break;
              case Object:
              case Array:
                e = null == e ? e : JSON.stringify(e);
            }
            return e;
          },
          fromAttribute(e, t) {
            let r = e;
            switch (t) {
              case Boolean:
                r = null !== e;
                break;
              case Number:
                r = null === e ? null : Number(e);
                break;
              case Object:
              case Array:
                try {
                  r = JSON.parse(e);
                } catch (e) {
                  r = null;
                }
            }
            return r;
          },
        },
        A = (e, t) => !h(e, t),
        I = {
          attribute: !0,
          type: String,
          converter: C,
          reflect: !1,
          useDefault: !1,
          hasChanged: A,
        };
      (Symbol.metadata ??= Symbol("metadata")),
        (b.litPropertyMetadata ??= new WeakMap());
      class S extends HTMLElement {
        static addInitializer(e) {
          this._$Ei(), (this.l ??= []).push(e);
        }
        static get observedAttributes() {
          return this.finalize(), this._$Eh && [...this._$Eh.keys()];
        }
        static createProperty(e, t = I) {
          if (
            (t.state && (t.attribute = !1),
            this._$Ei(),
            this.prototype.hasOwnProperty(e) &&
              ((t = Object.create(t)).wrapped = !0),
            this.elementProperties.set(e, t),
            !t.noAccessor)
          ) {
            let r = Symbol(),
              i = this.getPropertyDescriptor(e, r, t);
            void 0 !== i && p(this.prototype, e, i);
          }
        }
        static getPropertyDescriptor(e, t, r) {
          let { get: i, set: s } = f(this.prototype, e) ?? {
            get() {
              return this[t];
            },
            set(e) {
              this[t] = e;
            },
          };
          return {
            get: i,
            set(t) {
              let n = i?.call(this);
              s?.call(this, t), this.requestUpdate(e, n, r);
            },
            configurable: !0,
            enumerable: !0,
          };
        }
        static getPropertyOptions(e) {
          return this.elementProperties.get(e) ?? I;
        }
        static _$Ei() {
          if (this.hasOwnProperty(_("elementProperties"))) return;
          let e = y(this);
          e.finalize(),
            void 0 !== e.l && (this.l = [...e.l]),
            (this.elementProperties = new Map(e.elementProperties));
        }
        static finalize() {
          if (this.hasOwnProperty(_("finalized"))) return;
          if (
            ((this.finalized = !0),
            this._$Ei(),
            this.hasOwnProperty(_("properties")))
          ) {
            let e = this.properties;
            for (let t of [...g(e), ...m(e)]) this.createProperty(t, e[t]);
          }
          let e = this[Symbol.metadata];
          if (null !== e) {
            let t = litPropertyMetadata.get(e);
            if (void 0 !== t)
              for (let [e, r] of t) this.elementProperties.set(e, r);
          }
          for (let [e, t] of ((this._$Eh = new Map()),
          this.elementProperties)) {
            let r = this._$Eu(e, t);
            void 0 !== r && this._$Eh.set(r, e);
          }
          this.elementStyles = this.finalizeStyles(this.styles);
        }
        static finalizeStyles(e) {
          let t = [];
          if (Array.isArray(e))
            for (let r of new Set(e.flat(1 / 0).reverse())) t.unshift(d(r));
          else void 0 !== e && t.push(d(e));
          return t;
        }
        static _$Eu(e, t) {
          let r = t.attribute;
          return !1 === r
            ? void 0
            : "string" == typeof r
            ? r
            : "string" == typeof e
            ? e.toLowerCase()
            : void 0;
        }
        constructor() {
          super(),
            (this._$Ep = void 0),
            (this.isUpdatePending = !1),
            (this.hasUpdated = !1),
            (this._$Em = null),
            this._$Ev();
        }
        _$Ev() {
          (this._$ES = new Promise((e) => (this.enableUpdating = e))),
            (this._$AL = new Map()),
            this._$E_(),
            this.requestUpdate(),
            this.constructor.l?.forEach((e) => e(this));
        }
        addController(e) {
          (this._$EO ??= new Set()).add(e),
            void 0 !== this.renderRoot &&
              this.isConnected &&
              e.hostConnected?.();
        }
        removeController(e) {
          this._$EO?.delete(e);
        }
        _$E_() {
          let e = new Map();
          for (let t of this.constructor.elementProperties.keys())
            this.hasOwnProperty(t) && (e.set(t, this[t]), delete this[t]);
          e.size > 0 && (this._$Ep = e);
        }
        createRenderRoot() {
          let e =
            this.shadowRoot ??
            this.attachShadow(this.constructor.shadowRootOptions);
          return u(e, this.constructor.elementStyles), e;
        }
        connectedCallback() {
          (this.renderRoot ??= this.createRenderRoot()),
            this.enableUpdating(!0),
            this._$EO?.forEach((e) => e.hostConnected?.());
        }
        enableUpdating(e) {}
        disconnectedCallback() {
          this._$EO?.forEach((e) => e.hostDisconnected?.());
        }
        attributeChangedCallback(e, t, r) {
          this._$AK(e, r);
        }
        _$ET(e, t) {
          let r = this.constructor.elementProperties.get(e),
            i = this.constructor._$Eu(e, r);
          if (void 0 !== i && !0 === r.reflect) {
            let s = (
              void 0 !== r.converter?.toAttribute ? r.converter : C
            ).toAttribute(t, r.type);
            (this._$Em = e),
              null == s ? this.removeAttribute(i) : this.setAttribute(i, s),
              (this._$Em = null);
          }
        }
        _$AK(e, t) {
          let r = this.constructor,
            i = r._$Eh.get(e);
          if (void 0 !== i && this._$Em !== i) {
            let e = r.getPropertyOptions(i),
              s =
                "function" == typeof e.converter
                  ? { fromAttribute: e.converter }
                  : void 0 !== e.converter?.fromAttribute
                  ? e.converter
                  : C;
            (this._$Em = i),
              (this[i] =
                s.fromAttribute(t, e.type) ?? this._$Ej?.get(i) ?? null),
              (this._$Em = null);
          }
        }
        requestUpdate(e, t, r) {
          if (void 0 !== e) {
            let i = this.constructor,
              s = this[e];
            if (
              !(
                ((r ??= i.getPropertyOptions(e)).hasChanged ?? A)(s, t) ||
                (r.useDefault &&
                  r.reflect &&
                  s === this._$Ej?.get(e) &&
                  !this.hasAttribute(i._$Eu(e, r)))
              )
            )
              return;
            this.C(e, t, r);
          }
          !1 === this.isUpdatePending && (this._$ES = this._$EP());
        }
        C(e, t, { useDefault: r, reflect: i, wrapped: s }, n) {
          (r &&
            !(this._$Ej ??= new Map()).has(e) &&
            (this._$Ej.set(e, n ?? t ?? this[e]), !0 !== s || void 0 !== n)) ||
            (this._$AL.has(e) ||
              (this.hasUpdated || r || (t = void 0), this._$AL.set(e, t)),
            !0 === i && this._$Em !== e && (this._$Eq ??= new Set()).add(e));
        }
        async _$EP() {
          this.isUpdatePending = !0;
          try {
            await this._$ES;
          } catch (e) {
            Promise.reject(e);
          }
          let e = this.scheduleUpdate();
          return null != e && (await e), !this.isUpdatePending;
        }
        scheduleUpdate() {
          return this.performUpdate();
        }
        performUpdate() {
          if (!this.isUpdatePending) return;
          if (!this.hasUpdated) {
            if (((this.renderRoot ??= this.createRenderRoot()), this._$Ep)) {
              for (let [e, t] of this._$Ep) this[e] = t;
              this._$Ep = void 0;
            }
            let e = this.constructor.elementProperties;
            if (e.size > 0)
              for (let [t, r] of e) {
                let { wrapped: e } = r,
                  i = this[t];
                !0 !== e ||
                  this._$AL.has(t) ||
                  void 0 === i ||
                  this.C(t, void 0, r, i);
              }
          }
          let e = !1,
            t = this._$AL;
          try {
            (e = this.shouldUpdate(t))
              ? (this.willUpdate(t),
                this._$EO?.forEach((e) => e.hostUpdate?.()),
                this.update(t))
              : this._$EM();
          } catch (t) {
            throw ((e = !1), this._$EM(), t);
          }
          e && this._$AE(t);
        }
        willUpdate(e) {}
        _$AE(e) {
          this._$EO?.forEach((e) => e.hostUpdated?.()),
            this.hasUpdated || ((this.hasUpdated = !0), this.firstUpdated(e)),
            this.updated(e);
        }
        _$EM() {
          (this._$AL = new Map()), (this.isUpdatePending = !1);
        }
        get updateComplete() {
          return this.getUpdateComplete();
        }
        getUpdateComplete() {
          return this._$ES;
        }
        shouldUpdate(e) {
          return !0;
        }
        update(e) {
          (this._$Eq &&= this._$Eq.forEach((e) => this._$ET(e, this[e]))),
            this._$EM();
        }
        updated(e) {}
        firstUpdated(e) {}
      }
      (S.elementStyles = []),
        (S.shadowRootOptions = { mode: "open" }),
        (S[_("elementProperties")] = new Map()),
        (S[_("finalized")] = new Map()),
        E?.({ ReactiveElement: S }),
        (b.reactiveElementVersions ??= []).push("2.1.0");
    },
    30596: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => n });
      var i = r(45312),
        s = r(519);
      let n = {
        set(e, t) {
          s.Q.isClient && localStorage.setItem(`${i.s1.STORAGE_KEY}${e}`, t);
        },
        get: (e) =>
          s.Q.isClient ? localStorage.getItem(`${i.s1.STORAGE_KEY}${e}`) : null,
        delete(e, t) {
          s.Q.isClient &&
            (t
              ? localStorage.removeItem(e)
              : localStorage.removeItem(`${i.s1.STORAGE_KEY}${e}`));
        },
      };
    },
    30832: function (e) {
      e.exports = (function () {
        "use strict";
        var e = "millisecond",
          t = "second",
          r = "minute",
          i = "hour",
          s = "week",
          n = "month",
          a = "quarter",
          o = "year",
          c = "date",
          l = "Invalid Date",
          u =
            /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
          d =
            /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
          h = function (e, t, r) {
            var i = String(e);
            return !i || i.length >= t
              ? e
              : "" + Array(t + 1 - i.length).join(r) + e;
          },
          p = "en",
          f = {};
        f[p] = {
          name: "en",
          weekdays:
            "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
              "_"
            ),
          months:
            "January_February_March_April_May_June_July_August_September_October_November_December".split(
              "_"
            ),
          ordinal: function (e) {
            var t = ["th", "st", "nd", "rd"],
              r = e % 100;
            return "[" + e + (t[(r - 20) % 10] || t[r] || t[0]) + "]";
          },
        };
        var g = "$isDayjsObject",
          m = function (e) {
            return e instanceof v || !(!e || !e[g]);
          },
          y = function e(t, r, i) {
            var s;
            if (!t) return p;
            if ("string" == typeof t) {
              var n = t.toLowerCase();
              f[n] && (s = n), r && ((f[n] = r), (s = n));
              var a = t.split("-");
              if (!s && a.length > 1) return e(a[0]);
            } else {
              var o = t.name;
              (f[o] = t), (s = o);
            }
            return !i && s && (p = s), s || (!i && p);
          },
          b = function (e, t) {
            if (m(e)) return e.clone();
            var r = "object" == typeof t ? t : {};
            return (r.date = e), (r.args = arguments), new v(r);
          },
          w = {
            s: h,
            z: function (e) {
              var t = -e.utcOffset(),
                r = Math.abs(t);
              return (
                (t <= 0 ? "+" : "-") +
                h(Math.floor(r / 60), 2, "0") +
                ":" +
                h(r % 60, 2, "0")
              );
            },
            m: function e(t, r) {
              if (t.date() < r.date()) return -e(r, t);
              var i = 12 * (r.year() - t.year()) + (r.month() - t.month()),
                s = t.clone().add(i, n),
                a = r - s < 0,
                o = t.clone().add(i + (a ? -1 : 1), n);
              return +(-(i + (r - s) / (a ? s - o : o - s)) || 0);
            },
            a: function (e) {
              return e < 0 ? Math.ceil(e) || 0 : Math.floor(e);
            },
            p: function (l) {
              return (
                {
                  M: n,
                  y: o,
                  w: s,
                  d: "day",
                  D: c,
                  h: i,
                  m: r,
                  s: t,
                  ms: e,
                  Q: a,
                }[l] ||
                String(l || "")
                  .toLowerCase()
                  .replace(/s$/, "")
              );
            },
            u: function (e) {
              return void 0 === e;
            },
          };
        (w.l = y),
          (w.i = m),
          (w.w = function (e, t) {
            return b(e, {
              locale: t.$L,
              utc: t.$u,
              x: t.$x,
              $offset: t.$offset,
            });
          });
        var v = (function () {
            function h(e) {
              (this.$L = y(e.locale, null, !0)),
                this.parse(e),
                (this.$x = this.$x || e.x || {}),
                (this[g] = !0);
            }
            var p = h.prototype;
            return (
              (p.parse = function (e) {
                (this.$d = (function (e) {
                  var t = e.date,
                    r = e.utc;
                  if (null === t) return new Date(NaN);
                  if (w.u(t)) return new Date();
                  if (t instanceof Date) return new Date(t);
                  if ("string" == typeof t && !/Z$/i.test(t)) {
                    var i = t.match(u);
                    if (i) {
                      var s = i[2] - 1 || 0,
                        n = (i[7] || "0").substring(0, 3);
                      return r
                        ? new Date(
                            Date.UTC(
                              i[1],
                              s,
                              i[3] || 1,
                              i[4] || 0,
                              i[5] || 0,
                              i[6] || 0,
                              n
                            )
                          )
                        : new Date(
                            i[1],
                            s,
                            i[3] || 1,
                            i[4] || 0,
                            i[5] || 0,
                            i[6] || 0,
                            n
                          );
                    }
                  }
                  return new Date(t);
                })(e)),
                  this.init();
              }),
              (p.init = function () {
                var e = this.$d;
                (this.$y = e.getFullYear()),
                  (this.$M = e.getMonth()),
                  (this.$D = e.getDate()),
                  (this.$W = e.getDay()),
                  (this.$H = e.getHours()),
                  (this.$m = e.getMinutes()),
                  (this.$s = e.getSeconds()),
                  (this.$ms = e.getMilliseconds());
              }),
              (p.$utils = function () {
                return w;
              }),
              (p.isValid = function () {
                return this.$d.toString() !== l;
              }),
              (p.isSame = function (e, t) {
                var r = b(e);
                return this.startOf(t) <= r && r <= this.endOf(t);
              }),
              (p.isAfter = function (e, t) {
                return b(e) < this.startOf(t);
              }),
              (p.isBefore = function (e, t) {
                return this.endOf(t) < b(e);
              }),
              (p.$g = function (e, t, r) {
                return w.u(e) ? this[t] : this.set(r, e);
              }),
              (p.unix = function () {
                return Math.floor(this.valueOf() / 1e3);
              }),
              (p.valueOf = function () {
                return this.$d.getTime();
              }),
              (p.startOf = function (e, a) {
                var l = this,
                  u = !!w.u(a) || a,
                  d = w.p(e),
                  h = function (e, t) {
                    var r = w.w(
                      l.$u ? Date.UTC(l.$y, t, e) : new Date(l.$y, t, e),
                      l
                    );
                    return u ? r : r.endOf("day");
                  },
                  p = function (e, t) {
                    return w.w(
                      l
                        .toDate()
                        [e].apply(
                          l.toDate("s"),
                          (u ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(t)
                        ),
                      l
                    );
                  },
                  f = this.$W,
                  g = this.$M,
                  m = this.$D,
                  y = "set" + (this.$u ? "UTC" : "");
                switch (d) {
                  case o:
                    return u ? h(1, 0) : h(31, 11);
                  case n:
                    return u ? h(1, g) : h(0, g + 1);
                  case s:
                    var b = this.$locale().weekStart || 0,
                      v = (f < b ? f + 7 : f) - b;
                    return h(u ? m - v : m + (6 - v), g);
                  case "day":
                  case c:
                    return p(y + "Hours", 0);
                  case i:
                    return p(y + "Minutes", 1);
                  case r:
                    return p(y + "Seconds", 2);
                  case t:
                    return p(y + "Milliseconds", 3);
                  default:
                    return this.clone();
                }
              }),
              (p.endOf = function (e) {
                return this.startOf(e, !1);
              }),
              (p.$set = function (s, a) {
                var l,
                  u = w.p(s),
                  d = "set" + (this.$u ? "UTC" : ""),
                  h = (((l = {}).day = d + "Date"),
                  (l[c] = d + "Date"),
                  (l[n] = d + "Month"),
                  (l[o] = d + "FullYear"),
                  (l[i] = d + "Hours"),
                  (l[r] = d + "Minutes"),
                  (l[t] = d + "Seconds"),
                  (l[e] = d + "Milliseconds"),
                  l)[u],
                  p = "day" === u ? this.$D + (a - this.$W) : a;
                if (u === n || u === o) {
                  var f = this.clone().set(c, 1);
                  f.$d[h](p),
                    f.init(),
                    (this.$d = f.set(c, Math.min(this.$D, f.daysInMonth())).$d);
                } else h && this.$d[h](p);
                return this.init(), this;
              }),
              (p.set = function (e, t) {
                return this.clone().$set(e, t);
              }),
              (p.get = function (e) {
                return this[w.p(e)]();
              }),
              (p.add = function (e, a) {
                var c,
                  l = this;
                e = Number(e);
                var u = w.p(a),
                  d = function (t) {
                    var r = b(l);
                    return w.w(r.date(r.date() + Math.round(t * e)), l);
                  };
                if (u === n) return this.set(n, this.$M + e);
                if (u === o) return this.set(o, this.$y + e);
                if ("day" === u) return d(1);
                if (u === s) return d(7);
                var h =
                    (((c = {})[r] = 6e4), (c[i] = 36e5), (c[t] = 1e3), c)[u] ||
                    1,
                  p = this.$d.getTime() + e * h;
                return w.w(p, this);
              }),
              (p.subtract = function (e, t) {
                return this.add(-1 * e, t);
              }),
              (p.format = function (e) {
                var t = this,
                  r = this.$locale();
                if (!this.isValid()) return r.invalidDate || l;
                var i = e || "YYYY-MM-DDTHH:mm:ssZ",
                  s = w.z(this),
                  n = this.$H,
                  a = this.$m,
                  o = this.$M,
                  c = r.weekdays,
                  u = r.months,
                  h = r.meridiem,
                  p = function (e, r, s, n) {
                    return (e && (e[r] || e(t, i))) || s[r].slice(0, n);
                  },
                  f = function (e) {
                    return w.s(n % 12 || 12, e, "0");
                  },
                  g =
                    h ||
                    function (e, t, r) {
                      var i = e < 12 ? "AM" : "PM";
                      return r ? i.toLowerCase() : i;
                    };
                return i.replace(d, function (e, i) {
                  return (
                    i ||
                    (function (e) {
                      switch (e) {
                        case "YY":
                          return String(t.$y).slice(-2);
                        case "YYYY":
                          return w.s(t.$y, 4, "0");
                        case "M":
                          return o + 1;
                        case "MM":
                          return w.s(o + 1, 2, "0");
                        case "MMM":
                          return p(r.monthsShort, o, u, 3);
                        case "MMMM":
                          return p(u, o);
                        case "D":
                          return t.$D;
                        case "DD":
                          return w.s(t.$D, 2, "0");
                        case "d":
                          return String(t.$W);
                        case "dd":
                          return p(r.weekdaysMin, t.$W, c, 2);
                        case "ddd":
                          return p(r.weekdaysShort, t.$W, c, 3);
                        case "dddd":
                          return c[t.$W];
                        case "H":
                          return String(n);
                        case "HH":
                          return w.s(n, 2, "0");
                        case "h":
                          return f(1);
                        case "hh":
                          return f(2);
                        case "a":
                          return g(n, a, !0);
                        case "A":
                          return g(n, a, !1);
                        case "m":
                          return String(a);
                        case "mm":
                          return w.s(a, 2, "0");
                        case "s":
                          return String(t.$s);
                        case "ss":
                          return w.s(t.$s, 2, "0");
                        case "SSS":
                          return w.s(t.$ms, 3, "0");
                        case "Z":
                          return s;
                      }
                      return null;
                    })(e) ||
                    s.replace(":", "")
                  );
                });
              }),
              (p.utcOffset = function () {
                return -(15 * Math.round(this.$d.getTimezoneOffset() / 15));
              }),
              (p.diff = function (e, c, l) {
                var u,
                  d = this,
                  h = w.p(c),
                  p = b(e),
                  f = (p.utcOffset() - this.utcOffset()) * 6e4,
                  g = this - p,
                  m = function () {
                    return w.m(d, p);
                  };
                switch (h) {
                  case o:
                    u = m() / 12;
                    break;
                  case n:
                    u = m();
                    break;
                  case a:
                    u = m() / 3;
                    break;
                  case s:
                    u = (g - f) / 6048e5;
                    break;
                  case "day":
                    u = (g - f) / 864e5;
                    break;
                  case i:
                    u = g / 36e5;
                    break;
                  case r:
                    u = g / 6e4;
                    break;
                  case t:
                    u = g / 1e3;
                    break;
                  default:
                    u = g;
                }
                return l ? u : w.a(u);
              }),
              (p.daysInMonth = function () {
                return this.endOf(n).$D;
              }),
              (p.$locale = function () {
                return f[this.$L];
              }),
              (p.locale = function (e, t) {
                if (!e) return this.$L;
                var r = this.clone(),
                  i = y(e, t, !0);
                return i && (r.$L = i), r;
              }),
              (p.clone = function () {
                return w.w(this.$d, this);
              }),
              (p.toDate = function () {
                return new Date(this.valueOf());
              }),
              (p.toJSON = function () {
                return this.isValid() ? this.toISOString() : null;
              }),
              (p.toISOString = function () {
                return this.$d.toISOString();
              }),
              (p.toString = function () {
                return this.$d.toUTCString();
              }),
              h
            );
          })(),
          E = v.prototype;
        return (
          (b.prototype = E),
          [
            ["$ms", e],
            ["$s", t],
            ["$m", r],
            ["$H", i],
            ["$W", "day"],
            ["$M", n],
            ["$y", o],
            ["$D", c],
          ].forEach(function (e) {
            E[e[1]] = function (t) {
              return this.$g(t, e[0], e[1]);
            };
          }),
          (b.extend = function (e, t) {
            return e.$i || (e(t, v, b), (e.$i = !0)), b;
          }),
          (b.locale = y),
          (b.isDayjs = m),
          (b.unix = function (e) {
            return b(1e3 * e);
          }),
          (b.en = f[p]),
          (b.Ls = f),
          (b.p = {}),
          b
        );
      })();
    },
    31498: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }), (t.Watch = void 0);
      class r {
        constructor() {
          this.timestamps = new Map();
        }
        start(e) {
          if (this.timestamps.has(e))
            throw Error(`Watch already started for label: ${e}`);
          this.timestamps.set(e, { started: Date.now() });
        }
        stop(e) {
          let t = this.get(e);
          if (void 0 !== t.elapsed)
            throw Error(`Watch already stopped for label: ${e}`);
          let r = Date.now() - t.started;
          this.timestamps.set(e, { started: t.started, elapsed: r });
        }
        get(e) {
          let t = this.timestamps.get(e);
          if (void 0 === t) throw Error(`No timestamp found for label: ${e}`);
          return t;
        }
        elapsed(e) {
          let t = this.get(e);
          return t.elapsed || Date.now() - t.started;
        }
      }
      (t.Watch = r), (t.default = r);
    },
    31811: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => C });
      var i = r(90557),
        s = r(7441);
      class n extends s.C {
        constructor() {
          super(
            "No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.",
            { docsPath: "/docs/clients/intro", name: "UrlRequiredError" }
          );
        }
      }
      var a = r(85569),
        o = r(78519),
        c = r(79183);
      let l = {
        current: 0,
        take() {
          return this.current++;
        },
        reset() {
          this.current = 0;
        },
      };
      var u = r(54315);
      function d(e, t = {}) {
        let {
          batch: r,
          fetchOptions: s,
          key: h = "http",
          methods: p,
          name: f = "HTTP JSON-RPC",
          onFetchRequest: g,
          onFetchResponse: m,
          retryDelay: y,
          raw: b,
        } = t;
        return ({ chain: d, retryCount: w, timeout: v }) => {
          let { batchSize: E = 1e3, wait: _ = 0 } =
              "object" == typeof r ? r : {},
            C = t.retryCount ?? w,
            A = v ?? t.timeout ?? 1e4,
            I = e || d?.rpcUrls.default.http[0];
          if (!I) throw new n();
          let S = (function (e, t = {}) {
            return {
              async request(r) {
                let {
                    body: s,
                    onRequest: n = t.onRequest,
                    onResponse: a = t.onResponse,
                    timeout: u = t.timeout ?? 1e4,
                  } = r,
                  d = { ...(t.fetchOptions ?? {}), ...(r.fetchOptions ?? {}) },
                  { headers: h, method: p, signal: f } = d;
                try {
                  let t,
                    r = await (0, o.w)(
                      async ({ signal: t }) => {
                        let r = {
                            ...d,
                            body: Array.isArray(s)
                              ? (0, c.A)(
                                  s.map((e) => ({
                                    jsonrpc: "2.0",
                                    id: e.id ?? l.take(),
                                    ...e,
                                  }))
                                )
                              : (0, c.A)({
                                  jsonrpc: "2.0",
                                  id: s.id ?? l.take(),
                                  ...s,
                                }),
                            headers: {
                              "Content-Type": "application/json",
                              ...h,
                            },
                            method: p || "POST",
                            signal: f || (u > 0 ? t : null),
                          },
                          i = new Request(e, r),
                          a = (await n?.(i, r)) ?? { ...r, url: e };
                        return await fetch(a.url ?? e, a);
                      },
                      {
                        errorInstance: new i.MU({ body: s, url: e }),
                        timeout: u,
                        signal: !0,
                      }
                    );
                  if (
                    (a && (await a(r)),
                    r.headers
                      .get("Content-Type")
                      ?.startsWith("application/json"))
                  )
                    t = await r.json();
                  else {
                    t = await r.text();
                    try {
                      t = JSON.parse(t || "{}");
                    } catch (e) {
                      if (r.ok) throw e;
                      t = { error: t };
                    }
                  }
                  if (!r.ok)
                    throw new i.Ci({
                      body: s,
                      details: (0, c.A)(t.error) || r.statusText,
                      headers: r.headers,
                      status: r.status,
                      url: e,
                    });
                  return t;
                } catch (t) {
                  if (t instanceof i.Ci || t instanceof i.MU) throw t;
                  throw new i.Ci({ body: s, cause: t, url: e });
                }
              },
            };
          })(I, { fetchOptions: s, onRequest: g, onResponse: m, timeout: A });
          return (0, u.o)(
            {
              key: h,
              methods: p,
              name: f,
              async request({ method: e, params: t }) {
                let s = { method: e, params: t },
                  { schedule: n } = (0, a.u)({
                    id: I,
                    wait: _,
                    shouldSplitBatch: (e) => e.length > E,
                    fn: (e) => S.request({ body: e }),
                    sort: (e, t) => e.id - t.id,
                  }),
                  o = async (e) => (r ? n(e) : [await S.request({ body: e })]),
                  [{ error: c, result: l }] = await o(s);
                if (b) return { error: c, result: l };
                if (c) throw new i.J8({ body: s, error: c, url: I });
                return l;
              },
              retryCount: C,
              retryDelay: y,
              timeout: A,
              type: "http",
            },
            { fetchOptions: s, url: I }
          );
        };
      }
      var h = r(42264),
        p = r(81379),
        f = r(10231);
      function g(e, t = {}) {
        let {
          key: r = "fallback",
          name: i = "Fallback",
          rank: s = !1,
          shouldThrow: n = m,
          retryCount: a,
          retryDelay: o,
        } = t;
        return ({ chain: t, pollingInterval: c = 4e3, timeout: l, ...d }) => {
          let h = e,
            p = () => {},
            g = (0, u.o)(
              {
                key: r,
                name: i,
                async request({ method: e, params: r }) {
                  let i,
                    s = async (a = 0) => {
                      let o = h[a]({
                        ...d,
                        chain: t,
                        retryCount: 0,
                        timeout: l,
                      });
                      try {
                        let t = await o.request({ method: e, params: r });
                        return (
                          p({
                            method: e,
                            params: r,
                            response: t,
                            transport: o,
                            status: "success",
                          }),
                          t
                        );
                      } catch (c) {
                        if (
                          (p({
                            error: c,
                            method: e,
                            params: r,
                            transport: o,
                            status: "error",
                          }),
                          n(c) ||
                            a === h.length - 1 ||
                            !(i ??= h.slice(a + 1).some((r) => {
                              let { include: i, exclude: s } =
                                r({ chain: t }).config.methods || {};
                              return i ? i.includes(e) : !s || !s.includes(e);
                            })))
                        )
                          throw c;
                        return s(a + 1);
                      }
                    };
                  return s();
                },
                retryCount: a,
                retryDelay: o,
                type: "fallback",
              },
              {
                onResponse: (e) => (p = e),
                transports: h.map((e) => e({ chain: t, retryCount: 0 })),
              }
            );
          if (s) {
            let e = "object" == typeof s ? s : {};
            !(function ({
              chain: e,
              interval: t = 4e3,
              onTransports: r,
              ping: i,
              sampleCount: s = 10,
              timeout: n = 1e3,
              transports: a,
              weights: o = {},
            }) {
              let { stability: c = 0.7, latency: l = 0.3 } = o,
                u = [],
                d = async () => {
                  let o = await Promise.all(
                    a.map(async (t) => {
                      let r,
                        s,
                        a = t({ chain: e, retryCount: 0, timeout: n }),
                        o = Date.now();
                      try {
                        await (i
                          ? i({ transport: a })
                          : a.request({ method: "net_listening" })),
                          (s = 1);
                      } catch {
                        s = 0;
                      } finally {
                        r = Date.now();
                      }
                      return { latency: r - o, success: s };
                    })
                  );
                  u.push(o), u.length > s && u.shift();
                  let h = Math.max(
                    ...u.map((e) => Math.max(...e.map(({ latency: e }) => e)))
                  );
                  r(
                    a
                      .map((e, t) => {
                        let r = u.map((e) => e[t].latency),
                          i = r.reduce((e, t) => e + t, 0) / r.length,
                          s = u.map((e) => e[t].success),
                          n = s.reduce((e, t) => e + t, 0) / s.length;
                        return 0 === n ? [0, t] : [l * (1 - i / h) + c * n, t];
                      })
                      .sort((e, t) => t[0] - e[0])
                      .map(([, e]) => a[e])
                  ),
                    await (0, f.u)(t),
                    d();
                };
              d();
            })({
              chain: t,
              interval: e.interval ?? c,
              onTransports: (e) => (h = e),
              ping: e.ping,
              sampleCount: e.sampleCount,
              timeout: e.timeout,
              transports: h,
              weights: e.weights,
            });
          }
          return g;
        };
      }
      function m(e) {
        return !!(
          "code" in e &&
          "number" == typeof e.code &&
          (e.code === p.YW.code ||
            e.code === p.vx.code ||
            h.A7.nodeMessage.test(e.message) ||
            5e3 === e.code)
        );
      }
      var y = r(60500),
        b = r(5582),
        w = r(90906),
        v = r(93813);
      function E(e, t) {
        let r = new URL("https://rpc.walletconnect.org/v1/");
        return (
          r.searchParams.set("chainId", e),
          r.searchParams.set("projectId", t),
          r.toString()
        );
      }
      let _ = [
          "near:mainnet",
          "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
          "eip155:1101",
          "eip155:56",
          "eip155:42161",
          "eip155:7777777",
          "eip155:59144",
          "eip155:324",
          "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
          "eip155:5000",
          "solana:4sgjmw1sunhzsxgspuhpqldx6wiyjntz",
          "eip155:80084",
          "eip155:5003",
          "eip155:100",
          "eip155:8453",
          "eip155:42220",
          "eip155:1313161555",
          "eip155:17000",
          "eip155:1",
          "eip155:300",
          "eip155:1313161554",
          "eip155:1329",
          "eip155:84532",
          "eip155:421614",
          "eip155:11155111",
          "eip155:8217",
          "eip155:43114",
          "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
          "eip155:999999999",
          "eip155:11155420",
          "eip155:80002",
          "eip155:97",
          "eip155:43113",
          "eip155:137",
          "eip155:10",
          "eip155:1301",
          "bip122:000000000019d6689c085ae165831e93",
          "bip122:000000000933ea01ad0ee984209779ba",
        ],
        C = {
          extendRpcUrlWithProjectId(e, t) {
            let r = !1;
            try {
              r = "rpc.walletconnect.org" === new URL(e).host;
            } catch (e) {
              r = !1;
            }
            if (r) {
              let r = new URL(e);
              return (
                r.searchParams.has("projectId") ||
                  r.searchParams.set("projectId", t),
                r.toString()
              );
            }
            return e;
          },
          isCaipNetwork: (e) => "chainNamespace" in e && "caipNetworkId" in e,
          getChainNamespace(e) {
            return this.isCaipNetwork(e) ? e.chainNamespace : y.o.CHAIN.EVM;
          },
          getCaipNetworkId(e) {
            return this.isCaipNetwork(e)
              ? e.caipNetworkId
              : `${y.o.CHAIN.EVM}:${e.id}`;
          },
          getDefaultRpcUrl(e, t, r) {
            let i = e.rpcUrls?.default?.http?.[0];
            return _.includes(t) ? E(t, r) : i || "";
          },
          extendCaipNetwork(
            e,
            { customNetworkImageUrls: t, projectId: r, customRpcUrls: i }
          ) {
            let s = this.getChainNamespace(e),
              n = this.getCaipNetworkId(e),
              a = e.rpcUrls.default.http?.[0],
              o = this.getDefaultRpcUrl(e, n, r),
              c = e?.rpcUrls?.chainDefault?.http?.[0] || a,
              l = i?.[n]?.map((e) => e.url) || [],
              u = [...l, o],
              d = [...l];
            return (
              c && !d.includes(c) && d.push(c),
              {
                ...e,
                chainNamespace: s,
                caipNetworkId: n,
                assets: {
                  imageId: v.L.NetworkImageIds[e.id],
                  imageUrl: t?.[e.id],
                },
                rpcUrls: {
                  ...e.rpcUrls,
                  default: { http: u },
                  chainDefault: { http: d },
                },
              }
            );
          },
          extendCaipNetworks: (
            e,
            { customNetworkImageUrls: t, projectId: r, customRpcUrls: i }
          ) =>
            e.map((e) =>
              C.extendCaipNetwork(e, {
                customNetworkImageUrls: t,
                customRpcUrls: i,
                projectId: r,
              })
            ),
          getViemTransport(e, t, r) {
            let i = [];
            return (
              r?.forEach((e) => {
                i.push(d(e.url, e.config));
              }),
              _.includes(e.caipNetworkId) &&
                i.push(
                  d(E(e.caipNetworkId, t), {
                    fetchOptions: { headers: { "Content-Type": "text/plain" } },
                  })
                ),
              e?.rpcUrls?.default?.http?.forEach((e) => {
                i.push(d(e));
              }),
              g(i)
            );
          },
          extendWagmiTransports(e, t, r) {
            return _.includes(e.caipNetworkId)
              ? g([r, d(this.getDefaultRpcUrl(e, e.caipNetworkId, t))])
              : r;
          },
          getUnsupportedNetwork: (e) => ({
            id: e.split(":")[1],
            caipNetworkId: e,
            name: y.o.UNSUPPORTED_NETWORK_NAME,
            chainNamespace: e.split(":")[0],
            nativeCurrency: { name: "", decimals: 0, symbol: "" },
            rpcUrls: { default: { http: [] } },
          }),
          getCaipNetworkFromStorage(e) {
            let t = b.i.getActiveCaipNetworkId(),
              r = w.W.getAllRequestedCaipNetworks(),
              i = Array.from(w.W.state.chains?.keys() || []),
              s = t?.split(":")[0],
              n = !!s && i.includes(s),
              a = r?.find((e) => e.caipNetworkId === t);
            return n && !a && t
              ? this.getUnsupportedNetwork(t)
              : a || e || r?.[0];
          },
        };
    },
    31942: (e, t, r) => {
      "use strict";
      r.d(t, { Q: () => n });
      var i = r(77136),
        s = r(1405);
      function n(e, t = "wei") {
        return (0, s.J)(e, i.sz[t]);
      }
    },
    32107: function (e) {
      e.exports = {
        name: "en",
        weekdays:
          "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        months:
          "January_February_March_April_May_June_July_August_September_October_November_December".split(
            "_"
          ),
        ordinal: function (e) {
          var t = ["th", "st", "nd", "rd"],
            r = e % 100;
          return "[" + e + (t[(r - 20) % 10] || t[r] || t[0]) + "]";
        },
      };
    },
    32836: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => g });
      var i = r(43708),
        s = r(60500),
        n = r(55458),
        a = r(35558),
        o = r(43359),
        c = r(11076),
        l = r(79277),
        u = r(96641);
      let d = a.w.getAnalyticsUrl(),
        h = new o.Z({ baseUrl: d, clientId: null }),
        p = ["MODAL_CREATED"],
        f = (0, i.BX)({
          timestamp: Date.now(),
          reportedErrors: {},
          data: { type: "track", event: "MODAL_CREATED" },
        }),
        g = {
          state: f,
          subscribe: (e) => (0, i.B1)(f, () => e(f)),
          getSdkProperties() {
            let { projectId: e, sdkType: t, sdkVersion: r } = u.H.state;
            return { projectId: e, st: t, sv: r || "html-wagmi-4.2.2" };
          },
          async _sendAnalyticsEvent(e) {
            try {
              let t = c.U.state.address;
              if (p.includes(e.data.event) || "undefined" == typeof window)
                return;
              await h.post({
                path: "/e",
                params: g.getSdkProperties(),
                body: {
                  eventId: a.w.getUUID(),
                  url: window.location.href,
                  domain: window.location.hostname,
                  timestamp: e.timestamp,
                  props: { ...e.data, address: t },
                },
              }),
                (f.reportedErrors.FORBIDDEN = !1);
            } catch (e) {
              e instanceof Error &&
                e.cause instanceof Response &&
                e.cause.status === s.o.HTTP_STATUS_CODES.FORBIDDEN &&
                !f.reportedErrors.FORBIDDEN &&
                (l.h.open(
                  {
                    shortMessage: "Invalid App Configuration",
                    longMessage: `Origin ${
                      (0, n.IP)() ? window.origin : "uknown"
                    } not found on Allowlist - update configuration on cloud.reown.com`,
                  },
                  "error"
                ),
                (f.reportedErrors.FORBIDDEN = !0));
            }
          },
          sendEvent(e) {
            (f.timestamp = Date.now()),
              (f.data = e),
              u.H.state.features?.analytics && g._sendAnalyticsEvent(f);
          },
        };
    },
    32840: (e, t, r) => {
      "use strict";
      function i(e, { strict: t = !0 } = {}) {
        return (
          !!e &&
          "string" == typeof e &&
          (t ? /^0x[0-9a-fA-F]*$/.test(e) : e.startsWith("0x"))
        );
      }
      r.d(t, { q: () => i });
    },
    33806: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => b });
      var i = r(43708),
        s = r(70799),
        n = r(35558),
        a = r(80977),
        o = r(92555),
        c = r(11076),
        l = r(65819),
        u = r(90906),
        d = r(6193),
        h = r(54252),
        p = r(32836),
        f = r(96641),
        g = r(36665),
        m = r(19628);
      let y = (0, i.BX)({
          loading: !1,
          loadingNamespaceMap: new Map(),
          open: !1,
          shake: !1,
          namespace: void 0,
        }),
        b = (0, o.X)({
          state: y,
          subscribe: (e) => (0, i.B1)(y, () => e(y)),
          subscribeKey: (e, t) => (0, s.u$)(y, e, t),
          async open(e) {
            let t = "connected" === c.U.state.status,
              r = e?.namespace,
              i = u.W.state.activeChain,
              s = r && r !== i,
              o = u.W.getAccountData(e?.namespace)?.caipAddress;
            if (
              (d.x.state.wcBasic
                ? l.N.prefetch({
                    fetchNetworkImages: !1,
                    fetchConnectorImages: !1,
                  })
                : await l.N.prefetch({
                    fetchConnectorImages: !t,
                    fetchFeaturedWallets: !t,
                    fetchRecommendedWallets: !t,
                  }),
              h.a.setFilterByNamespace(e?.namespace),
              b.setLoading(!0, r),
              r && s)
            ) {
              let e =
                u.W.getNetworkData(r)?.caipNetwork ||
                u.W.getRequestedCaipNetworks(r)[0];
              e &&
                a.L.onSwitchNetwork({
                  network: e,
                  ignoreSwitchConfirmation: !0,
                });
            } else {
              let t = u.W.state.noAdapters;
              f.H.state.manualWCControl || (t && !o)
                ? n.w.isMobile()
                  ? m.I.reset("AllWallets")
                  : m.I.reset("ConnectingWalletConnectBasic")
                : e?.view
                ? m.I.reset(e.view, e.data)
                : o
                ? m.I.reset("Account")
                : m.I.reset("Connect");
            }
            (y.open = !0),
              g.z.set({ open: !0 }),
              p.E.sendEvent({
                type: "track",
                event: "MODAL_OPEN",
                properties: { connected: !!o },
              });
          },
          close() {
            let e = f.H.state.enableEmbedded,
              t = !!u.W.state.activeCaipAddress;
            y.open &&
              p.E.sendEvent({
                type: "track",
                event: "MODAL_CLOSE",
                properties: { connected: t },
              }),
              (y.open = !1),
              m.I.reset("Connect"),
              b.clearLoading(),
              e
                ? t
                  ? m.I.replace("Account")
                  : m.I.push("Connect")
                : g.z.set({ open: !1 }),
              d.x.resetUri();
          },
          setLoading(e, t) {
            t && y.loadingNamespaceMap.set(t, e),
              (y.loading = e),
              g.z.set({ loading: e });
          },
          clearLoading() {
            y.loadingNamespaceMap.clear(), (y.loading = !1);
          },
          shake() {
            y.shake ||
              ((y.shake = !0),
              setTimeout(() => {
                y.shake = !1;
              }, 500));
          },
        });
    },
    34250: (e, t, r) => {
      "use strict";
      r.d(t, {
        b: () =>
          function e(t, r) {
            if (t === r) return !0;
            if (t && r && "object" == typeof t && "object" == typeof r) {
              let i, s;
              if (t.constructor !== r.constructor) return !1;
              if (Array.isArray(t) && Array.isArray(r)) {
                if ((i = t.length) !== r.length) return !1;
                for (s = i; 0 != s--; ) if (!e(t[s], r[s])) return !1;
                return !0;
              }
              if (t.valueOf !== Object.prototype.valueOf)
                return t.valueOf() === r.valueOf();
              if (t.toString !== Object.prototype.toString)
                return t.toString() === r.toString();
              let n = Object.keys(t);
              if ((i = n.length) !== Object.keys(r).length) return !1;
              for (s = i; 0 != s--; )
                if (!Object.prototype.hasOwnProperty.call(r, n[s])) return !1;
              for (s = i; 0 != s--; ) {
                let i = n[s];
                if (i && !e(t[i], r[i])) return !1;
              }
              return !0;
            }
            return t != t && r != r;
          },
      });
    },
    34735: (e, t, r) => {
      "use strict";
      r.d(t, { $: () => c });
      var i = r(43708),
        s = r(65819),
        n = r(74623);
      let a = {
          eip155: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
          solana: "a1b58899-f671-4276-6a5e-56ca5bd59700",
          polkadot: "",
          bip122: "0b4838db-0161-4ffe-022d-532bf03dba00",
          cosmos: "",
        },
        o = (0, i.BX)({ networkImagePromises: {} }),
        c = {
          async fetchWalletImage(e) {
            if (e)
              return await s.N._fetchWalletImage(e), this.getWalletImageById(e);
          },
          async fetchNetworkImage(e) {
            if (!e) return;
            let t = this.getNetworkImageById(e);
            return (
              t ||
              (o.networkImagePromises[e] ||
                (o.networkImagePromises[e] = s.N._fetchNetworkImage(e)),
              await o.networkImagePromises[e],
              this.getNetworkImageById(e))
            );
          },
          getWalletImageById(e) {
            if (e) return n.j.state.walletImages[e];
          },
          getWalletImage: (e) =>
            e?.image_url
              ? e?.image_url
              : e?.image_id
              ? n.j.state.walletImages[e.image_id]
              : void 0,
          getNetworkImage: (e) =>
            e?.assets?.imageUrl
              ? e?.assets?.imageUrl
              : e?.assets?.imageId
              ? n.j.state.networkImages[e.assets.imageId]
              : void 0,
          getNetworkImageById(e) {
            if (e) return n.j.state.networkImages[e];
          },
          getConnectorImage: (e) =>
            e?.imageUrl
              ? e.imageUrl
              : e?.imageId
              ? n.j.state.connectorImages[e.imageId]
              : void 0,
          getChainImage: (e) => n.j.state.networkImages[a[e]],
        };
    },
    35558: (e, t, r) => {
      "use strict";
      r.d(t, { w: () => a });
      var i = r(60500),
        s = r(76610),
        n = r(5582);
      let a = {
        isMobile() {
          return (
            !!this.isClient() &&
            !!(
              ("function" == typeof window?.matchMedia &&
                window?.matchMedia("(pointer:coarse)")?.matches) ||
              /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(
                navigator.userAgent
              )
            )
          );
        },
        checkCaipNetwork: (e, t = "") =>
          e?.caipNetworkId.toLocaleLowerCase().includes(t.toLowerCase()),
        isAndroid() {
          if (!this.isMobile()) return !1;
          let e = window?.navigator.userAgent.toLowerCase();
          return a.isMobile() && e.includes("android");
        },
        isIos() {
          if (!this.isMobile()) return !1;
          let e = window?.navigator.userAgent.toLowerCase();
          return e.includes("iphone") || e.includes("ipad");
        },
        isSafari() {
          return (
            !!this.isClient() &&
            window?.navigator.userAgent.toLowerCase().includes("safari")
          );
        },
        isClient: () => "undefined" != typeof window,
        isPairingExpired: (e) => !e || e - Date.now() <= s.oU.TEN_SEC_MS,
        isAllowedRetry: (e, t = s.oU.ONE_SEC_MS) => Date.now() - e >= t,
        copyToClopboard(e) {
          navigator.clipboard.writeText(e);
        },
        isIframe() {
          try {
            return window?.self !== window?.top;
          } catch (e) {
            return !1;
          }
        },
        isSafeApp() {
          if (a.isClient() && window.self !== window.top)
            try {
              let e = window?.location?.ancestorOrigins?.[0];
              if (e) {
                let t = new URL(e),
                  r = new URL("https://app.safe.global");
                return t.hostname === r.hostname;
              }
            } catch {}
          return !1;
        },
        getPairingExpiry: () => Date.now() + s.oU.FOUR_MINUTES_MS,
        getNetworkId: (e) => e?.split(":")[1],
        getPlainAddress: (e) => e?.split(":")[2],
        wait: async (e) =>
          new Promise((t) => {
            setTimeout(t, e);
          }),
        debounce(e, t = 500) {
          let r;
          return (...i) => {
            r && clearTimeout(r),
              (r = setTimeout(function () {
                e(...i);
              }, t));
          };
        },
        isHttpUrl: (e) => e.startsWith("http://") || e.startsWith("https://"),
        formatNativeUrl(e, t, r = null) {
          if (a.isHttpUrl(e)) return this.formatUniversalUrl(e, t);
          let i = e,
            s = r;
          i.includes("://") ||
            ((i = e.replaceAll("/", "").replaceAll(":", "")), (i = `${i}://`)),
            i.endsWith("/") || (i = `${i}/`),
            s && !s?.endsWith("/") && (s = `${s}/`),
            this.isTelegram() &&
              this.isAndroid() &&
              (t = encodeURIComponent(t));
          let n = encodeURIComponent(t);
          return {
            redirect: `${i}wc?uri=${n}`,
            redirectUniversalLink: s ? `${s}wc?uri=${n}` : void 0,
            href: i,
          };
        },
        formatUniversalUrl(e, t) {
          if (!a.isHttpUrl(e)) return this.formatNativeUrl(e, t);
          let r = e;
          r.endsWith("/") || (r = `${r}/`);
          let i = encodeURIComponent(t);
          return { redirect: `${r}wc?uri=${i}`, href: r };
        },
        getOpenTargetForPlatform(e) {
          return "popupWindow" === e
            ? e
            : this.isTelegram()
            ? n.i.getTelegramSocialProvider()
              ? "_top"
              : "_blank"
            : e;
        },
        openHref(e, t, r) {
          window?.open(
            e,
            this.getOpenTargetForPlatform(t),
            r || "noreferrer noopener"
          );
        },
        returnOpenHref(e, t, r) {
          return window?.open(
            e,
            this.getOpenTargetForPlatform(t),
            r || "noreferrer noopener"
          );
        },
        isTelegram: () =>
          "undefined" != typeof window &&
          (!!window.TelegramWebviewProxy ||
            !!window.Telegram ||
            !!window.TelegramWebviewProxyProto),
        isPWA() {
          if ("undefined" == typeof window) return !1;
          let e = window.matchMedia?.("(display-mode: standalone)")?.matches,
            t = window?.navigator?.standalone;
          return !!(e || t);
        },
        preloadImage: async (e) =>
          Promise.race([
            new Promise((t, r) => {
              let i = new Image();
              (i.onload = t),
                (i.onerror = r),
                (i.crossOrigin = "anonymous"),
                (i.src = e);
            }),
            a.wait(2e3),
          ]),
        formatBalance(e, t) {
          let r = "0.000";
          if ("string" == typeof e) {
            let t = Number(e);
            if (t) {
              let e = Math.floor(1e3 * t) / 1e3;
              e && (r = e.toString());
            }
          }
          return `${r}${t ? ` ${t}` : ""}`;
        },
        formatBalance2(e, t) {
          let r;
          if ("0" === e) r = "0";
          else if ("string" == typeof e) {
            let t = Number(e);
            t && (r = t.toString().match(/^-?\d+(?:\.\d{0,3})?/u)?.[0]);
          }
          return { value: r ?? "0", rest: "0" === r ? "000" : "", symbol: t };
        },
        getApiUrl: () => i.o.W3M_API_URL,
        getBlockchainApiUrl: () => i.o.BLOCKCHAIN_API_RPC_URL,
        getAnalyticsUrl: () => i.o.PULSE_API_URL,
        getUUID: () =>
          crypto?.randomUUID
            ? crypto.randomUUID()
            : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e) => {
                let t = (16 * Math.random()) | 0;
                return ("x" === e ? t : (3 & t) | 8).toString(16);
              }),
        parseError: (e) =>
          "string" == typeof e
            ? e
            : "string" == typeof e?.issues?.[0]?.message
            ? e.issues[0].message
            : e instanceof Error
            ? e.message
            : "Unknown error",
        sortRequestedNetworks(e, t = []) {
          let r = {};
          return (
            t &&
              e &&
              (e.forEach((e, t) => {
                r[e] = t;
              }),
              t.sort((e, t) => {
                let i = r[e.id],
                  s = r[t.id];
                return void 0 !== i && void 0 !== s
                  ? i - s
                  : void 0 !== i
                  ? -1
                  : 1 * (void 0 !== s);
              })),
            t
          );
        },
        calculateBalance(e) {
          let t = 0;
          for (let r of e) t += r.value ?? 0;
          return t;
        },
        formatTokenBalance(e) {
          let [t, r] = e.toFixed(2).split(".");
          return { dollars: t, pennies: r };
        },
        isAddress(e, t = "eip155") {
          switch (t) {
            case "eip155":
              if (
                /^(?:0x)?[0-9a-f]{40}$/iu.test(e) &&
                (/^(?:0x)?[0-9a-f]{40}$/iu.test(e) ||
                  /^(?:0x)?[0-9A-F]{40}$/iu.test(e))
              )
                return !0;
              return !1;
            case "solana":
              return /[1-9A-HJ-NP-Za-km-z]{32,44}$/iu.test(e);
            default:
              return !1;
          }
        },
        uniqueBy(e, t) {
          let r = new Set();
          return e.filter((e) => {
            let i = e[t];
            return !r.has(i) && (r.add(i), !0);
          });
        },
        generateSdkVersion(e, t, r) {
          let i =
            0 === e.length
              ? s.oU.ADAPTER_TYPES.UNIVERSAL
              : e.map((e) => e.adapterType).join(",");
          return `${t}-${i}-${r}`;
        },
        createAccount: (e, t, r, i, s) => ({
          namespace: e,
          address: t,
          type: r,
          publicKey: i,
          path: s,
        }),
        isCaipAddress(e) {
          if ("string" != typeof e) return !1;
          let t = e.split(":"),
            r = t[0];
          return 3 === t.filter(Boolean).length && r in i.o.CHAIN_NAME_MAP;
        },
        isMac() {
          let e = window?.navigator.userAgent.toLowerCase();
          return e.includes("macintosh") && !e.includes("safari");
        },
        formatTelegramSocialLoginUrl(e) {
          let t = `--${encodeURIComponent(window?.location.href)}`,
            r = "state=";
          if ("auth.magic.link" === new URL(e).host) {
            let i = "provider_authorization_url=",
              s = e.substring(e.indexOf(i) + i.length),
              n = this.injectIntoUrl(decodeURIComponent(s), r, t);
            return e.replace(s, encodeURIComponent(n));
          }
          return this.injectIntoUrl(e, r, t);
        },
        injectIntoUrl(e, t, r) {
          let i = e.indexOf(t);
          if (-1 === i)
            throw Error(`${t} parameter not found in the URL: ${e}`);
          let s = e.indexOf("&", i),
            n = t.length,
            a = -1 !== s ? s : e.length,
            o = e.substring(0, i + n),
            c = e.substring(i + n, a);
          return o + (c + r) + e.substring(s);
        },
      };
    },
    35883: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => u, o: () => l });
      var i = r(36444),
        s = r(80844),
        n = r(38978),
        a = r(65003),
        o = r(81757);
      let c = new a.A(8192);
      function l(e, t) {
        if (c.has(`${e}.${t}`)) return c.get(`${e}.${t}`);
        let r = t ? `${t}${e.toLowerCase()}` : e.substring(2).toLowerCase(),
          i = (0, n.S)((0, s.Af)(r), "bytes"),
          a = (t ? r.substring(`${t}0x`.length) : r).split("");
        for (let e = 0; e < 40; e += 2)
          i[e >> 1] >> 4 >= 8 && a[e] && (a[e] = a[e].toUpperCase()),
            (15 & i[e >> 1]) >= 8 &&
              a[e + 1] &&
              (a[e + 1] = a[e + 1].toUpperCase());
        let o = `0x${a.join("")}`;
        return c.set(`${e}.${t}`, o), o;
      }
      function u(e, t) {
        if (!(0, o.P)(e, { strict: !1 })) throw new i.M({ address: e });
        return l(e, t);
      }
    },
    36444: (e, t, r) => {
      "use strict";
      r.d(t, { M: () => s });
      var i = r(7441);
      class s extends i.C {
        constructor({ address: e }) {
          super(`Address "${e}" is invalid.`, {
            metaMessages: [
              "- Address must be a hex value of 20 bytes (40 hex characters).",
              "- Address must match its checksum counterpart.",
            ],
            name: "InvalidAddressError",
          });
        }
      }
    },
    36665: (e, t, r) => {
      "use strict";
      r.d(t, { z: () => a });
      var i = r(43708),
        s = r(70799);
      let n = (0, i.BX)({
          loading: !1,
          open: !1,
          selectedNetworkId: void 0,
          activeChain: void 0,
          initialized: !1,
        }),
        a = {
          state: n,
          subscribe: (e) => (0, i.B1)(n, () => e(n)),
          subscribeOpen: (e) => (0, s.u$)(n, "open", e),
          set(e) {
            Object.assign(n, { ...n, ...e });
          },
        };
    },
    36984: (e, t, r) => {
      "use strict";
      r.d(t, { db: () => n, eV: () => s });
      var i = r(58980);
      function s(e, { dir: t, size: r = 32 } = {}) {
        return "string" == typeof e
          ? n(e, { dir: t, size: r })
          : (function (e, { dir: t, size: r = 32 } = {}) {
              if (null === r) return e;
              if (e.length > r)
                throw new i.Fl({
                  size: e.length,
                  targetSize: r,
                  type: "bytes",
                });
              let s = new Uint8Array(r);
              for (let i = 0; i < r; i++) {
                let n = "right" === t;
                s[n ? i : r - i - 1] = e[n ? i : e.length - i - 1];
              }
              return s;
            })(e, { dir: t, size: r });
      }
      function n(e, { dir: t, size: r = 32 } = {}) {
        if (null === r) return e;
        let s = e.replace("0x", "");
        if (s.length > 2 * r)
          throw new i.Fl({
            size: Math.ceil(s.length / 2),
            targetSize: r,
            type: "hex",
          });
        return `0x${s["right" === t ? "padEnd" : "padStart"](2 * r, "0")}`;
      }
    },
    38978: (e, t, r) => {
      "use strict";
      r.d(t, { S: () => O });
      var i = r(2255);
      let s = BigInt(0x100000000 - 1),
        n = BigInt(32),
        a = (e, t, r) => (e << r) | (t >>> (32 - r)),
        o = (e, t, r) => (t << r) | (e >>> (32 - r)),
        c = (e, t, r) => (t << (r - 32)) | (e >>> (64 - r)),
        l = (e, t, r) => (e << (r - 32)) | (t >>> (64 - r));
      var u = r(26607);
      let d = [],
        h = [],
        p = [],
        f = BigInt(0),
        g = BigInt(1),
        m = BigInt(2),
        y = BigInt(7),
        b = BigInt(256),
        w = BigInt(113);
      for (let e = 0, t = g, r = 1, i = 0; e < 24; e++) {
        ([r, i] = [i, (2 * r + 3 * i) % 5]),
          d.push(2 * (5 * i + r)),
          h.push((((e + 1) * (e + 2)) / 2) % 64);
        let s = f;
        for (let e = 0; e < 7; e++)
          (t = ((t << g) ^ ((t >> y) * w)) % b) & m &&
            (s ^= g << ((g << BigInt(e)) - g));
        p.push(s);
      }
      let [v, E] = (function (e, t = !1) {
          let r = new Uint32Array(e.length),
            i = new Uint32Array(e.length);
          for (let a = 0; a < e.length; a++) {
            let { h: o, l: c } = (function (e, t = !1) {
              return t
                ? { h: Number(e & s), l: Number((e >> n) & s) }
                : { h: 0 | Number((e >> n) & s), l: 0 | Number(e & s) };
            })(e[a], t);
            [r[a], i[a]] = [o, c];
          }
          return [r, i];
        })(p, !0),
        _ = (e, t, r) => (r > 32 ? c(e, t, r) : a(e, t, r)),
        C = (e, t, r) => (r > 32 ? l(e, t, r) : o(e, t, r));
      class A extends u.Vw {
        constructor(e, t, r, s = !1, n = 24) {
          if (
            (super(),
            (this.pos = 0),
            (this.posOut = 0),
            (this.finished = !1),
            (this.destroyed = !1),
            (this.enableXOF = !1),
            (this.blockLen = e),
            (this.suffix = t),
            (this.outputLen = r),
            (this.enableXOF = s),
            (this.rounds = n),
            (0, i.Fe)(r),
            0 >= this.blockLen || this.blockLen >= 200)
          )
            throw Error("Sha3 supports only keccak-f1600 function");
          (this.state = new Uint8Array(200)),
            (this.state32 = (0, u.DH)(this.state));
        }
        keccak() {
          u.qv || (0, u.Fc)(this.state32),
            (function (e, t = 24) {
              let r = new Uint32Array(10);
              for (let i = 24 - t; i < 24; i++) {
                for (let t = 0; t < 10; t++)
                  r[t] = e[t] ^ e[t + 10] ^ e[t + 20] ^ e[t + 30] ^ e[t + 40];
                for (let t = 0; t < 10; t += 2) {
                  let i = (t + 8) % 10,
                    s = (t + 2) % 10,
                    n = r[s],
                    a = r[s + 1],
                    o = _(n, a, 1) ^ r[i],
                    c = C(n, a, 1) ^ r[i + 1];
                  for (let r = 0; r < 50; r += 10)
                    (e[t + r] ^= o), (e[t + r + 1] ^= c);
                }
                let t = e[2],
                  s = e[3];
                for (let r = 0; r < 24; r++) {
                  let i = h[r],
                    n = _(t, s, i),
                    a = C(t, s, i),
                    o = d[r];
                  (t = e[o]), (s = e[o + 1]), (e[o] = n), (e[o + 1] = a);
                }
                for (let t = 0; t < 50; t += 10) {
                  for (let i = 0; i < 10; i++) r[i] = e[t + i];
                  for (let i = 0; i < 10; i++)
                    e[t + i] ^= ~r[(i + 2) % 10] & r[(i + 4) % 10];
                }
                (e[0] ^= v[i]), (e[1] ^= E[i]);
              }
              r.fill(0);
            })(this.state32, this.rounds),
            u.qv || (0, u.Fc)(this.state32),
            (this.posOut = 0),
            (this.pos = 0);
        }
        update(e) {
          (0, i.CC)(this);
          let { blockLen: t, state: r } = this,
            s = (e = (0, u.ZJ)(e)).length;
          for (let i = 0; i < s; ) {
            let n = Math.min(t - this.pos, s - i);
            for (let t = 0; t < n; t++) r[this.pos++] ^= e[i++];
            this.pos === t && this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished) return;
          this.finished = !0;
          let { state: e, suffix: t, pos: r, blockLen: i } = this;
          (e[r] ^= t),
            (128 & t) != 0 && r === i - 1 && this.keccak(),
            (e[i - 1] ^= 128),
            this.keccak();
        }
        writeInto(e) {
          (0, i.CC)(this, !1), (0, i.DO)(e), this.finish();
          let t = this.state,
            { blockLen: r } = this;
          for (let i = 0, s = e.length; i < s; ) {
            this.posOut >= r && this.keccak();
            let n = Math.min(r - this.posOut, s - i);
            e.set(t.subarray(this.posOut, this.posOut + n), i),
              (this.posOut += n),
              (i += n);
          }
          return e;
        }
        xofInto(e) {
          if (!this.enableXOF)
            throw Error("XOF is not possible for this instance");
          return this.writeInto(e);
        }
        xof(e) {
          return (0, i.Fe)(e), this.xofInto(new Uint8Array(e));
        }
        digestInto(e) {
          if (((0, i.Ht)(e, this), this.finished))
            throw Error("digest() was already called");
          return this.writeInto(e), this.destroy(), e;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          (this.destroyed = !0), this.state.fill(0);
        }
        _cloneInto(e) {
          let {
            blockLen: t,
            suffix: r,
            outputLen: i,
            rounds: s,
            enableXOF: n,
          } = this;
          return (
            e || (e = new A(t, r, i, n, s)),
            e.state32.set(this.state32),
            (e.pos = this.pos),
            (e.posOut = this.posOut),
            (e.finished = this.finished),
            (e.rounds = s),
            (e.suffix = r),
            (e.outputLen = i),
            (e.enableXOF = n),
            (e.destroyed = this.destroyed),
            e
          );
        }
      }
      let I = (0, u.ld)(() => new A(136, 1, 32));
      var S = r(32840),
        N = r(80844),
        T = r(67622);
      function O(e, t) {
        let r = I((0, S.q)(e, { strict: !1 }) ? (0, N.ZJ)(e) : e);
        return "bytes" === (t || "hex") ? r : (0, T.nj)(r);
      }
    },
    39853: (e, t, r) => {
      "use strict";
      r.d(t, { X: () => o, k: () => c });
      var i = r(52020),
        s = r(7165),
        n = r(6784),
        a = r(57948),
        o = class extends a.k {
          #i;
          #s;
          #n;
          #a;
          #o;
          #c;
          #l;
          constructor(e) {
            super(),
              (this.#l = !1),
              (this.#c = e.defaultOptions),
              this.setOptions(e.options),
              (this.observers = []),
              (this.#a = e.client),
              (this.#n = this.#a.getQueryCache()),
              (this.queryKey = e.queryKey),
              (this.queryHash = e.queryHash),
              (this.#i = (function (e) {
                let t =
                    "function" == typeof e.initialData
                      ? e.initialData()
                      : e.initialData,
                  r = void 0 !== t,
                  i = r
                    ? "function" == typeof e.initialDataUpdatedAt
                      ? e.initialDataUpdatedAt()
                      : e.initialDataUpdatedAt
                    : 0;
                return {
                  data: t,
                  dataUpdateCount: 0,
                  dataUpdatedAt: r ? i ?? Date.now() : 0,
                  error: null,
                  errorUpdateCount: 0,
                  errorUpdatedAt: 0,
                  fetchFailureCount: 0,
                  fetchFailureReason: null,
                  fetchMeta: null,
                  isInvalidated: !1,
                  status: r ? "success" : "pending",
                  fetchStatus: "idle",
                };
              })(this.options)),
              (this.state = e.state ?? this.#i),
              this.scheduleGc();
          }
          get meta() {
            return this.options.meta;
          }
          get promise() {
            return this.#o?.promise;
          }
          setOptions(e) {
            (this.options = { ...this.#c, ...e }),
              this.updateGcTime(this.options.gcTime);
          }
          optionalRemove() {
            this.observers.length ||
              "idle" !== this.state.fetchStatus ||
              this.#n.remove(this);
          }
          setData(e, t) {
            let r = (0, i.pl)(this.state.data, e, this.options);
            return (
              this.#u({
                data: r,
                type: "success",
                dataUpdatedAt: t?.updatedAt,
                manual: t?.manual,
              }),
              r
            );
          }
          setState(e, t) {
            this.#u({ type: "setState", state: e, setStateOptions: t });
          }
          cancel(e) {
            let t = this.#o?.promise;
            return (
              this.#o?.cancel(e),
              t ? t.then(i.lQ).catch(i.lQ) : Promise.resolve()
            );
          }
          destroy() {
            super.destroy(), this.cancel({ silent: !0 });
          }
          reset() {
            this.destroy(), this.setState(this.#i);
          }
          isActive() {
            return this.observers.some(
              (e) => !1 !== (0, i.Eh)(e.options.enabled, this)
            );
          }
          isDisabled() {
            return this.getObserversCount() > 0
              ? !this.isActive()
              : this.options.queryFn === i.hT ||
                  this.state.dataUpdateCount + this.state.errorUpdateCount ===
                    0;
          }
          isStale() {
            return (
              !!this.state.isInvalidated ||
              (this.getObserversCount() > 0
                ? this.observers.some((e) => e.getCurrentResult().isStale)
                : void 0 === this.state.data)
            );
          }
          isStaleByTime(e = 0) {
            return (
              this.state.isInvalidated ||
              void 0 === this.state.data ||
              !(0, i.j3)(this.state.dataUpdatedAt, e)
            );
          }
          onFocus() {
            let e = this.observers.find((e) => e.shouldFetchOnWindowFocus());
            e?.refetch({ cancelRefetch: !1 }), this.#o?.continue();
          }
          onOnline() {
            let e = this.observers.find((e) => e.shouldFetchOnReconnect());
            e?.refetch({ cancelRefetch: !1 }), this.#o?.continue();
          }
          addObserver(e) {
            this.observers.includes(e) ||
              (this.observers.push(e),
              this.clearGcTimeout(),
              this.#n.notify({
                type: "observerAdded",
                query: this,
                observer: e,
              }));
          }
          removeObserver(e) {
            this.observers.includes(e) &&
              ((this.observers = this.observers.filter((t) => t !== e)),
              this.observers.length ||
                (this.#o &&
                  (this.#l
                    ? this.#o.cancel({ revert: !0 })
                    : this.#o.cancelRetry()),
                this.scheduleGc()),
              this.#n.notify({
                type: "observerRemoved",
                query: this,
                observer: e,
              }));
          }
          getObserversCount() {
            return this.observers.length;
          }
          invalidate() {
            this.state.isInvalidated || this.#u({ type: "invalidate" });
          }
          fetch(e, t) {
            if ("idle" !== this.state.fetchStatus) {
              if (void 0 !== this.state.data && t?.cancelRefetch)
                this.cancel({ silent: !0 });
              else if (this.#o) return this.#o.continueRetry(), this.#o.promise;
            }
            if ((e && this.setOptions(e), !this.options.queryFn)) {
              let e = this.observers.find((e) => e.options.queryFn);
              e && this.setOptions(e.options);
            }
            let r = new AbortController(),
              s = (e) => {
                Object.defineProperty(e, "signal", {
                  enumerable: !0,
                  get: () => ((this.#l = !0), r.signal),
                });
              },
              a = {
                fetchOptions: t,
                options: this.options,
                queryKey: this.queryKey,
                client: this.#a,
                state: this.state,
                fetchFn: () => {
                  let e = (0, i.ZM)(this.options, t),
                    r = {
                      client: this.#a,
                      queryKey: this.queryKey,
                      meta: this.meta,
                    };
                  return (s(r), (this.#l = !1), this.options.persister)
                    ? this.options.persister(e, r, this)
                    : e(r);
                },
              };
            s(a),
              this.options.behavior?.onFetch(a, this),
              (this.#s = this.state),
              ("idle" === this.state.fetchStatus ||
                this.state.fetchMeta !== a.fetchOptions?.meta) &&
                this.#u({ type: "fetch", meta: a.fetchOptions?.meta });
            let o = (e) => {
              ((0, n.wm)(e) && e.silent) ||
                this.#u({ type: "error", error: e }),
                (0, n.wm)(e) ||
                  (this.#n.config.onError?.(e, this),
                  this.#n.config.onSettled?.(this.state.data, e, this)),
                this.scheduleGc();
            };
            return (
              (this.#o = (0, n.II)({
                initialPromise: t?.initialPromise,
                fn: a.fetchFn,
                abort: r.abort.bind(r),
                onSuccess: (e) => {
                  if (void 0 === e)
                    return void o(Error(`${this.queryHash} data is undefined`));
                  try {
                    this.setData(e);
                  } catch (e) {
                    o(e);
                    return;
                  }
                  this.#n.config.onSuccess?.(e, this),
                    this.#n.config.onSettled?.(e, this.state.error, this),
                    this.scheduleGc();
                },
                onError: o,
                onFail: (e, t) => {
                  this.#u({ type: "failed", failureCount: e, error: t });
                },
                onPause: () => {
                  this.#u({ type: "pause" });
                },
                onContinue: () => {
                  this.#u({ type: "continue" });
                },
                retry: a.options.retry,
                retryDelay: a.options.retryDelay,
                networkMode: a.options.networkMode,
                canRun: () => !0,
              })),
              this.#o.start()
            );
          }
          #u(e) {
            (this.state = ((t) => {
              switch (e.type) {
                case "failed":
                  return {
                    ...t,
                    fetchFailureCount: e.failureCount,
                    fetchFailureReason: e.error,
                  };
                case "pause":
                  return { ...t, fetchStatus: "paused" };
                case "continue":
                  return { ...t, fetchStatus: "fetching" };
                case "fetch":
                  return {
                    ...t,
                    ...c(t.data, this.options),
                    fetchMeta: e.meta ?? null,
                  };
                case "success":
                  return {
                    ...t,
                    data: e.data,
                    dataUpdateCount: t.dataUpdateCount + 1,
                    dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
                    error: null,
                    isInvalidated: !1,
                    status: "success",
                    ...(!e.manual && {
                      fetchStatus: "idle",
                      fetchFailureCount: 0,
                      fetchFailureReason: null,
                    }),
                  };
                case "error":
                  let r = e.error;
                  if ((0, n.wm)(r) && r.revert && this.#s)
                    return { ...this.#s, fetchStatus: "idle" };
                  return {
                    ...t,
                    error: r,
                    errorUpdateCount: t.errorUpdateCount + 1,
                    errorUpdatedAt: Date.now(),
                    fetchFailureCount: t.fetchFailureCount + 1,
                    fetchFailureReason: r,
                    fetchStatus: "idle",
                    status: "error",
                  };
                case "invalidate":
                  return { ...t, isInvalidated: !0 };
                case "setState":
                  return { ...t, ...e.state };
              }
            })(this.state)),
              s.jG.batch(() => {
                this.observers.forEach((e) => {
                  e.onQueryUpdate();
                }),
                  this.#n.notify({ query: this, type: "updated", action: e });
              });
          }
        };
      function c(e, t) {
        return {
          fetchFailureCount: 0,
          fetchFailureReason: null,
          fetchStatus: (0, n.v_)(t.networkMode) ? "fetching" : "paused",
          ...(void 0 === e && { error: null, status: "pending" }),
        };
      }
    },
    40052: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.fromMiliseconds = t.toMiliseconds = void 0);
      let i = r(64587);
      (t.toMiliseconds = function (e) {
        return e * i.ONE_THOUSAND;
      }),
        (t.fromMiliseconds = function (e) {
          return Math.floor(e / i.ONE_THOUSAND);
        });
    },
    40194: (e, t, r) => {
      "use strict";
      r.d(t, { r: () => i });
      let i = "2.17.2";
    },
    40347: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        r(86313).__exportStar(r(86156), t);
    },
    40662: (e) => {
      "use strict";
      var t,
        r = "object" == typeof Reflect ? Reflect : null,
        i =
          r && "function" == typeof r.apply
            ? r.apply
            : function (e, t, r) {
                return Function.prototype.apply.call(e, t, r);
              };
      t =
        r && "function" == typeof r.ownKeys
          ? r.ownKeys
          : Object.getOwnPropertySymbols
          ? function (e) {
              return Object.getOwnPropertyNames(e).concat(
                Object.getOwnPropertySymbols(e)
              );
            }
          : function (e) {
              return Object.getOwnPropertyNames(e);
            };
      var s =
        Number.isNaN ||
        function (e) {
          return e != e;
        };
      function n() {
        n.init.call(this);
      }
      (e.exports = n),
        (e.exports.once = function (e, t) {
          return new Promise(function (r, i) {
            var s, n, a;
            function o(r) {
              e.removeListener(t, c), i(r);
            }
            function c() {
              "function" == typeof e.removeListener &&
                e.removeListener("error", o),
                r([].slice.call(arguments));
            }
            g(e, t, c, { once: !0 }),
              "error" !== t &&
                ((s = e),
                (n = o),
                (a = { once: !0 }),
                "function" == typeof s.on && g(s, "error", n, a));
          });
        }),
        (n.EventEmitter = n),
        (n.prototype._events = void 0),
        (n.prototype._eventsCount = 0),
        (n.prototype._maxListeners = void 0);
      var a = 10;
      function o(e) {
        if ("function" != typeof e)
          throw TypeError(
            'The "listener" argument must be of type Function. Received type ' +
              typeof e
          );
      }
      function c(e) {
        return void 0 === e._maxListeners
          ? n.defaultMaxListeners
          : e._maxListeners;
      }
      function l(e, t, r, i) {
        if (
          (o(r),
          void 0 === (n = e._events)
            ? ((n = e._events = Object.create(null)), (e._eventsCount = 0))
            : (void 0 !== n.newListener &&
                (e.emit("newListener", t, r.listener ? r.listener : r),
                (n = e._events)),
              (a = n[t])),
          void 0 === a)
        )
          (a = n[t] = r), ++e._eventsCount;
        else if (
          ("function" == typeof a
            ? (a = n[t] = i ? [r, a] : [a, r])
            : i
            ? a.unshift(r)
            : a.push(r),
          (s = c(e)) > 0 && a.length > s && !a.warned)
        ) {
          a.warned = !0;
          var s,
            n,
            a,
            l = Error(
              "Possible EventEmitter memory leak detected. " +
                a.length +
                " " +
                String(t) +
                " listeners added. Use emitter.setMaxListeners() to increase limit"
            );
          (l.name = "MaxListenersExceededWarning"),
            (l.emitter = e),
            (l.type = t),
            (l.count = a.length),
            console && console.warn && console.warn(l);
        }
        return e;
      }
      function u() {
        if (!this.fired)
          return (this.target.removeListener(this.type, this.wrapFn),
          (this.fired = !0),
          0 == arguments.length)
            ? this.listener.call(this.target)
            : this.listener.apply(this.target, arguments);
      }
      function d(e, t, r) {
        var i = { fired: !1, wrapFn: void 0, target: e, type: t, listener: r },
          s = u.bind(i);
        return (s.listener = r), (i.wrapFn = s), s;
      }
      function h(e, t, r) {
        var i = e._events;
        if (void 0 === i) return [];
        var s = i[t];
        return void 0 === s
          ? []
          : "function" == typeof s
          ? r
            ? [s.listener || s]
            : [s]
          : r
          ? (function (e) {
              for (var t = Array(e.length), r = 0; r < t.length; ++r)
                t[r] = e[r].listener || e[r];
              return t;
            })(s)
          : f(s, s.length);
      }
      function p(e) {
        var t = this._events;
        if (void 0 !== t) {
          var r = t[e];
          if ("function" == typeof r) return 1;
          if (void 0 !== r) return r.length;
        }
        return 0;
      }
      function f(e, t) {
        for (var r = Array(t), i = 0; i < t; ++i) r[i] = e[i];
        return r;
      }
      function g(e, t, r, i) {
        if ("function" == typeof e.on) i.once ? e.once(t, r) : e.on(t, r);
        else if ("function" == typeof e.addEventListener)
          e.addEventListener(t, function s(n) {
            i.once && e.removeEventListener(t, s), r(n);
          });
        else
          throw TypeError(
            'The "emitter" argument must be of type EventEmitter. Received type ' +
              typeof e
          );
      }
      Object.defineProperty(n, "defaultMaxListeners", {
        enumerable: !0,
        get: function () {
          return a;
        },
        set: function (e) {
          if ("number" != typeof e || e < 0 || s(e))
            throw RangeError(
              'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                e +
                "."
            );
          a = e;
        },
      }),
        (n.init = function () {
          (void 0 === this._events ||
            this._events === Object.getPrototypeOf(this)._events) &&
            ((this._events = Object.create(null)), (this._eventsCount = 0)),
            (this._maxListeners = this._maxListeners || void 0);
        }),
        (n.prototype.setMaxListeners = function (e) {
          if ("number" != typeof e || e < 0 || s(e))
            throw RangeError(
              'The value of "n" is out of range. It must be a non-negative number. Received ' +
                e +
                "."
            );
          return (this._maxListeners = e), this;
        }),
        (n.prototype.getMaxListeners = function () {
          return c(this);
        }),
        (n.prototype.emit = function (e) {
          for (var t = [], r = 1; r < arguments.length; r++)
            t.push(arguments[r]);
          var s = "error" === e,
            n = this._events;
          if (void 0 !== n) s = s && void 0 === n.error;
          else if (!s) return !1;
          if (s) {
            if ((t.length > 0 && (a = t[0]), a instanceof Error)) throw a;
            var a,
              o = Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
            throw ((o.context = a), o);
          }
          var c = n[e];
          if (void 0 === c) return !1;
          if ("function" == typeof c) i(c, this, t);
          else
            for (var l = c.length, u = f(c, l), r = 0; r < l; ++r)
              i(u[r], this, t);
          return !0;
        }),
        (n.prototype.addListener = function (e, t) {
          return l(this, e, t, !1);
        }),
        (n.prototype.on = n.prototype.addListener),
        (n.prototype.prependListener = function (e, t) {
          return l(this, e, t, !0);
        }),
        (n.prototype.once = function (e, t) {
          return o(t), this.on(e, d(this, e, t)), this;
        }),
        (n.prototype.prependOnceListener = function (e, t) {
          return o(t), this.prependListener(e, d(this, e, t)), this;
        }),
        (n.prototype.removeListener = function (e, t) {
          var r, i, s, n, a;
          if ((o(t), void 0 === (i = this._events) || void 0 === (r = i[e])))
            return this;
          if (r === t || r.listener === t)
            0 == --this._eventsCount
              ? (this._events = Object.create(null))
              : (delete i[e],
                i.removeListener &&
                  this.emit("removeListener", e, r.listener || t));
          else if ("function" != typeof r) {
            for (s = -1, n = r.length - 1; n >= 0; n--)
              if (r[n] === t || r[n].listener === t) {
                (a = r[n].listener), (s = n);
                break;
              }
            if (s < 0) return this;
            0 === s
              ? r.shift()
              : (function (e, t) {
                  for (; t + 1 < e.length; t++) e[t] = e[t + 1];
                  e.pop();
                })(r, s),
              1 === r.length && (i[e] = r[0]),
              void 0 !== i.removeListener &&
                this.emit("removeListener", e, a || t);
          }
          return this;
        }),
        (n.prototype.off = n.prototype.removeListener),
        (n.prototype.removeAllListeners = function (e) {
          var t, r, i;
          if (void 0 === (r = this._events)) return this;
          if (void 0 === r.removeListener)
            return (
              0 == arguments.length
                ? ((this._events = Object.create(null)),
                  (this._eventsCount = 0))
                : void 0 !== r[e] &&
                  (0 == --this._eventsCount
                    ? (this._events = Object.create(null))
                    : delete r[e]),
              this
            );
          if (0 == arguments.length) {
            var s,
              n = Object.keys(r);
            for (i = 0; i < n.length; ++i)
              "removeListener" !== (s = n[i]) && this.removeAllListeners(s);
            return (
              this.removeAllListeners("removeListener"),
              (this._events = Object.create(null)),
              (this._eventsCount = 0),
              this
            );
          }
          if ("function" == typeof (t = r[e])) this.removeListener(e, t);
          else if (void 0 !== t)
            for (i = t.length - 1; i >= 0; i--) this.removeListener(e, t[i]);
          return this;
        }),
        (n.prototype.listeners = function (e) {
          return h(this, e, !0);
        }),
        (n.prototype.rawListeners = function (e) {
          return h(this, e, !1);
        }),
        (n.listenerCount = function (e, t) {
          return "function" == typeof e.listenerCount
            ? e.listenerCount(t)
            : p.call(e, t);
        }),
        (n.prototype.listenerCount = p),
        (n.prototype.eventNames = function () {
          return this._eventsCount > 0 ? t(this._events) : [];
        });
    },
    41514: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => s, R: () => i });
      let i = (e) => e,
        s = (e) => e;
    },
    41757: (e, t, r) => {
      "use strict";
      function i(e) {
        return { formatters: void 0, fees: void 0, serializers: void 0, ...e };
      }
      r.d(t, { NBY: () => s, rCZ: () => n, tWt: () => o, Rn0: () => c });
      let s = i({
          id: 56,
          name: "BNB Smart Chain",
          nativeCurrency: { decimals: 18, name: "BNB", symbol: "BNB" },
          rpcUrls: { default: { http: ["https://56.rpc.thirdweb.com"] } },
          blockExplorers: {
            default: {
              name: "BscScan",
              url: "https://bscscan.com",
              apiUrl: "https://api.bscscan.com/api",
            },
          },
          contracts: {
            multicall3: {
              address: "0xca11bde05977b3631167028862be2a173976ca11",
              blockCreated: 0xf2f12c,
            },
          },
        }),
        n = i({
          id: 1,
          name: "Ethereum",
          nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
          rpcUrls: { default: { http: ["https://eth.merkle.io"] } },
          blockExplorers: {
            default: {
              name: "Etherscan",
              url: "https://etherscan.io",
              apiUrl: "https://api.etherscan.io/api",
            },
          },
          contracts: {
            ensRegistry: {
              address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
            },
            ensUniversalResolver: {
              address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
              blockCreated: 0x125db65,
            },
            multicall3: {
              address: "0xca11bde05977b3631167028862be2a173976ca11",
              blockCreated: 0xdb04c1,
            },
          },
        });
      function a(e) {
        return { formatters: void 0, fees: void 0, serializers: void 0, ...e };
      }
      let o = a({
          id: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
          name: "Solana",
          network: "solana-mainnet",
          nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
          rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
          blockExplorers: {
            default: { name: "Solscan", url: "https://solscan.io" },
          },
          testnet: !1,
          chainNamespace: "solana",
          caipNetworkId: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
          deprecatedCaipNetworkId: "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ",
        }),
        c = a({
          id: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
          name: "Solana Devnet",
          network: "solana-devnet",
          nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
          rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
          blockExplorers: {
            default: { name: "Solscan", url: "https://solscan.io" },
          },
          testnet: !0,
          chainNamespace: "solana",
          caipNetworkId: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
          deprecatedCaipNetworkId: "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K",
        });
      a({
        id: "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
        name: "Solana Testnet",
        network: "solana-testnet",
        nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
        rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
        blockExplorers: {
          default: { name: "Solscan", url: "https://solscan.io" },
        },
        testnet: !0,
        chainNamespace: "solana",
        caipNetworkId: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      }),
        a({
          id: "000000000019d6689c085ae165831e93",
          caipNetworkId: "bip122:000000000019d6689c085ae165831e93",
          chainNamespace: "bip122",
          name: "Bitcoin",
          nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 8 },
          rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
        }),
        a({
          id: "000000000933ea01ad0ee984209779ba",
          caipNetworkId: "bip122:000000000933ea01ad0ee984209779ba",
          chainNamespace: "bip122",
          name: "Bitcoin Testnet",
          nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 8 },
          rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
          testnet: !0,
        });
    },
    42142: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => s });
      var i = r(10231);
      function s(
        e,
        { delay: t = 100, retryCount: r = 2, shouldRetry: n = () => !0 } = {}
      ) {
        return new Promise((s, a) => {
          let o = async ({ count: c = 0 } = {}) => {
            let l = async ({ error: e }) => {
              let r = "function" == typeof t ? t({ count: c, error: e }) : t;
              r && (await (0, i.u)(r)), o({ count: c + 1 });
            };
            try {
              let t = await e();
              s(t);
            } catch (e) {
              if (c < r && (await n({ count: c, error: e })))
                return l({ error: e });
              a(e);
            }
          };
          o();
        });
      }
    },
    42264: (e, t, r) => {
      "use strict";
      r.d(t, {
        A7: () => n,
        BG: () => a,
        Fo: () => p,
        K0: () => c,
        Oh: () => l,
        RM: () => m,
        jj: () => o,
        k5: () => d,
        lN: () => g,
        lY: () => h,
        uC: () => f,
        vW: () => u,
      });
      var i = r(31942),
        s = r(7441);
      class n extends s.C {
        constructor({ cause: e, message: t } = {}) {
          let r = t
            ?.replace("execution reverted: ", "")
            ?.replace("execution reverted", "");
          super(
            `Execution reverted ${
              r ? `with reason: ${r}` : "for an unknown reason"
            }.`,
            { cause: e, name: "ExecutionRevertedError" }
          );
        }
      }
      Object.defineProperty(n, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 3,
      }),
        Object.defineProperty(n, "nodeMessage", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: /execution reverted/,
        });
      class a extends s.C {
        constructor({ cause: e, maxFeePerGas: t } = {}) {
          super(
            `The fee cap (\`maxFeePerGas\`${
              t ? ` = ${(0, i.Q)(t)} gwei` : ""
            }) cannot be higher than the maximum allowed value (2^256-1).`,
            { cause: e, name: "FeeCapTooHighError" }
          );
        }
      }
      Object.defineProperty(a, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value:
          /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/,
      });
      class o extends s.C {
        constructor({ cause: e, maxFeePerGas: t } = {}) {
          super(
            `The fee cap (\`maxFeePerGas\`${
              t ? ` = ${(0, i.Q)(t)}` : ""
            } gwei) cannot be lower than the block base fee.`,
            { cause: e, name: "FeeCapTooLowError" }
          );
        }
      }
      Object.defineProperty(o, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value:
          /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/,
      });
      class c extends s.C {
        constructor({ cause: e, nonce: t } = {}) {
          super(
            `Nonce provided for the transaction ${
              t ? `(${t}) ` : ""
            }is higher than the next one expected.`,
            { cause: e, name: "NonceTooHighError" }
          );
        }
      }
      Object.defineProperty(c, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /nonce too high/,
      });
      class l extends s.C {
        constructor({ cause: e, nonce: t } = {}) {
          super(
            `Nonce provided for the transaction ${
              t ? `(${t}) ` : ""
            }is lower than the current nonce of the account.
Try increasing the nonce or find the latest nonce with \`getTransactionCount\`.`,
            { cause: e, name: "NonceTooLowError" }
          );
        }
      }
      Object.defineProperty(l, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /nonce too low|transaction already imported|already known/,
      });
      class u extends s.C {
        constructor({ cause: e, nonce: t } = {}) {
          super(
            `Nonce provided for the transaction ${
              t ? `(${t}) ` : ""
            }exceeds the maximum allowed nonce.`,
            { cause: e, name: "NonceMaxValueError" }
          );
        }
      }
      Object.defineProperty(u, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /nonce has max value/,
      });
      class d extends s.C {
        constructor({ cause: e } = {}) {
          super(
            "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.",
            {
              cause: e,
              metaMessages: [
                "This error could arise when the account does not have enough funds to:",
                " - pay for the total gas fee,",
                " - pay for the value to send.",
                " ",
                "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
                " - `gas` is the amount of gas needed for transaction to execute,",
                " - `gas fee` is the gas fee,",
                " - `value` is the amount of ether to send to the recipient.",
              ],
              name: "InsufficientFundsError",
            }
          );
        }
      }
      Object.defineProperty(d, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /insufficient funds|exceeds transaction sender account balance/,
      });
      class h extends s.C {
        constructor({ cause: e, gas: t } = {}) {
          super(
            `The amount of gas ${
              t ? `(${t}) ` : ""
            }provided for the transaction exceeds the limit allowed for the block.`,
            { cause: e, name: "IntrinsicGasTooHighError" }
          );
        }
      }
      Object.defineProperty(h, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /intrinsic gas too high|gas limit reached/,
      });
      class p extends s.C {
        constructor({ cause: e, gas: t } = {}) {
          super(
            `The amount of gas ${
              t ? `(${t}) ` : ""
            }provided for the transaction is too low.`,
            { cause: e, name: "IntrinsicGasTooLowError" }
          );
        }
      }
      Object.defineProperty(p, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /intrinsic gas too low/,
      });
      class f extends s.C {
        constructor({ cause: e }) {
          super("The transaction type is not supported for this chain.", {
            cause: e,
            name: "TransactionTypeNotSupportedError",
          });
        }
      }
      Object.defineProperty(f, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /transaction type not valid/,
      });
      class g extends s.C {
        constructor({
          cause: e,
          maxPriorityFeePerGas: t,
          maxFeePerGas: r,
        } = {}) {
          super(
            `The provided tip (\`maxPriorityFeePerGas\`${
              t ? ` = ${(0, i.Q)(t)} gwei` : ""
            }) cannot be higher than the fee cap (\`maxFeePerGas\`${
              r ? ` = ${(0, i.Q)(r)} gwei` : ""
            }).`,
            { cause: e, name: "TipAboveFeeCapError" }
          );
        }
      }
      Object.defineProperty(g, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value:
          /max priority fee per gas higher than max fee per gas|tip higher than fee cap/,
      });
      class m extends s.C {
        constructor({ cause: e }) {
          super(`An error occurred while executing: ${e?.shortMessage}`, {
            cause: e,
            name: "UnknownNodeError",
          });
        }
      }
    },
    42552: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => i });
      let i = (function (e) {
        if (e.length >= 255) throw TypeError("Alphabet too long");
        let t = new Uint8Array(256);
        for (let e = 0; e < t.length; e++) t[e] = 255;
        for (let r = 0; r < e.length; r++) {
          let i = e.charAt(r),
            s = i.charCodeAt(0);
          if (255 !== t[s]) throw TypeError(i + " is ambiguous");
          t[s] = r;
        }
        let r = e.length,
          i = e.charAt(0),
          s = Math.log(r) / Math.log(256),
          n = Math.log(256) / Math.log(r);
        function a(e) {
          if ("string" != typeof e) throw TypeError("Expected String");
          if (0 === e.length) return new Uint8Array();
          let n = 0,
            a = 0,
            o = 0;
          for (; e[n] === i; ) a++, n++;
          let c = ((e.length - n) * s + 1) >>> 0,
            l = new Uint8Array(c);
          for (; n < e.length; ) {
            let i = e.charCodeAt(n);
            if (i > 255) return;
            let s = t[i];
            if (255 === s) return;
            let a = 0;
            for (let e = c - 1; (0 !== s || a < o) && -1 !== e; e--, a++)
              (s += (r * l[e]) >>> 0),
                (l[e] = s % 256 >>> 0),
                (s = (s / 256) >>> 0);
            if (0 !== s) throw Error("Non-zero carry");
            (o = a), n++;
          }
          let u = c - o;
          for (; u !== c && 0 === l[u]; ) u++;
          let d = new Uint8Array(a + (c - u)),
            h = a;
          for (; u !== c; ) d[h++] = l[u++];
          return d;
        }
        return {
          encode: function (t) {
            if (
              (t instanceof Uint8Array ||
                (ArrayBuffer.isView(t)
                  ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                  : Array.isArray(t) && (t = Uint8Array.from(t))),
              !(t instanceof Uint8Array))
            )
              throw TypeError("Expected Uint8Array");
            if (0 === t.length) return "";
            let s = 0,
              a = 0,
              o = 0,
              c = t.length;
            for (; o !== c && 0 === t[o]; ) o++, s++;
            let l = ((c - o) * n + 1) >>> 0,
              u = new Uint8Array(l);
            for (; o !== c; ) {
              let e = t[o],
                i = 0;
              for (let t = l - 1; (0 !== e || i < a) && -1 !== t; t--, i++)
                (e += (256 * u[t]) >>> 0),
                  (u[t] = e % r >>> 0),
                  (e = (e / r) >>> 0);
              if (0 !== e) throw Error("Non-zero carry");
              (a = i), o++;
            }
            let d = l - a;
            for (; d !== l && 0 === u[d]; ) d++;
            let h = i.repeat(s);
            for (; d < l; ++d) h += e.charAt(u[d]);
            return h;
          },
          decodeUnsafe: a,
          decode: function (e) {
            let t = a(e);
            if (t) return t;
            throw Error("Non-base" + r + " character");
          },
        };
      })("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    },
    43359: (e, t, r) => {
      "use strict";
      async function i(...e) {
        let t = await fetch(...e);
        if (!t.ok) throw Error(`HTTP status code: ${t.status}`, { cause: t });
        return t;
      }
      r.d(t, { Z: () => s });
      class s {
        constructor({ baseUrl: e, clientId: t }) {
          (this.baseUrl = e), (this.clientId = t);
        }
        async get({ headers: e, signal: t, cache: r, ...s }) {
          let n = this.createUrl(s);
          return (
            await i(n, { method: "GET", headers: e, signal: t, cache: r })
          ).json();
        }
        async getBlob({ headers: e, signal: t, ...r }) {
          let s = this.createUrl(r);
          return (await i(s, { method: "GET", headers: e, signal: t })).blob();
        }
        async post({ body: e, headers: t, signal: r, ...s }) {
          let n = this.createUrl(s);
          return (
            await i(n, {
              method: "POST",
              headers: t,
              body: e ? JSON.stringify(e) : void 0,
              signal: r,
            })
          ).json();
        }
        async put({ body: e, headers: t, signal: r, ...s }) {
          let n = this.createUrl(s);
          return (
            await i(n, {
              method: "PUT",
              headers: t,
              body: e ? JSON.stringify(e) : void 0,
              signal: r,
            })
          ).json();
        }
        async delete({ body: e, headers: t, signal: r, ...s }) {
          let n = this.createUrl(s);
          return (
            await i(n, {
              method: "DELETE",
              headers: t,
              body: e ? JSON.stringify(e) : void 0,
              signal: r,
            })
          ).json();
        }
        createUrl({ path: e, params: t }) {
          let r = new URL(e, this.baseUrl);
          return (
            t &&
              Object.entries(t).forEach(([e, t]) => {
                t && r.searchParams.append(e, t);
              }),
            this.clientId && r.searchParams.append("clientId", this.clientId),
            r
          );
        }
      }
    },
    43520: (e, t, r) => {
      "use strict";
      r.d(t, { aG: () => y });
      var i = r(43708),
        s = r(70799),
        n = r(60500),
        a = r(76610),
        o = r(92555),
        c = r(11076),
        l = r(65819),
        u = r(11501),
        d = r(90906),
        h = r(96641);
      let p = {
          id: "2b92315d-eab7-5bef-84fa-089a131333f5",
          name: "USD Coin",
          symbol: "USDC",
          networks: [
            {
              name: "ethereum-mainnet",
              display_name: "Ethereum",
              chain_id: "1",
              contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
            },
            {
              name: "polygon-mainnet",
              display_name: "Polygon",
              chain_id: "137",
              contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
            },
          ],
        },
        f = {
          id: "USD",
          payment_method_limits: [
            { id: "card", min: "10.00", max: "7500.00" },
            { id: "ach_bank_account", min: "10.00", max: "25000.00" },
          ],
        },
        g = {
          providers: a.tM,
          selectedProvider: null,
          error: null,
          purchaseCurrency: p,
          paymentCurrency: f,
          purchaseCurrencies: [p],
          paymentCurrencies: [],
          quotesLoading: !1,
        },
        m = (0, i.BX)(g),
        y = (0, o.X)({
          state: m,
          subscribe: (e) => (0, i.B1)(m, () => e(m)),
          subscribeKey: (e, t) => (0, s.u$)(m, e, t),
          setSelectedProvider(e) {
            if (e && "meld" === e.name) {
              let t =
                  d.W.state.activeChain === n.o.CHAIN.SOLANA ? "SOL" : "USDC",
                r = c.U.state.address ?? "",
                i = new URL(e.url);
              i.searchParams.append("publicKey", a.Db),
                i.searchParams.append("destinationCurrencyCode", t),
                i.searchParams.append("walletAddress", r),
                i.searchParams.append(
                  "externalCustomerId",
                  h.H.state.projectId
                ),
                (m.selectedProvider = { ...e, url: i.toString() });
            } else m.selectedProvider = e;
          },
          setOnrampProviders(e) {
            Array.isArray(e) && e.every((e) => "string" == typeof e)
              ? (m.providers = a.tM.filter((t) => e.includes(t.name)))
              : (m.providers = []);
          },
          setPurchaseCurrency(e) {
            m.purchaseCurrency = e;
          },
          setPaymentCurrency(e) {
            m.paymentCurrency = e;
          },
          setPurchaseAmount(e) {
            y.state.purchaseAmount = e;
          },
          setPaymentAmount(e) {
            y.state.paymentAmount = e;
          },
          async getAvailableCurrencies() {
            let e = await u.T.getOnrampOptions();
            (m.purchaseCurrencies = e.purchaseCurrencies),
              (m.paymentCurrencies = e.paymentCurrencies),
              (m.paymentCurrency = e.paymentCurrencies[0] || f),
              (m.purchaseCurrency = e.purchaseCurrencies[0] || p),
              await l.N.fetchCurrencyImages(
                e.paymentCurrencies.map((e) => e.id)
              ),
              await l.N.fetchTokenImages(
                e.purchaseCurrencies.map((e) => e.symbol)
              );
          },
          async getQuote() {
            m.quotesLoading = !0;
            try {
              let e = await u.T.getOnrampQuote({
                purchaseCurrency: m.purchaseCurrency,
                paymentCurrency: m.paymentCurrency,
                amount: m.paymentAmount?.toString() || "0",
                network: m.purchaseCurrency?.symbol,
              });
              return (
                (m.quotesLoading = !1),
                (m.purchaseAmount = Number(e?.purchaseAmount.amount)),
                e
              );
            } catch (e) {
              return (m.error = e.message), (m.quotesLoading = !1), null;
            } finally {
              m.quotesLoading = !1;
            }
          },
          resetState() {
            (m.selectedProvider = null),
              (m.error = null),
              (m.purchaseCurrency = p),
              (m.paymentCurrency = f),
              (m.purchaseCurrencies = [p]),
              (m.paymentCurrencies = []),
              (m.paymentAmount = void 0),
              (m.purchaseAmount = void 0),
              (m.quotesLoading = !1);
          },
        });
    },
    43708: (e, t, r) => {
      "use strict";
      r.d(t, { BX: () => p, KR: () => m, P9: () => g, B1: () => f }), Symbol();
      let i = Symbol(),
        s = Object.getPrototypeOf,
        n = new WeakMap(),
        a = (e) =>
          e &&
          (n.has(e)
            ? n.get(e)
            : s(e) === Object.prototype || s(e) === Array.prototype),
        o = (e) => (a(e) && e[i]) || null,
        c = (e, t = !0) => {
          n.set(e, t);
        },
        l = (e) => "object" == typeof e && null !== e,
        u = new WeakMap(),
        d = new WeakSet(),
        [h] = ((
          e = Object.is,
          t = (e, t) => new Proxy(e, t),
          r = (e) =>
            l(e) &&
            !d.has(e) &&
            (Array.isArray(e) || !(Symbol.iterator in e)) &&
            !(e instanceof WeakMap) &&
            !(e instanceof WeakSet) &&
            !(e instanceof Error) &&
            !(e instanceof Number) &&
            !(e instanceof Date) &&
            !(e instanceof String) &&
            !(e instanceof RegExp) &&
            !(e instanceof ArrayBuffer),
          i = (e) => {
            switch (e.status) {
              case "fulfilled":
                return e.value;
              case "rejected":
                throw e.reason;
              default:
                throw e;
            }
          },
          s = new WeakMap(),
          n = (e, t, r = i) => {
            let a = s.get(e);
            if ((null == a ? void 0 : a[0]) === t) return a[1];
            let o = Array.isArray(e)
              ? []
              : Object.create(Object.getPrototypeOf(e));
            return (
              c(o, !0),
              s.set(e, [t, o]),
              Reflect.ownKeys(e).forEach((t) => {
                if (Object.getOwnPropertyDescriptor(o, t)) return;
                let i = Reflect.get(e, t),
                  { enumerable: s } = Reflect.getOwnPropertyDescriptor(e, t),
                  a = { value: i, enumerable: s, configurable: !0 };
                if (d.has(i)) c(i, !1);
                else if (i instanceof Promise)
                  delete a.value, (a.get = () => r(i));
                else if (u.has(i)) {
                  let [e, t] = u.get(i);
                  a.value = n(e, t(), r);
                }
                Object.defineProperty(o, t, a);
              }),
              Object.preventExtensions(o)
            );
          },
          a = new WeakMap(),
          h = [1, 1],
          p = (i) => {
            if (!l(i)) throw Error("object required");
            let s = a.get(i);
            if (s) return s;
            let c = h[0],
              f = new Set(),
              g = (e, t = ++h[0]) => {
                c !== t && ((c = t), f.forEach((r) => r(e, t)));
              },
              m = h[1],
              y = (e = ++h[1]) => (
                m === e ||
                  f.size ||
                  ((m = e),
                  w.forEach(([t]) => {
                    let r = t[1](e);
                    r > c && (c = r);
                  })),
                c
              ),
              b = (e) => (t, r) => {
                let i = [...t];
                (i[1] = [e, ...i[1]]), g(i, r);
              },
              w = new Map(),
              v = (e, t) => {
                if (w.has(e)) throw Error("prop listener already exists");
                if (f.size) {
                  let r = t[3](b(e));
                  w.set(e, [t, r]);
                } else w.set(e, [t]);
              },
              E = (e) => {
                var t;
                let r = w.get(e);
                r && (w.delete(e), null == (t = r[1]) || t.call(r));
              },
              _ = (e) => {
                f.add(e),
                  1 === f.size &&
                    w.forEach(([e, t], r) => {
                      if (t) throw Error("remove already exists");
                      let i = e[3](b(r));
                      w.set(r, [e, i]);
                    });
                let t = () => {
                  f.delete(e),
                    0 === f.size &&
                      w.forEach(([e, t], r) => {
                        t && (t(), w.set(r, [e]));
                      });
                };
                return t;
              },
              C = Array.isArray(i)
                ? []
                : Object.create(Object.getPrototypeOf(i)),
              A = {
                deleteProperty(e, t) {
                  let r = Reflect.get(e, t);
                  E(t);
                  let i = Reflect.deleteProperty(e, t);
                  return i && g(["delete", [t], r]), i;
                },
                set(t, i, s, n) {
                  let c = Reflect.has(t, i),
                    h = Reflect.get(t, i, n);
                  if (c && (e(h, s) || (a.has(s) && e(h, a.get(s))))) return !0;
                  E(i), l(s) && (s = o(s) || s);
                  let f = s;
                  if (s instanceof Promise)
                    s.then((e) => {
                      (s.status = "fulfilled"),
                        (s.value = e),
                        g(["resolve", [i], e]);
                    }).catch((e) => {
                      (s.status = "rejected"),
                        (s.reason = e),
                        g(["reject", [i], e]);
                    });
                  else {
                    !u.has(s) && r(s) && (f = p(s));
                    let e = !d.has(f) && u.get(f);
                    e && v(i, e);
                  }
                  return Reflect.set(t, i, f, n), g(["set", [i], s, h]), !0;
                },
              },
              I = t(C, A);
            a.set(i, I);
            let S = [C, y, n, _];
            return (
              u.set(I, S),
              Reflect.ownKeys(i).forEach((e) => {
                let t = Object.getOwnPropertyDescriptor(i, e);
                "value" in t &&
                  ((I[e] = i[e]), delete t.value, delete t.writable),
                  Object.defineProperty(C, e, t);
              }),
              I
            );
          }
        ) => [p, u, d, e, t, r, i, s, n, a, h])();
      function p(e = {}) {
        return h(e);
      }
      function f(e, t, r) {
        let i,
          s = u.get(e);
        s || console.warn("Please use proxy object");
        let n = [],
          a = s[3],
          o = !1,
          c = a((e) => {
            if ((n.push(e), r)) return void t(n.splice(0));
            i ||
              (i = Promise.resolve().then(() => {
                (i = void 0), o && t(n.splice(0));
              }));
          });
        return (
          (o = !0),
          () => {
            (o = !1), c();
          }
        );
      }
      function g(e, t) {
        let r = u.get(e);
        r || console.warn("Please use proxy object");
        let [i, s, n] = r;
        return n(i, s(), t);
      }
      function m(e) {
        return d.add(e), e;
      }
    },
    44134: (e, t, r) => {
      "use strict";
      let i = r(57719),
        s = r(7610),
        n =
          "function" == typeof Symbol && "function" == typeof Symbol.for
            ? Symbol.for("nodejs.util.inspect.custom")
            : null;
      function a(e) {
        if (e > 0x7fffffff)
          throw RangeError(
            'The value "' + e + '" is invalid for option "size"'
          );
        let t = new Uint8Array(e);
        return Object.setPrototypeOf(t, o.prototype), t;
      }
      function o(e, t, r) {
        if ("number" == typeof e) {
          if ("string" == typeof t)
            throw TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          return u(e);
        }
        return c(e, t, r);
      }
      function c(e, t, r) {
        if ("string" == typeof e) {
          var i = e,
            s = t;
          if (
            (("string" != typeof s || "" === s) && (s = "utf8"),
            !o.isEncoding(s))
          )
            throw TypeError("Unknown encoding: " + s);
          let r = 0 | f(i, s),
            n = a(r),
            c = n.write(i, s);
          return c !== r && (n = n.slice(0, c)), n;
        }
        if (ArrayBuffer.isView(e)) {
          var n = e;
          if (M(n, Uint8Array)) {
            let e = new Uint8Array(n);
            return h(e.buffer, e.byteOffset, e.byteLength);
          }
          return d(n);
        }
        if (null == e)
          throw TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
              typeof e
          );
        if (
          M(e, ArrayBuffer) ||
          (e && M(e.buffer, ArrayBuffer)) ||
          ("undefined" != typeof SharedArrayBuffer &&
            (M(e, SharedArrayBuffer) || (e && M(e.buffer, SharedArrayBuffer))))
        )
          return h(e, t, r);
        if ("number" == typeof e)
          throw TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        let c = e.valueOf && e.valueOf();
        if (null != c && c !== e) return o.from(c, t, r);
        let l = (function (e) {
          if (o.isBuffer(e)) {
            let t = 0 | p(e.length),
              r = a(t);
            return 0 === r.length || e.copy(r, 0, 0, t), r;
          }
          return void 0 !== e.length
            ? "number" != typeof e.length ||
              (function (e) {
                return e != e;
              })(e.length)
              ? a(0)
              : d(e)
            : "Buffer" === e.type && Array.isArray(e.data)
            ? d(e.data)
            : void 0;
        })(e);
        if (l) return l;
        if (
          "undefined" != typeof Symbol &&
          null != Symbol.toPrimitive &&
          "function" == typeof e[Symbol.toPrimitive]
        )
          return o.from(e[Symbol.toPrimitive]("string"), t, r);
        throw TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
            typeof e
        );
      }
      function l(e) {
        if ("number" != typeof e)
          throw TypeError('"size" argument must be of type number');
        if (e < 0)
          throw RangeError(
            'The value "' + e + '" is invalid for option "size"'
          );
      }
      function u(e) {
        return l(e), a(e < 0 ? 0 : 0 | p(e));
      }
      function d(e) {
        let t = e.length < 0 ? 0 : 0 | p(e.length),
          r = a(t);
        for (let i = 0; i < t; i += 1) r[i] = 255 & e[i];
        return r;
      }
      function h(e, t, r) {
        let i;
        if (t < 0 || e.byteLength < t)
          throw RangeError('"offset" is outside of buffer bounds');
        if (e.byteLength < t + (r || 0))
          throw RangeError('"length" is outside of buffer bounds');
        return (
          Object.setPrototypeOf(
            (i =
              void 0 === t && void 0 === r
                ? new Uint8Array(e)
                : void 0 === r
                ? new Uint8Array(e, t)
                : new Uint8Array(e, t, r)),
            o.prototype
          ),
          i
        );
      }
      function p(e) {
        if (e >= 0x7fffffff)
          throw RangeError(
            "Attempt to allocate Buffer larger than maximum size: 0x7fffffff bytes"
          );
        return 0 | e;
      }
      function f(e, t) {
        if (o.isBuffer(e)) return e.length;
        if (ArrayBuffer.isView(e) || M(e, ArrayBuffer)) return e.byteLength;
        if ("string" != typeof e)
          throw TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
              typeof e
          );
        let r = e.length,
          i = arguments.length > 2 && !0 === arguments[2];
        if (!i && 0 === r) return 0;
        let s = !1;
        for (;;)
          switch (t) {
            case "ascii":
            case "latin1":
            case "binary":
              return r;
            case "utf8":
            case "utf-8":
              return D(e).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * r;
            case "hex":
              return r >>> 1;
            case "base64":
              return U(e).length;
            default:
              if (s) return i ? -1 : D(e).length;
              (t = ("" + t).toLowerCase()), (s = !0);
          }
      }
      function g(e, t, r) {
        let s = !1;
        if (
          ((void 0 === t || t < 0) && (t = 0),
          t > this.length ||
            ((void 0 === r || r > this.length) && (r = this.length),
            r <= 0 || (r >>>= 0) <= (t >>>= 0)))
        )
          return "";
        for (e || (e = "utf8"); ; )
          switch (e) {
            case "hex":
              return (function (e, t, r) {
                let i = e.length;
                (!t || t < 0) && (t = 0), (!r || r < 0 || r > i) && (r = i);
                let s = "";
                for (let i = t; i < r; ++i) s += j[e[i]];
                return s;
              })(this, t, r);
            case "utf8":
            case "utf-8":
              return w(this, t, r);
            case "ascii":
              return (function (e, t, r) {
                let i = "";
                r = Math.min(e.length, r);
                for (let s = t; s < r; ++s)
                  i += String.fromCharCode(127 & e[s]);
                return i;
              })(this, t, r);
            case "latin1":
            case "binary":
              return (function (e, t, r) {
                let i = "";
                r = Math.min(e.length, r);
                for (let s = t; s < r; ++s) i += String.fromCharCode(e[s]);
                return i;
              })(this, t, r);
            case "base64":
              var n, a, o;
              return (
                (n = this),
                (a = t),
                (o = r),
                0 === a && o === n.length
                  ? i.fromByteArray(n)
                  : i.fromByteArray(n.slice(a, o))
              );
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return (function (e, t, r) {
                let i = e.slice(t, r),
                  s = "";
                for (let e = 0; e < i.length - 1; e += 2)
                  s += String.fromCharCode(i[e] + 256 * i[e + 1]);
                return s;
              })(this, t, r);
            default:
              if (s) throw TypeError("Unknown encoding: " + e);
              (e = (e + "").toLowerCase()), (s = !0);
          }
      }
      function m(e, t, r) {
        let i = e[t];
        (e[t] = e[r]), (e[r] = i);
      }
      function y(e, t, r, i, s) {
        var n;
        if (0 === e.length) return -1;
        if (
          ("string" == typeof r
            ? ((i = r), (r = 0))
            : r > 0x7fffffff
            ? (r = 0x7fffffff)
            : r < -0x80000000 && (r = -0x80000000),
          (n = r *= 1) != n && (r = s ? 0 : e.length - 1),
          r < 0 && (r = e.length + r),
          r >= e.length)
        )
          if (s) return -1;
          else r = e.length - 1;
        else if (r < 0)
          if (!s) return -1;
          else r = 0;
        if (("string" == typeof t && (t = o.from(t, i)), o.isBuffer(t)))
          return 0 === t.length ? -1 : b(e, t, r, i, s);
        if ("number" == typeof t) {
          if (((t &= 255), "function" == typeof Uint8Array.prototype.indexOf))
            if (s) return Uint8Array.prototype.indexOf.call(e, t, r);
            else return Uint8Array.prototype.lastIndexOf.call(e, t, r);
          return b(e, [t], r, i, s);
        }
        throw TypeError("val must be string, number or Buffer");
      }
      function b(e, t, r, i, s) {
        let n,
          a = 1,
          o = e.length,
          c = t.length;
        if (
          void 0 !== i &&
          ("ucs2" === (i = String(i).toLowerCase()) ||
            "ucs-2" === i ||
            "utf16le" === i ||
            "utf-16le" === i)
        ) {
          if (e.length < 2 || t.length < 2) return -1;
          (a = 2), (o /= 2), (c /= 2), (r /= 2);
        }
        function l(e, t) {
          return 1 === a ? e[t] : e.readUInt16BE(t * a);
        }
        if (s) {
          let i = -1;
          for (n = r; n < o; n++)
            if (l(e, n) === l(t, -1 === i ? 0 : n - i)) {
              if ((-1 === i && (i = n), n - i + 1 === c)) return i * a;
            } else -1 !== i && (n -= n - i), (i = -1);
        } else
          for (r + c > o && (r = o - c), n = r; n >= 0; n--) {
            let r = !0;
            for (let i = 0; i < c; i++)
              if (l(e, n + i) !== l(t, i)) {
                r = !1;
                break;
              }
            if (r) return n;
          }
        return -1;
      }
      function w(e, t, r) {
        r = Math.min(e.length, r);
        let i = [],
          s = t;
        for (; s < r; ) {
          let t = e[s],
            n = null,
            a = t > 239 ? 4 : t > 223 ? 3 : t > 191 ? 2 : 1;
          if (s + a <= r) {
            let r, i, o, c;
            switch (a) {
              case 1:
                t < 128 && (n = t);
                break;
              case 2:
                (192 & (r = e[s + 1])) == 128 &&
                  (c = ((31 & t) << 6) | (63 & r)) > 127 &&
                  (n = c);
                break;
              case 3:
                (r = e[s + 1]),
                  (i = e[s + 2]),
                  (192 & r) == 128 &&
                    (192 & i) == 128 &&
                    (c = ((15 & t) << 12) | ((63 & r) << 6) | (63 & i)) >
                      2047 &&
                    (c < 55296 || c > 57343) &&
                    (n = c);
                break;
              case 4:
                (r = e[s + 1]),
                  (i = e[s + 2]),
                  (o = e[s + 3]),
                  (192 & r) == 128 &&
                    (192 & i) == 128 &&
                    (192 & o) == 128 &&
                    (c =
                      ((15 & t) << 18) |
                      ((63 & r) << 12) |
                      ((63 & i) << 6) |
                      (63 & o)) > 65535 &&
                    c < 1114112 &&
                    (n = c);
            }
          }
          null === n
            ? ((n = 65533), (a = 1))
            : n > 65535 &&
              ((n -= 65536),
              i.push(((n >>> 10) & 1023) | 55296),
              (n = 56320 | (1023 & n))),
            i.push(n),
            (s += a);
        }
        var n = i;
        let a = n.length;
        if (a <= 4096) return String.fromCharCode.apply(String, n);
        let o = "",
          c = 0;
        for (; c < a; )
          o += String.fromCharCode.apply(String, n.slice(c, (c += 4096)));
        return o;
      }
      function v(e, t, r) {
        if (e % 1 != 0 || e < 0) throw RangeError("offset is not uint");
        if (e + t > r)
          throw RangeError("Trying to access beyond buffer length");
      }
      function E(e, t, r, i, s, n) {
        if (!o.isBuffer(e))
          throw TypeError('"buffer" argument must be a Buffer instance');
        if (t > s || t < n)
          throw RangeError('"value" argument is out of bounds');
        if (r + i > e.length) throw RangeError("Index out of range");
      }
      function _(e, t, r, i, s) {
        x(t, i, s, e, r, 7);
        let n = Number(t & BigInt(0xffffffff));
        (e[r++] = n),
          (n >>= 8),
          (e[r++] = n),
          (n >>= 8),
          (e[r++] = n),
          (n >>= 8),
          (e[r++] = n);
        let a = Number((t >> BigInt(32)) & BigInt(0xffffffff));
        return (
          (e[r++] = a),
          (a >>= 8),
          (e[r++] = a),
          (a >>= 8),
          (e[r++] = a),
          (a >>= 8),
          (e[r++] = a),
          r
        );
      }
      function C(e, t, r, i, s) {
        x(t, i, s, e, r, 7);
        let n = Number(t & BigInt(0xffffffff));
        (e[r + 7] = n),
          (n >>= 8),
          (e[r + 6] = n),
          (n >>= 8),
          (e[r + 5] = n),
          (n >>= 8),
          (e[r + 4] = n);
        let a = Number((t >> BigInt(32)) & BigInt(0xffffffff));
        return (
          (e[r + 3] = a),
          (a >>= 8),
          (e[r + 2] = a),
          (a >>= 8),
          (e[r + 1] = a),
          (a >>= 8),
          (e[r] = a),
          r + 8
        );
      }
      function A(e, t, r, i, s, n) {
        if (r + i > e.length || r < 0) throw RangeError("Index out of range");
      }
      function I(e, t, r, i, n) {
        return (
          (t *= 1),
          (r >>>= 0),
          n || A(e, t, r, 4, 34028234663852886e22, -34028234663852886e22),
          s.write(e, t, r, i, 23, 4),
          r + 4
        );
      }
      function S(e, t, r, i, n) {
        return (
          (t *= 1),
          (r >>>= 0),
          n || A(e, t, r, 8, 17976931348623157e292, -17976931348623157e292),
          s.write(e, t, r, i, 52, 8),
          r + 8
        );
      }
      (t.Buffer = o),
        (t.SlowBuffer = function (e) {
          return +e != e && (e = 0), o.alloc(+e);
        }),
        (t.INSPECT_MAX_BYTES = 50),
        (t.kMaxLength = 0x7fffffff),
        (o.TYPED_ARRAY_SUPPORT = (function () {
          try {
            let e = new Uint8Array(1),
              t = {
                foo: function () {
                  return 42;
                },
              };
            return (
              Object.setPrototypeOf(t, Uint8Array.prototype),
              Object.setPrototypeOf(e, t),
              42 === e.foo()
            );
          } catch (e) {
            return !1;
          }
        })()),
        o.TYPED_ARRAY_SUPPORT ||
          "undefined" == typeof console ||
          "function" != typeof console.error ||
          console.error(
            "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
          ),
        Object.defineProperty(o.prototype, "parent", {
          enumerable: !0,
          get: function () {
            if (o.isBuffer(this)) return this.buffer;
          },
        }),
        Object.defineProperty(o.prototype, "offset", {
          enumerable: !0,
          get: function () {
            if (o.isBuffer(this)) return this.byteOffset;
          },
        }),
        (o.poolSize = 8192),
        (o.from = function (e, t, r) {
          return c(e, t, r);
        }),
        Object.setPrototypeOf(o.prototype, Uint8Array.prototype),
        Object.setPrototypeOf(o, Uint8Array),
        (o.alloc = function (e, t, r) {
          return (l(e), e <= 0)
            ? a(e)
            : void 0 !== t
            ? "string" == typeof r
              ? a(e).fill(t, r)
              : a(e).fill(t)
            : a(e);
        }),
        (o.allocUnsafe = function (e) {
          return u(e);
        }),
        (o.allocUnsafeSlow = function (e) {
          return u(e);
        }),
        (o.isBuffer = function (e) {
          return null != e && !0 === e._isBuffer && e !== o.prototype;
        }),
        (o.compare = function (e, t) {
          if (
            (M(e, Uint8Array) && (e = o.from(e, e.offset, e.byteLength)),
            M(t, Uint8Array) && (t = o.from(t, t.offset, t.byteLength)),
            !o.isBuffer(e) || !o.isBuffer(t))
          )
            throw TypeError(
              'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
            );
          if (e === t) return 0;
          let r = e.length,
            i = t.length;
          for (let s = 0, n = Math.min(r, i); s < n; ++s)
            if (e[s] !== t[s]) {
              (r = e[s]), (i = t[s]);
              break;
            }
          return r < i ? -1 : +(i < r);
        }),
        (o.isEncoding = function (e) {
          switch (String(e).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1;
          }
        }),
        (o.concat = function (e, t) {
          let r;
          if (!Array.isArray(e))
            throw TypeError('"list" argument must be an Array of Buffers');
          if (0 === e.length) return o.alloc(0);
          if (void 0 === t)
            for (r = 0, t = 0; r < e.length; ++r) t += e[r].length;
          let i = o.allocUnsafe(t),
            s = 0;
          for (r = 0; r < e.length; ++r) {
            let t = e[r];
            if (M(t, Uint8Array))
              s + t.length > i.length
                ? (o.isBuffer(t) || (t = o.from(t)), t.copy(i, s))
                : Uint8Array.prototype.set.call(i, t, s);
            else if (o.isBuffer(t)) t.copy(i, s);
            else throw TypeError('"list" argument must be an Array of Buffers');
            s += t.length;
          }
          return i;
        }),
        (o.byteLength = f),
        (o.prototype._isBuffer = !0),
        (o.prototype.swap16 = function () {
          let e = this.length;
          if (e % 2 != 0)
            throw RangeError("Buffer size must be a multiple of 16-bits");
          for (let t = 0; t < e; t += 2) m(this, t, t + 1);
          return this;
        }),
        (o.prototype.swap32 = function () {
          let e = this.length;
          if (e % 4 != 0)
            throw RangeError("Buffer size must be a multiple of 32-bits");
          for (let t = 0; t < e; t += 4)
            m(this, t, t + 3), m(this, t + 1, t + 2);
          return this;
        }),
        (o.prototype.swap64 = function () {
          let e = this.length;
          if (e % 8 != 0)
            throw RangeError("Buffer size must be a multiple of 64-bits");
          for (let t = 0; t < e; t += 8)
            m(this, t, t + 7),
              m(this, t + 1, t + 6),
              m(this, t + 2, t + 5),
              m(this, t + 3, t + 4);
          return this;
        }),
        (o.prototype.toString = function () {
          let e = this.length;
          return 0 === e
            ? ""
            : 0 == arguments.length
            ? w(this, 0, e)
            : g.apply(this, arguments);
        }),
        (o.prototype.toLocaleString = o.prototype.toString),
        (o.prototype.equals = function (e) {
          if (!o.isBuffer(e)) throw TypeError("Argument must be a Buffer");
          return this === e || 0 === o.compare(this, e);
        }),
        (o.prototype.inspect = function () {
          let e = "",
            r = t.INSPECT_MAX_BYTES;
          return (
            (e = this.toString("hex", 0, r)
              .replace(/(.{2})/g, "$1 ")
              .trim()),
            this.length > r && (e += " ... "),
            "<Buffer " + e + ">"
          );
        }),
        n && (o.prototype[n] = o.prototype.inspect),
        (o.prototype.compare = function (e, t, r, i, s) {
          if (
            (M(e, Uint8Array) && (e = o.from(e, e.offset, e.byteLength)),
            !o.isBuffer(e))
          )
            throw TypeError(
              'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                typeof e
            );
          if (
            (void 0 === t && (t = 0),
            void 0 === r && (r = e ? e.length : 0),
            void 0 === i && (i = 0),
            void 0 === s && (s = this.length),
            t < 0 || r > e.length || i < 0 || s > this.length)
          )
            throw RangeError("out of range index");
          if (i >= s && t >= r) return 0;
          if (i >= s) return -1;
          if (t >= r) return 1;
          if (((t >>>= 0), (r >>>= 0), (i >>>= 0), (s >>>= 0), this === e))
            return 0;
          let n = s - i,
            a = r - t,
            c = Math.min(n, a),
            l = this.slice(i, s),
            u = e.slice(t, r);
          for (let e = 0; e < c; ++e)
            if (l[e] !== u[e]) {
              (n = l[e]), (a = u[e]);
              break;
            }
          return n < a ? -1 : +(a < n);
        }),
        (o.prototype.includes = function (e, t, r) {
          return -1 !== this.indexOf(e, t, r);
        }),
        (o.prototype.indexOf = function (e, t, r) {
          return y(this, e, t, r, !0);
        }),
        (o.prototype.lastIndexOf = function (e, t, r) {
          return y(this, e, t, r, !1);
        }),
        (o.prototype.write = function (e, t, r, i) {
          var s, n, a, o, c, l, u, d;
          if (void 0 === t) (i = "utf8"), (r = this.length), (t = 0);
          else if (void 0 === r && "string" == typeof t)
            (i = t), (r = this.length), (t = 0);
          else if (isFinite(t))
            (t >>>= 0),
              isFinite(r)
                ? ((r >>>= 0), void 0 === i && (i = "utf8"))
                : ((i = r), (r = void 0));
          else
            throw Error(
              "Buffer.write(string, encoding, offset[, length]) is no longer supported"
            );
          let h = this.length - t;
          if (
            ((void 0 === r || r > h) && (r = h),
            (e.length > 0 && (r < 0 || t < 0)) || t > this.length)
          )
            throw RangeError("Attempt to write outside buffer bounds");
          i || (i = "utf8");
          let p = !1;
          for (;;)
            switch (i) {
              case "hex":
                return (function (e, t, r, i) {
                  let s;
                  r = Number(r) || 0;
                  let n = e.length - r;
                  i ? (i = Number(i)) > n && (i = n) : (i = n);
                  let a = t.length;
                  for (i > a / 2 && (i = a / 2), s = 0; s < i; ++s) {
                    var o;
                    let i = parseInt(t.substr(2 * s, 2), 16);
                    if ((o = i) != o) break;
                    e[r + s] = i;
                  }
                  return s;
                })(this, e, t, r);
              case "utf8":
              case "utf-8":
                return (s = t), (n = r), L(D(e, this.length - s), this, s, n);
              case "ascii":
              case "latin1":
              case "binary":
                return (
                  (a = t),
                  (o = r),
                  L(
                    (function (e) {
                      let t = [];
                      for (let r = 0; r < e.length; ++r)
                        t.push(255 & e.charCodeAt(r));
                      return t;
                    })(e),
                    this,
                    a,
                    o
                  )
                );
              case "base64":
                return (c = t), (l = r), L(U(e), this, c, l);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return (
                  (u = t),
                  (d = r),
                  L(
                    (function (e, t) {
                      let r,
                        i,
                        s = [];
                      for (let n = 0; n < e.length && !((t -= 2) < 0); ++n)
                        (i = (r = e.charCodeAt(n)) >> 8),
                          s.push(r % 256),
                          s.push(i);
                      return s;
                    })(e, this.length - u),
                    this,
                    u,
                    d
                  )
                );
              default:
                if (p) throw TypeError("Unknown encoding: " + i);
                (i = ("" + i).toLowerCase()), (p = !0);
            }
        }),
        (o.prototype.toJSON = function () {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0),
          };
        }),
        (o.prototype.slice = function (e, t) {
          let r = this.length;
          (e = ~~e),
            (t = void 0 === t ? r : ~~t),
            e < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r),
            t < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r),
            t < e && (t = e);
          let i = this.subarray(e, t);
          return Object.setPrototypeOf(i, o.prototype), i;
        }),
        (o.prototype.readUintLE = o.prototype.readUIntLE =
          function (e, t, r) {
            (e >>>= 0), (t >>>= 0), r || v(e, t, this.length);
            let i = this[e],
              s = 1,
              n = 0;
            for (; ++n < t && (s *= 256); ) i += this[e + n] * s;
            return i;
          }),
        (o.prototype.readUintBE = o.prototype.readUIntBE =
          function (e, t, r) {
            (e >>>= 0), (t >>>= 0), r || v(e, t, this.length);
            let i = this[e + --t],
              s = 1;
            for (; t > 0 && (s *= 256); ) i += this[e + --t] * s;
            return i;
          }),
        (o.prototype.readUint8 = o.prototype.readUInt8 =
          function (e, t) {
            return (e >>>= 0), t || v(e, 1, this.length), this[e];
          }),
        (o.prototype.readUint16LE = o.prototype.readUInt16LE =
          function (e, t) {
            return (
              (e >>>= 0),
              t || v(e, 2, this.length),
              this[e] | (this[e + 1] << 8)
            );
          }),
        (o.prototype.readUint16BE = o.prototype.readUInt16BE =
          function (e, t) {
            return (
              (e >>>= 0),
              t || v(e, 2, this.length),
              (this[e] << 8) | this[e + 1]
            );
          }),
        (o.prototype.readUint32LE = o.prototype.readUInt32LE =
          function (e, t) {
            return (
              (e >>>= 0),
              t || v(e, 4, this.length),
              (this[e] | (this[e + 1] << 8) | (this[e + 2] << 16)) +
                0x1000000 * this[e + 3]
            );
          }),
        (o.prototype.readUint32BE = o.prototype.readUInt32BE =
          function (e, t) {
            return (
              (e >>>= 0),
              t || v(e, 4, this.length),
              0x1000000 * this[e] +
                ((this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3])
            );
          }),
        (o.prototype.readBigUInt64LE = $(function (e) {
          P((e >>>= 0), "offset");
          let t = this[e],
            r = this[e + 7];
          (void 0 === t || void 0 === r) && R(e, this.length - 8);
          let i =
              t + 256 * this[++e] + 65536 * this[++e] + 0x1000000 * this[++e],
            s = this[++e] + 256 * this[++e] + 65536 * this[++e] + 0x1000000 * r;
          return BigInt(i) + (BigInt(s) << BigInt(32));
        })),
        (o.prototype.readBigUInt64BE = $(function (e) {
          P((e >>>= 0), "offset");
          let t = this[e],
            r = this[e + 7];
          (void 0 === t || void 0 === r) && R(e, this.length - 8);
          let i =
              0x1000000 * t + 65536 * this[++e] + 256 * this[++e] + this[++e],
            s = 0x1000000 * this[++e] + 65536 * this[++e] + 256 * this[++e] + r;
          return (BigInt(i) << BigInt(32)) + BigInt(s);
        })),
        (o.prototype.readIntLE = function (e, t, r) {
          (e >>>= 0), (t >>>= 0), r || v(e, t, this.length);
          let i = this[e],
            s = 1,
            n = 0;
          for (; ++n < t && (s *= 256); ) i += this[e + n] * s;
          return i >= (s *= 128) && (i -= Math.pow(2, 8 * t)), i;
        }),
        (o.prototype.readIntBE = function (e, t, r) {
          (e >>>= 0), (t >>>= 0), r || v(e, t, this.length);
          let i = t,
            s = 1,
            n = this[e + --i];
          for (; i > 0 && (s *= 256); ) n += this[e + --i] * s;
          return n >= (s *= 128) && (n -= Math.pow(2, 8 * t)), n;
        }),
        (o.prototype.readInt8 = function (e, t) {
          return ((e >>>= 0), t || v(e, 1, this.length), 128 & this[e])
            ? -((255 - this[e] + 1) * 1)
            : this[e];
        }),
        (o.prototype.readInt16LE = function (e, t) {
          (e >>>= 0), t || v(e, 2, this.length);
          let r = this[e] | (this[e + 1] << 8);
          return 32768 & r ? 0xffff0000 | r : r;
        }),
        (o.prototype.readInt16BE = function (e, t) {
          (e >>>= 0), t || v(e, 2, this.length);
          let r = this[e + 1] | (this[e] << 8);
          return 32768 & r ? 0xffff0000 | r : r;
        }),
        (o.prototype.readInt32LE = function (e, t) {
          return (
            (e >>>= 0),
            t || v(e, 4, this.length),
            this[e] |
              (this[e + 1] << 8) |
              (this[e + 2] << 16) |
              (this[e + 3] << 24)
          );
        }),
        (o.prototype.readInt32BE = function (e, t) {
          return (
            (e >>>= 0),
            t || v(e, 4, this.length),
            (this[e] << 24) |
              (this[e + 1] << 16) |
              (this[e + 2] << 8) |
              this[e + 3]
          );
        }),
        (o.prototype.readBigInt64LE = $(function (e) {
          P((e >>>= 0), "offset");
          let t = this[e],
            r = this[e + 7];
          return (
            (void 0 === t || void 0 === r) && R(e, this.length - 8),
            (BigInt(
              this[e + 4] + 256 * this[e + 5] + 65536 * this[e + 6] + (r << 24)
            ) <<
              BigInt(32)) +
              BigInt(
                t + 256 * this[++e] + 65536 * this[++e] + 0x1000000 * this[++e]
              )
          );
        })),
        (o.prototype.readBigInt64BE = $(function (e) {
          P((e >>>= 0), "offset");
          let t = this[e],
            r = this[e + 7];
          return (
            (void 0 === t || void 0 === r) && R(e, this.length - 8),
            (BigInt(
              (t << 24) + 65536 * this[++e] + 256 * this[++e] + this[++e]
            ) <<
              BigInt(32)) +
              BigInt(
                0x1000000 * this[++e] + 65536 * this[++e] + 256 * this[++e] + r
              )
          );
        })),
        (o.prototype.readFloatLE = function (e, t) {
          return (
            (e >>>= 0), t || v(e, 4, this.length), s.read(this, e, !0, 23, 4)
          );
        }),
        (o.prototype.readFloatBE = function (e, t) {
          return (
            (e >>>= 0), t || v(e, 4, this.length), s.read(this, e, !1, 23, 4)
          );
        }),
        (o.prototype.readDoubleLE = function (e, t) {
          return (
            (e >>>= 0), t || v(e, 8, this.length), s.read(this, e, !0, 52, 8)
          );
        }),
        (o.prototype.readDoubleBE = function (e, t) {
          return (
            (e >>>= 0), t || v(e, 8, this.length), s.read(this, e, !1, 52, 8)
          );
        }),
        (o.prototype.writeUintLE = o.prototype.writeUIntLE =
          function (e, t, r, i) {
            if (((e *= 1), (t >>>= 0), (r >>>= 0), !i)) {
              let i = Math.pow(2, 8 * r) - 1;
              E(this, e, t, r, i, 0);
            }
            let s = 1,
              n = 0;
            for (this[t] = 255 & e; ++n < r && (s *= 256); )
              this[t + n] = (e / s) & 255;
            return t + r;
          }),
        (o.prototype.writeUintBE = o.prototype.writeUIntBE =
          function (e, t, r, i) {
            if (((e *= 1), (t >>>= 0), (r >>>= 0), !i)) {
              let i = Math.pow(2, 8 * r) - 1;
              E(this, e, t, r, i, 0);
            }
            let s = r - 1,
              n = 1;
            for (this[t + s] = 255 & e; --s >= 0 && (n *= 256); )
              this[t + s] = (e / n) & 255;
            return t + r;
          }),
        (o.prototype.writeUint8 = o.prototype.writeUInt8 =
          function (e, t, r) {
            return (
              (e *= 1),
              (t >>>= 0),
              r || E(this, e, t, 1, 255, 0),
              (this[t] = 255 & e),
              t + 1
            );
          }),
        (o.prototype.writeUint16LE = o.prototype.writeUInt16LE =
          function (e, t, r) {
            return (
              (e *= 1),
              (t >>>= 0),
              r || E(this, e, t, 2, 65535, 0),
              (this[t] = 255 & e),
              (this[t + 1] = e >>> 8),
              t + 2
            );
          }),
        (o.prototype.writeUint16BE = o.prototype.writeUInt16BE =
          function (e, t, r) {
            return (
              (e *= 1),
              (t >>>= 0),
              r || E(this, e, t, 2, 65535, 0),
              (this[t] = e >>> 8),
              (this[t + 1] = 255 & e),
              t + 2
            );
          }),
        (o.prototype.writeUint32LE = o.prototype.writeUInt32LE =
          function (e, t, r) {
            return (
              (e *= 1),
              (t >>>= 0),
              r || E(this, e, t, 4, 0xffffffff, 0),
              (this[t + 3] = e >>> 24),
              (this[t + 2] = e >>> 16),
              (this[t + 1] = e >>> 8),
              (this[t] = 255 & e),
              t + 4
            );
          }),
        (o.prototype.writeUint32BE = o.prototype.writeUInt32BE =
          function (e, t, r) {
            return (
              (e *= 1),
              (t >>>= 0),
              r || E(this, e, t, 4, 0xffffffff, 0),
              (this[t] = e >>> 24),
              (this[t + 1] = e >>> 16),
              (this[t + 2] = e >>> 8),
              (this[t + 3] = 255 & e),
              t + 4
            );
          }),
        (o.prototype.writeBigUInt64LE = $(function (e, t = 0) {
          return _(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
        })),
        (o.prototype.writeBigUInt64BE = $(function (e, t = 0) {
          return C(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
        })),
        (o.prototype.writeIntLE = function (e, t, r, i) {
          if (((e *= 1), (t >>>= 0), !i)) {
            let i = Math.pow(2, 8 * r - 1);
            E(this, e, t, r, i - 1, -i);
          }
          let s = 0,
            n = 1,
            a = 0;
          for (this[t] = 255 & e; ++s < r && (n *= 256); )
            e < 0 && 0 === a && 0 !== this[t + s - 1] && (a = 1),
              (this[t + s] = (((e / n) | 0) - a) & 255);
          return t + r;
        }),
        (o.prototype.writeIntBE = function (e, t, r, i) {
          if (((e *= 1), (t >>>= 0), !i)) {
            let i = Math.pow(2, 8 * r - 1);
            E(this, e, t, r, i - 1, -i);
          }
          let s = r - 1,
            n = 1,
            a = 0;
          for (this[t + s] = 255 & e; --s >= 0 && (n *= 256); )
            e < 0 && 0 === a && 0 !== this[t + s + 1] && (a = 1),
              (this[t + s] = (((e / n) | 0) - a) & 255);
          return t + r;
        }),
        (o.prototype.writeInt8 = function (e, t, r) {
          return (
            (e *= 1),
            (t >>>= 0),
            r || E(this, e, t, 1, 127, -128),
            e < 0 && (e = 255 + e + 1),
            (this[t] = 255 & e),
            t + 1
          );
        }),
        (o.prototype.writeInt16LE = function (e, t, r) {
          return (
            (e *= 1),
            (t >>>= 0),
            r || E(this, e, t, 2, 32767, -32768),
            (this[t] = 255 & e),
            (this[t + 1] = e >>> 8),
            t + 2
          );
        }),
        (o.prototype.writeInt16BE = function (e, t, r) {
          return (
            (e *= 1),
            (t >>>= 0),
            r || E(this, e, t, 2, 32767, -32768),
            (this[t] = e >>> 8),
            (this[t + 1] = 255 & e),
            t + 2
          );
        }),
        (o.prototype.writeInt32LE = function (e, t, r) {
          return (
            (e *= 1),
            (t >>>= 0),
            r || E(this, e, t, 4, 0x7fffffff, -0x80000000),
            (this[t] = 255 & e),
            (this[t + 1] = e >>> 8),
            (this[t + 2] = e >>> 16),
            (this[t + 3] = e >>> 24),
            t + 4
          );
        }),
        (o.prototype.writeInt32BE = function (e, t, r) {
          return (
            (e *= 1),
            (t >>>= 0),
            r || E(this, e, t, 4, 0x7fffffff, -0x80000000),
            e < 0 && (e = 0xffffffff + e + 1),
            (this[t] = e >>> 24),
            (this[t + 1] = e >>> 16),
            (this[t + 2] = e >>> 8),
            (this[t + 3] = 255 & e),
            t + 4
          );
        }),
        (o.prototype.writeBigInt64LE = $(function (e, t = 0) {
          return _(
            this,
            e,
            t,
            -BigInt("0x8000000000000000"),
            BigInt("0x7fffffffffffffff")
          );
        })),
        (o.prototype.writeBigInt64BE = $(function (e, t = 0) {
          return C(
            this,
            e,
            t,
            -BigInt("0x8000000000000000"),
            BigInt("0x7fffffffffffffff")
          );
        })),
        (o.prototype.writeFloatLE = function (e, t, r) {
          return I(this, e, t, !0, r);
        }),
        (o.prototype.writeFloatBE = function (e, t, r) {
          return I(this, e, t, !1, r);
        }),
        (o.prototype.writeDoubleLE = function (e, t, r) {
          return S(this, e, t, !0, r);
        }),
        (o.prototype.writeDoubleBE = function (e, t, r) {
          return S(this, e, t, !1, r);
        }),
        (o.prototype.copy = function (e, t, r, i) {
          if (!o.isBuffer(e)) throw TypeError("argument should be a Buffer");
          if (
            (r || (r = 0),
            i || 0 === i || (i = this.length),
            t >= e.length && (t = e.length),
            t || (t = 0),
            i > 0 && i < r && (i = r),
            i === r || 0 === e.length || 0 === this.length)
          )
            return 0;
          if (t < 0) throw RangeError("targetStart out of bounds");
          if (r < 0 || r >= this.length) throw RangeError("Index out of range");
          if (i < 0) throw RangeError("sourceEnd out of bounds");
          i > this.length && (i = this.length),
            e.length - t < i - r && (i = e.length - t + r);
          let s = i - r;
          return (
            this === e && "function" == typeof Uint8Array.prototype.copyWithin
              ? this.copyWithin(t, r, i)
              : Uint8Array.prototype.set.call(e, this.subarray(r, i), t),
            s
          );
        }),
        (o.prototype.fill = function (e, t, r, i) {
          let s;
          if ("string" == typeof e) {
            if (
              ("string" == typeof t
                ? ((i = t), (t = 0), (r = this.length))
                : "string" == typeof r && ((i = r), (r = this.length)),
              void 0 !== i && "string" != typeof i)
            )
              throw TypeError("encoding must be a string");
            if ("string" == typeof i && !o.isEncoding(i))
              throw TypeError("Unknown encoding: " + i);
            if (1 === e.length) {
              let t = e.charCodeAt(0);
              (("utf8" === i && t < 128) || "latin1" === i) && (e = t);
            }
          } else
            "number" == typeof e
              ? (e &= 255)
              : "boolean" == typeof e && (e = Number(e));
          if (t < 0 || this.length < t || this.length < r)
            throw RangeError("Out of range index");
          if (r <= t) return this;
          if (
            ((t >>>= 0),
            (r = void 0 === r ? this.length : r >>> 0),
            e || (e = 0),
            "number" == typeof e)
          )
            for (s = t; s < r; ++s) this[s] = e;
          else {
            let n = o.isBuffer(e) ? e : o.from(e, i),
              a = n.length;
            if (0 === a)
              throw TypeError(
                'The value "' + e + '" is invalid for argument "value"'
              );
            for (s = 0; s < r - t; ++s) this[s + t] = n[s % a];
          }
          return this;
        });
      let N = {};
      function T(e, t, r) {
        N[e] = class extends r {
          constructor() {
            super(),
              Object.defineProperty(this, "message", {
                value: t.apply(this, arguments),
                writable: !0,
                configurable: !0,
              }),
              (this.name = `${this.name} [${e}]`),
              this.stack,
              delete this.name;
          }
          get code() {
            return e;
          }
          set code(e) {
            Object.defineProperty(this, "code", {
              configurable: !0,
              enumerable: !0,
              value: e,
              writable: !0,
            });
          }
          toString() {
            return `${this.name} [${e}]: ${this.message}`;
          }
        };
      }
      function O(e) {
        let t = "",
          r = e.length,
          i = +("-" === e[0]);
        for (; r >= i + 4; r -= 3) t = `_${e.slice(r - 3, r)}${t}`;
        return `${e.slice(0, r)}${t}`;
      }
      function x(e, t, r, i, s, n) {
        if (e > r || e < t) {
          let i,
            s = "bigint" == typeof t ? "n" : "";
          throw (
            ((i =
              n > 3
                ? 0 === t || t === BigInt(0)
                  ? `>= 0${s} and < 2${s} ** ${(n + 1) * 8}${s}`
                  : `>= -(2${s} ** ${(n + 1) * 8 - 1}${s}) and < 2 ** ${
                      (n + 1) * 8 - 1
                    }${s}`
                : `>= ${t}${s} and <= ${r}${s}`),
            new N.ERR_OUT_OF_RANGE("value", i, e))
          );
        }
        P(s, "offset"),
          (void 0 === i[s] || void 0 === i[s + n]) && R(s, i.length - (n + 1));
      }
      function P(e, t) {
        if ("number" != typeof e)
          throw new N.ERR_INVALID_ARG_TYPE(t, "number", e);
      }
      function R(e, t, r) {
        if (Math.floor(e) !== e)
          throw (
            (P(e, r), new N.ERR_OUT_OF_RANGE(r || "offset", "an integer", e))
          );
        if (t < 0) throw new N.ERR_BUFFER_OUT_OF_BOUNDS();
        throw new N.ERR_OUT_OF_RANGE(
          r || "offset",
          `>= ${+!!r} and <= ${t}`,
          e
        );
      }
      T(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function (e) {
          return e
            ? `${e} is outside of buffer bounds`
            : "Attempt to access memory outside buffer bounds";
        },
        RangeError
      ),
        T(
          "ERR_INVALID_ARG_TYPE",
          function (e, t) {
            return `The "${e}" argument must be of type number. Received type ${typeof t}`;
          },
          TypeError
        ),
        T(
          "ERR_OUT_OF_RANGE",
          function (e, t, r) {
            let i = `The value of "${e}" is out of range.`,
              s = r;
            return (
              Number.isInteger(r) && Math.abs(r) > 0x100000000
                ? (s = O(String(r)))
                : "bigint" == typeof r &&
                  ((s = String(r)),
                  (r > BigInt(2) ** BigInt(32) ||
                    r < -(BigInt(2) ** BigInt(32))) &&
                    (s = O(s)),
                  (s += "n")),
              (i += ` It must be ${t}. Received ${s}`)
            );
          },
          RangeError
        );
      let k = /[^+/0-9A-Za-z-_]/g;
      function D(e, t) {
        let r;
        t = t || 1 / 0;
        let i = e.length,
          s = null,
          n = [];
        for (let a = 0; a < i; ++a) {
          if ((r = e.charCodeAt(a)) > 55295 && r < 57344) {
            if (!s) {
              if (r > 56319 || a + 1 === i) {
                (t -= 3) > -1 && n.push(239, 191, 189);
                continue;
              }
              s = r;
              continue;
            }
            if (r < 56320) {
              (t -= 3) > -1 && n.push(239, 191, 189), (s = r);
              continue;
            }
            r = (((s - 55296) << 10) | (r - 56320)) + 65536;
          } else s && (t -= 3) > -1 && n.push(239, 191, 189);
          if (((s = null), r < 128)) {
            if ((t -= 1) < 0) break;
            n.push(r);
          } else if (r < 2048) {
            if ((t -= 2) < 0) break;
            n.push((r >> 6) | 192, (63 & r) | 128);
          } else if (r < 65536) {
            if ((t -= 3) < 0) break;
            n.push((r >> 12) | 224, ((r >> 6) & 63) | 128, (63 & r) | 128);
          } else if (r < 1114112) {
            if ((t -= 4) < 0) break;
            n.push(
              (r >> 18) | 240,
              ((r >> 12) & 63) | 128,
              ((r >> 6) & 63) | 128,
              (63 & r) | 128
            );
          } else throw Error("Invalid code point");
        }
        return n;
      }
      function U(e) {
        return i.toByteArray(
          (function (e) {
            if ((e = (e = e.split("=")[0]).trim().replace(k, "")).length < 2)
              return "";
            for (; e.length % 4 != 0; ) e += "=";
            return e;
          })(e)
        );
      }
      function L(e, t, r, i) {
        let s;
        for (s = 0; s < i && !(s + r >= t.length) && !(s >= e.length); ++s)
          t[s + r] = e[s];
        return s;
      }
      function M(e, t) {
        return (
          e instanceof t ||
          (null != e &&
            null != e.constructor &&
            null != e.constructor.name &&
            e.constructor.name === t.name)
        );
      }
      let j = (function () {
        let e = "0123456789abcdef",
          t = Array(256);
        for (let r = 0; r < 16; ++r) {
          let i = 16 * r;
          for (let s = 0; s < 16; ++s) t[i + s] = e[r] + e[s];
        }
        return t;
      })();
      function $(e) {
        return "undefined" == typeof BigInt ? B : e;
      }
      function B() {
        throw Error("BigInt not supported");
      }
    },
    45312: (e, t, r) => {
      "use strict";
      r.d(t, {
        OH: () => n,
        Vl: () => c,
        gS: () => a,
        hy: () => s,
        s1: () => o,
      });
      var i = r(49509);
      let s =
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_SECURE_SITE_SDK_URL
            : void 0) || "https://secure.walletconnect.org/sdk",
        n =
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_DEFAULT_LOG_LEVEL
            : void 0) || "error",
        a =
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_SECURE_SITE_SDK_VERSION
            : void 0) || "4",
        o = {
          APP_EVENT_KEY: "@w3m-app/",
          FRAME_EVENT_KEY: "@w3m-frame/",
          RPC_METHOD_KEY: "RPC_",
          STORAGE_KEY: "@appkit-wallet/",
          SESSION_TOKEN_KEY: "SESSION_TOKEN_KEY",
          EMAIL_LOGIN_USED_KEY: "EMAIL_LOGIN_USED_KEY",
          LAST_USED_CHAIN_KEY: "LAST_USED_CHAIN_KEY",
          LAST_EMAIL_LOGIN_TIME: "LAST_EMAIL_LOGIN_TIME",
          EMAIL: "EMAIL",
          PREFERRED_ACCOUNT_TYPE: "PREFERRED_ACCOUNT_TYPE",
          SMART_ACCOUNT_ENABLED: "SMART_ACCOUNT_ENABLED",
          SMART_ACCOUNT_ENABLED_NETWORKS: "SMART_ACCOUNT_ENABLED_NETWORKS",
          SOCIAL_USERNAME: "SOCIAL_USERNAME",
          APP_SWITCH_NETWORK: "@w3m-app/SWITCH_NETWORK",
          APP_CONNECT_EMAIL: "@w3m-app/CONNECT_EMAIL",
          APP_CONNECT_DEVICE: "@w3m-app/CONNECT_DEVICE",
          APP_CONNECT_OTP: "@w3m-app/CONNECT_OTP",
          APP_CONNECT_SOCIAL: "@w3m-app/CONNECT_SOCIAL",
          APP_GET_SOCIAL_REDIRECT_URI: "@w3m-app/GET_SOCIAL_REDIRECT_URI",
          APP_GET_USER: "@w3m-app/GET_USER",
          APP_SIGN_OUT: "@w3m-app/SIGN_OUT",
          APP_IS_CONNECTED: "@w3m-app/IS_CONNECTED",
          APP_GET_CHAIN_ID: "@w3m-app/GET_CHAIN_ID",
          APP_RPC_REQUEST: "@w3m-app/RPC_REQUEST",
          APP_UPDATE_EMAIL: "@w3m-app/UPDATE_EMAIL",
          APP_UPDATE_EMAIL_PRIMARY_OTP: "@w3m-app/UPDATE_EMAIL_PRIMARY_OTP",
          APP_UPDATE_EMAIL_SECONDARY_OTP: "@w3m-app/UPDATE_EMAIL_SECONDARY_OTP",
          APP_AWAIT_UPDATE_EMAIL: "@w3m-app/AWAIT_UPDATE_EMAIL",
          APP_SYNC_THEME: "@w3m-app/SYNC_THEME",
          APP_SYNC_DAPP_DATA: "@w3m-app/SYNC_DAPP_DATA",
          APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS:
            "@w3m-app/GET_SMART_ACCOUNT_ENABLED_NETWORKS",
          APP_INIT_SMART_ACCOUNT: "@w3m-app/INIT_SMART_ACCOUNT",
          APP_SET_PREFERRED_ACCOUNT: "@w3m-app/SET_PREFERRED_ACCOUNT",
          APP_CONNECT_FARCASTER: "@w3m-app/CONNECT_FARCASTER",
          APP_GET_FARCASTER_URI: "@w3m-app/GET_FARCASTER_URI",
          APP_RELOAD: "@w3m-app/RELOAD",
          FRAME_SWITCH_NETWORK_ERROR: "@w3m-frame/SWITCH_NETWORK_ERROR",
          FRAME_SWITCH_NETWORK_SUCCESS: "@w3m-frame/SWITCH_NETWORK_SUCCESS",
          FRAME_CONNECT_EMAIL_ERROR: "@w3m-frame/CONNECT_EMAIL_ERROR",
          FRAME_CONNECT_EMAIL_SUCCESS: "@w3m-frame/CONNECT_EMAIL_SUCCESS",
          FRAME_CONNECT_DEVICE_ERROR: "@w3m-frame/CONNECT_DEVICE_ERROR",
          FRAME_CONNECT_DEVICE_SUCCESS: "@w3m-frame/CONNECT_DEVICE_SUCCESS",
          FRAME_CONNECT_OTP_SUCCESS: "@w3m-frame/CONNECT_OTP_SUCCESS",
          FRAME_CONNECT_OTP_ERROR: "@w3m-frame/CONNECT_OTP_ERROR",
          FRAME_CONNECT_SOCIAL_SUCCESS: "@w3m-frame/CONNECT_SOCIAL_SUCCESS",
          FRAME_CONNECT_SOCIAL_ERROR: "@w3m-frame/CONNECT_SOCIAL_ERROR",
          FRAME_CONNECT_FARCASTER_SUCCESS:
            "@w3m-frame/CONNECT_FARCASTER_SUCCESS",
          FRAME_CONNECT_FARCASTER_ERROR: "@w3m-frame/CONNECT_FARCASTER_ERROR",
          FRAME_GET_FARCASTER_URI_SUCCESS:
            "@w3m-frame/GET_FARCASTER_URI_SUCCESS",
          FRAME_GET_FARCASTER_URI_ERROR: "@w3m-frame/GET_FARCASTER_URI_ERROR",
          FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS:
            "@w3m-frame/GET_SOCIAL_REDIRECT_URI_SUCCESS",
          FRAME_GET_SOCIAL_REDIRECT_URI_ERROR:
            "@w3m-frame/GET_SOCIAL_REDIRECT_URI_ERROR",
          FRAME_GET_USER_SUCCESS: "@w3m-frame/GET_USER_SUCCESS",
          FRAME_GET_USER_ERROR: "@w3m-frame/GET_USER_ERROR",
          FRAME_SIGN_OUT_SUCCESS: "@w3m-frame/SIGN_OUT_SUCCESS",
          FRAME_SIGN_OUT_ERROR: "@w3m-frame/SIGN_OUT_ERROR",
          FRAME_IS_CONNECTED_SUCCESS: "@w3m-frame/IS_CONNECTED_SUCCESS",
          FRAME_IS_CONNECTED_ERROR: "@w3m-frame/IS_CONNECTED_ERROR",
          FRAME_GET_CHAIN_ID_SUCCESS: "@w3m-frame/GET_CHAIN_ID_SUCCESS",
          FRAME_GET_CHAIN_ID_ERROR: "@w3m-frame/GET_CHAIN_ID_ERROR",
          FRAME_RPC_REQUEST_SUCCESS: "@w3m-frame/RPC_REQUEST_SUCCESS",
          FRAME_RPC_REQUEST_ERROR: "@w3m-frame/RPC_REQUEST_ERROR",
          FRAME_SESSION_UPDATE: "@w3m-frame/SESSION_UPDATE",
          FRAME_UPDATE_EMAIL_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SUCCESS",
          FRAME_UPDATE_EMAIL_ERROR: "@w3m-frame/UPDATE_EMAIL_ERROR",
          FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS:
            "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_SUCCESS",
          FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR:
            "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_ERROR",
          FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS:
            "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_SUCCESS",
          FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR:
            "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_ERROR",
          FRAME_SYNC_THEME_SUCCESS: "@w3m-frame/SYNC_THEME_SUCCESS",
          FRAME_SYNC_THEME_ERROR: "@w3m-frame/SYNC_THEME_ERROR",
          FRAME_SYNC_DAPP_DATA_SUCCESS: "@w3m-frame/SYNC_DAPP_DATA_SUCCESS",
          FRAME_SYNC_DAPP_DATA_ERROR: "@w3m-frame/SYNC_DAPP_DATA_ERROR",
          FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS:
            "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS",
          FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR:
            "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR",
          FRAME_INIT_SMART_ACCOUNT_SUCCESS:
            "@w3m-frame/INIT_SMART_ACCOUNT_SUCCESS",
          FRAME_INIT_SMART_ACCOUNT_ERROR: "@w3m-frame/INIT_SMART_ACCOUNT_ERROR",
          FRAME_SET_PREFERRED_ACCOUNT_SUCCESS:
            "@w3m-frame/SET_PREFERRED_ACCOUNT_SUCCESS",
          FRAME_SET_PREFERRED_ACCOUNT_ERROR:
            "@w3m-frame/SET_PREFERRED_ACCOUNT_ERROR",
          FRAME_READY: "@w3m-frame/READY",
          FRAME_RELOAD_SUCCESS: "@w3m-frame/RELOAD_SUCCESS",
          FRAME_RELOAD_ERROR: "@w3m-frame/RELOAD_ERROR",
          RPC_RESPONSE_TYPE_ERROR: "RPC_RESPONSE_ERROR",
          RPC_RESPONSE_TYPE_TX: "RPC_RESPONSE_TRANSACTION_HASH",
          RPC_RESPONSE_TYPE_OBJECT: "RPC_RESPONSE_OBJECT",
        },
        c = {
          SAFE_RPC_METHODS: [
            "eth_accounts",
            "eth_blockNumber",
            "eth_call",
            "eth_chainId",
            "eth_estimateGas",
            "eth_feeHistory",
            "eth_gasPrice",
            "eth_getAccount",
            "eth_getBalance",
            "eth_getBlockByHash",
            "eth_getBlockByNumber",
            "eth_getBlockReceipts",
            "eth_getBlockTransactionCountByHash",
            "eth_getBlockTransactionCountByNumber",
            "eth_getCode",
            "eth_getFilterChanges",
            "eth_getFilterLogs",
            "eth_getLogs",
            "eth_getProof",
            "eth_getStorageAt",
            "eth_getTransactionByBlockHashAndIndex",
            "eth_getTransactionByBlockNumberAndIndex",
            "eth_getTransactionByHash",
            "eth_getTransactionCount",
            "eth_getTransactionReceipt",
            "eth_getUncleCountByBlockHash",
            "eth_getUncleCountByBlockNumber",
            "eth_maxPriorityFeePerGas",
            "eth_newBlockFilter",
            "eth_newFilter",
            "eth_newPendingTransactionFilter",
            "eth_sendRawTransaction",
            "eth_syncing",
            "eth_uninstallFilter",
            "wallet_getCapabilities",
            "wallet_getCallsStatus",
            "eth_getUserOperationReceipt",
            "eth_estimateUserOperationGas",
            "eth_getUserOperationByHash",
            "eth_supportedEntryPoints",
            "wallet_getAssets",
          ],
          NOT_SAFE_RPC_METHODS: [
            "personal_sign",
            "eth_signTypedData_v4",
            "eth_sendTransaction",
            "solana_signMessage",
            "solana_signTransaction",
            "solana_signAllTransactions",
            "solana_signAndSendTransaction",
            "wallet_sendCalls",
            "wallet_grantPermissions",
            "wallet_revokePermissions",
            "eth_sendUserOperation",
          ],
          GET_CHAIN_ID: "eth_chainId",
          RPC_METHOD_NOT_ALLOWED_MESSAGE: "Requested RPC call is not allowed",
          RPC_METHOD_NOT_ALLOWED_UI_MESSAGE: "Action not allowed",
          ACCOUNT_TYPES: { EOA: "eoa", SMART_ACCOUNT: "smartAccount" },
        };
    },
    45714: (e, t, r) => {
      "use strict";
      r.d(t, { C: () => i });
      let i = {
        validateCaipAddress(e) {
          if (e.split(":")?.length !== 3) throw Error("Invalid CAIP Address");
          return e;
        },
        parseCaipAddress(e) {
          let t = e.split(":");
          if (3 !== t.length) throw Error(`Invalid CAIP-10 address: ${e}`);
          let [r, i, s] = t;
          if (!r || !i || !s) throw Error(`Invalid CAIP-10 address: ${e}`);
          return { chainNamespace: r, chainId: i, address: s };
        },
        parseCaipNetworkId(e) {
          let t = e.split(":");
          if (2 !== t.length) throw Error(`Invalid CAIP-2 network id: ${e}`);
          let [r, i] = t;
          if (!r || !i) throw Error(`Invalid CAIP-2 network id: ${e}`);
          return { chainNamespace: r, chainId: i };
        },
      };
    },
    45954: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => g }), r(50254);
      var i = r(60500),
        s = r(45312),
        n = r(11076),
        a = r(90906),
        o = r(6193),
        c = r(54252),
        l = r(32836),
        u = r(33806),
        d = r(96641),
        h = r(19628),
        p = r(5517),
        f = r(35558);
      let g = {
        getSIWX: () => d.H.state.siwx,
        async initializeIfEnabled() {
          let e = d.H.state.siwx,
            t = a.W.getActiveCaipAddress();
          if (!(e && t)) return;
          let [r, i, s] = t.split(":");
          if (a.W.checkIfSupportedNetwork(r))
            try {
              if ((await e.getSessions(`${r}:${i}`, s)).length) return;
              await u.W.open({ view: "SIWXSignMessage" });
            } catch (e) {
              console.error("SIWXUtil:initializeIfEnabled", e),
                l.E.sendEvent({
                  type: "track",
                  event: "SIWX_AUTH_ERROR",
                  properties: this.getSIWXEventProperties(),
                }),
                await o.x._getClient()?.disconnect().catch(console.error),
                h.I.reset("Connect"),
                p.P.showError(
                  "A problem occurred while trying initialize authentication"
                );
            }
        },
        async requestSignMessage() {
          let e = d.H.state.siwx,
            t = f.w.getPlainAddress(a.W.getActiveCaipAddress()),
            r = a.W.getActiveCaipNetwork(),
            s = o.x._getClient();
          if (!e) throw Error("SIWX is not enabled");
          if (!t) throw Error("No ActiveCaipAddress found");
          if (!r) throw Error("No ActiveCaipNetwork or client found");
          if (!s) throw Error("No ConnectionController client found");
          try {
            let n = await e.createMessage({
                chainId: r.caipNetworkId,
                accountAddress: t,
              }),
              a = n.toString();
            c.a.getConnectorId(r.chainNamespace) === i.o.CONNECTOR_ID.AUTH &&
              h.I.pushTransactionStack({});
            let o = await s.signMessage(a);
            await e.addSession({ data: n, message: a, signature: o }),
              u.W.close(),
              l.E.sendEvent({
                type: "track",
                event: "SIWX_AUTH_SUCCESS",
                properties: this.getSIWXEventProperties(),
              });
          } catch (t) {
            let e = this.getSIWXEventProperties();
            (u.W.state.open && "ApproveTransaction" !== h.I.state.view) ||
              (await u.W.open({ view: "SIWXSignMessage" })),
              e.isSmartAccount
                ? p.P.showError(
                    "This application might not support Smart Accounts"
                  )
                : p.P.showError("Signature declined"),
              l.E.sendEvent({
                type: "track",
                event: "SIWX_AUTH_ERROR",
                properties: e,
              }),
              console.error("SWIXUtil:requestSignMessage", t);
          }
        },
        async cancelSignMessage() {
          try {
            let e = this.getSIWX();
            e?.getRequired?.() ? await o.x.disconnect() : u.W.close(),
              h.I.reset("Connect"),
              l.E.sendEvent({
                event: "CLICK_CANCEL_SIWX",
                type: "track",
                properties: this.getSIWXEventProperties(),
              });
          } catch (e) {
            console.error("SIWXUtil:cancelSignMessage", e);
          }
        },
        async getSessions() {
          let e = d.H.state.siwx,
            t = f.w.getPlainAddress(a.W.getActiveCaipAddress()),
            r = a.W.getActiveCaipNetwork();
          return e && t && r ? e.getSessions(r.caipNetworkId, t) : [];
        },
        async isSIWXCloseDisabled() {
          let e = this.getSIWX();
          if (e) {
            let t = "ApproveTransaction" === h.I.state.view,
              r = "SIWXSignMessage" === h.I.state.view;
            if (t || r)
              return (
                e.getRequired?.() && 0 === (await this.getSessions()).length
              );
          }
          return !1;
        },
        async universalProviderAuthenticate({
          universalProvider: e,
          chains: t,
          methods: r,
        }) {
          let i = g.getSIWX(),
            s = new Set(t.map((e) => e.split(":")[0]));
          if (!i || 1 !== s.size || !s.has("eip155")) return !1;
          let o = await i.createMessage({
              chainId: a.W.getActiveCaipNetwork()?.caipNetworkId || "",
              accountAddress: "",
            }),
            c = await e.authenticate({
              nonce: o.nonce,
              domain: o.domain,
              uri: o.uri,
              exp: o.expirationTime,
              iat: o.issuedAt,
              nbf: o.notBefore,
              requestId: o.requestId,
              version: o.version,
              resources: o.resources,
              statement: o.statement,
              chainId: o.chainId,
              methods: r,
              chains: [o.chainId, ...t.filter((e) => e !== o.chainId)],
            });
          if (
            (p.P.showLoading("Authenticating...", { autoClose: !1 }),
            n.U.setConnectedWalletInfo(
              {
                ...c.session.peer.metadata,
                name: c.session.peer.metadata.name,
                icon: c.session.peer.metadata.icons?.[0],
                type: "WALLET_CONNECT",
              },
              Array.from(s)[0]
            ),
            c?.auths?.length)
          ) {
            let t = c.auths.map((t) => {
              let r = e.client.formatAuthMessage({
                request: t.p,
                iss: t.p.iss,
              });
              return {
                data: {
                  ...t.p,
                  accountAddress: t.p.iss.split(":").slice(-1).join(""),
                  chainId: t.p.iss.split(":").slice(2, 4).join(":"),
                  uri: t.p.aud,
                  version: t.p.version || o.version,
                  expirationTime: t.p.exp,
                  issuedAt: t.p.iat,
                  notBefore: t.p.nbf,
                },
                message: r,
                signature: t.s.s,
                cacao: t,
              };
            });
            try {
              await i.setSessions(t),
                l.E.sendEvent({
                  type: "track",
                  event: "SIWX_AUTH_SUCCESS",
                  properties: g.getSIWXEventProperties(),
                });
            } catch (t) {
              throw (
                (console.error(
                  "SIWX:universalProviderAuth - failed to set sessions",
                  t
                ),
                l.E.sendEvent({
                  type: "track",
                  event: "SIWX_AUTH_ERROR",
                  properties: g.getSIWXEventProperties(),
                }),
                await e.disconnect().catch(console.error),
                t)
              );
            } finally {
              p.P.hide();
            }
          }
          return !0;
        },
        getSIWXEventProperties() {
          let e = a.W.state.activeChain;
          return {
            network: a.W.state.activeCaipNetwork?.caipNetworkId || "",
            isSmartAccount:
              n.U.state.preferredAccountTypes?.[e] ===
              s.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
          };
        },
        async clearSessions() {
          let e = this.getSIWX();
          e && (await e.setSessions([]));
        },
      };
    },
    47584: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => p });
      var i = r(43708),
        s = r(45312),
        n = r(92555),
        a = r(11076),
        o = r(11501),
        c = r(90906),
        l = r(32836),
        u = r(96641),
        d = r(5517);
      let h = (0, i.BX)({
          transactions: [],
          coinbaseTransactions: {},
          transactionsByYear: {},
          lastNetworkInView: void 0,
          loading: !1,
          empty: !1,
          next: void 0,
        }),
        p = (0, n.X)(
          {
            state: h,
            subscribe: (e) => (0, i.B1)(h, () => e(h)),
            setLastNetworkInView(e) {
              h.lastNetworkInView = e;
            },
            async fetchTransactions(e, t) {
              if (!e)
                throw Error(
                  "Transactions can't be fetched without an accountAddress"
                );
              h.loading = !0;
              try {
                let r = await o.T.fetchTransactions({
                    account: e,
                    cursor: h.next,
                    onramp: t,
                    cache: "coinbase" === t ? "no-cache" : void 0,
                    chainId: c.W.state.activeCaipNetwork?.caipNetworkId,
                  }),
                  i = p.filterSpamTransactions(r.data),
                  s = p.filterByConnectedChain(i),
                  n = [...h.transactions, ...s];
                (h.loading = !1),
                  "coinbase" === t
                    ? (h.coinbaseTransactions =
                        p.groupTransactionsByYearAndMonth(
                          h.coinbaseTransactions,
                          r.data
                        ))
                    : ((h.transactions = n),
                      (h.transactionsByYear = p.groupTransactionsByYearAndMonth(
                        h.transactionsByYear,
                        s
                      ))),
                  (h.empty = 0 === n.length),
                  (h.next = r.next ? r.next : void 0);
              } catch (r) {
                let t = c.W.state.activeChain;
                l.E.sendEvent({
                  type: "track",
                  event: "ERROR_FETCH_TRANSACTIONS",
                  properties: {
                    address: e,
                    projectId: u.H.state.projectId,
                    cursor: h.next,
                    isSmartAccount:
                      a.U.state.preferredAccountTypes?.[t] ===
                      s.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                  },
                }),
                  d.P.showError("Failed to fetch transactions"),
                  (h.loading = !1),
                  (h.empty = !0),
                  (h.next = void 0);
              }
            },
            groupTransactionsByYearAndMonth: (e = {}, t = []) => (
              t.forEach((t) => {
                let r = new Date(t.metadata.minedAt).getFullYear(),
                  i = new Date(t.metadata.minedAt).getMonth(),
                  s = e[r] ?? {},
                  n = (s[i] ?? []).filter((e) => e.id !== t.id);
                e[r] = {
                  ...s,
                  [i]: [...n, t].sort(
                    (e, t) =>
                      new Date(t.metadata.minedAt).getTime() -
                      new Date(e.metadata.minedAt).getTime()
                  ),
                };
              }),
              e
            ),
            filterSpamTransactions: (e) =>
              e.filter(
                (e) =>
                  !e.transfers.every((e) => e.nft_info?.flags.is_spam === !0)
              ),
            filterByConnectedChain(e) {
              let t = c.W.state.activeCaipNetwork?.caipNetworkId;
              return e.filter((e) => e.metadata.chain === t);
            },
            clearCursor() {
              h.next = void 0;
            },
            resetTransactions() {
              (h.transactions = []),
                (h.transactionsByYear = {}),
                (h.lastNetworkInView = void 0),
                (h.loading = !1),
                (h.empty = !1),
                (h.next = void 0);
            },
          },
          "API_ERROR"
        );
    },
    48374: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => a, x: () => o });
      var i = r(12115),
        s = r(75483);
      function n(e) {
        let {
            children: t,
            config: r,
            initialState: n,
            reconnectOnMount: a = !0,
          } = e,
          { onMount: o } = (function (e, t) {
            let { initialState: r, reconnectOnMount: i } = t;
            return (
              r &&
                !e._internal.store.persist.hasHydrated() &&
                e.setState({
                  ...r,
                  chainId: e.chains.some((e) => e.id === r.chainId)
                    ? r.chainId
                    : e.chains[0].id,
                  connections: i ? r.connections : new Map(),
                  status: i ? "reconnecting" : "disconnected",
                }),
              {
                async onMount() {
                  e._internal.ssr &&
                    (await e._internal.store.persist.rehydrate(),
                    e._internal.mipd &&
                      e._internal.connectors.setState((t) => {
                        let r = new Set();
                        for (let e of t ?? [])
                          if (e.rdns)
                            for (let t of Array.isArray(e.rdns)
                              ? e.rdns
                              : [e.rdns])
                              r.add(t);
                        let i = [];
                        for (let t of e._internal.mipd?.getProviders() ?? []) {
                          if (r.has(t.info.rdns)) continue;
                          let s =
                              e._internal.connectors.providerDetailToConnector(
                                t
                              ),
                            n = e._internal.connectors.setup(s);
                          i.push(n);
                        }
                        return [...t, ...i];
                      })),
                    i
                      ? (0, s.M)(e)
                      : e.storage &&
                        e.setState((e) => ({ ...e, connections: new Map() }));
                },
              }
            );
          })(r, { initialState: n, reconnectOnMount: a });
        r._internal.ssr || o();
        let c = (0, i.useRef)(!0);
        return (
          (0, i.useEffect)(() => {
            if (c.current && r._internal.ssr)
              return (
                o(),
                () => {
                  c.current = !1;
                }
              );
          }, []),
          t
        );
      }
      let a = (0, i.createContext)(void 0);
      function o(e) {
        let { children: t, config: r } = e;
        return (0, i.createElement)(
          n,
          e,
          (0, i.createElement)(a.Provider, { value: r }, t)
        );
      }
    },
    50254: (e, t, r) => {
      "use strict";
      let i;
      r.d(t, { A: () => gr });
      var s = {};
      r.r(s), r.d(s, { identity: () => i3 });
      var n = {};
      r.r(n), r.d(n, { base2: () => i5 });
      var a = {};
      r.r(a), r.d(a, { base8: () => i8 });
      var o = {};
      r.r(o), r.d(o, { base10: () => i6 });
      var c = {};
      r.r(c), r.d(c, { base16: () => i4, base16upper: () => i9 });
      var l = {};
      r.r(l),
        r.d(l, {
          base32: () => i7,
          base32hex: () => si,
          base32hexpad: () => sn,
          base32hexpadupper: () => sa,
          base32hexupper: () => ss,
          base32pad: () => st,
          base32padupper: () => sr,
          base32upper: () => se,
          base32z: () => so,
        });
      var u = {};
      r.r(u), r.d(u, { base36: () => sc, base36upper: () => sl });
      var d = {};
      r.r(d), r.d(d, { base58btc: () => su, base58flickr: () => sd });
      var h = {};
      r.r(h),
        r.d(h, {
          base64: () => sh,
          base64pad: () => sp,
          base64url: () => sf,
          base64urlpad: () => sg,
        });
      var p = {};
      r.r(p), r.d(p, { base256emoji: () => sw });
      var f = {};
      r.r(f), r.d(f, { sha256: () => sk, sha512: () => sD });
      var g = {};
      r.r(g), r.d(g, { identity: () => sU });
      var m = {};
      r.r(m),
        r.d(m, {
          code: () => sM,
          decode: () => s$,
          encode: () => sj,
          name: () => sL,
        });
      var y = {};
      r.r(y),
        r.d(y, {
          code: () => sq,
          decode: () => sz,
          encode: () => sH,
          name: () => sW,
        });
      var b = r(40662),
        w = r.n(b),
        v = r(89101);
      class E {}
      class _ extends E {
        constructor(e) {
          super();
        }
      }
      let C = v.FIVE_SECONDS,
        A = { pulse: "heartbeat_pulse" };
      class I extends _ {
        constructor(e) {
          super(e),
            (this.events = new b.EventEmitter()),
            (this.interval = C),
            (this.interval = e?.interval || C);
        }
        static async init(e) {
          let t = new I(e);
          return await t.init(), t;
        }
        async init() {
          await this.initialize();
        }
        stop() {
          clearInterval(this.intervalRef);
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async initialize() {
          this.intervalRef = setInterval(
            () => this.pulse(),
            (0, v.toMiliseconds)(this.interval)
          );
        }
        pulse() {
          this.events.emit(A.pulse);
        }
      }
      let S =
          /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
        N =
          /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
        T = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
      function O(e, t) {
        var r;
        return "__proto__" === e ||
          ("constructor" === e && t && "object" == typeof t && "prototype" in t)
          ? void ((r = e),
            console.warn(
              `[destr] Dropping "${r}" key to prevent prototype pollution.`
            ))
          : t;
      }
      function x(e, t = {}) {
        if ("string" != typeof e) return e;
        if ('"' === e[0] && '"' === e[e.length - 1] && -1 === e.indexOf("\\"))
          return e.slice(1, -1);
        let r = e.trim();
        if (r.length <= 9)
          switch (r.toLowerCase()) {
            case "true":
              return !0;
            case "false":
              return !1;
            case "undefined":
              return;
            case "null":
              return null;
            case "nan":
              return Number.NaN;
            case "infinity":
              return Number.POSITIVE_INFINITY;
            case "-infinity":
              return Number.NEGATIVE_INFINITY;
          }
        if (!T.test(e)) {
          if (t.strict) throw SyntaxError("[destr] Invalid JSON");
          return e;
        }
        try {
          if (S.test(e) || N.test(e)) {
            if (t.strict) throw Error("[destr] Possible prototype pollution");
            return JSON.parse(e, O);
          }
          return JSON.parse(e);
        } catch (r) {
          if (t.strict) throw r;
          return e;
        }
      }
      var P = r(44134).Buffer;
      function R(e, ...t) {
        try {
          var r;
          return (r = e(...t)) && "function" == typeof r.then
            ? r
            : Promise.resolve(r);
        } catch (e) {
          return Promise.reject(e);
        }
      }
      function k(e) {
        if (
          (function (e) {
            let t = typeof e;
            return null === e || ("object" !== t && "function" !== t);
          })(e)
        )
          return String(e);
        if (
          (function (e) {
            let t = Object.getPrototypeOf(e);
            return !t || t.isPrototypeOf(Object);
          })(e) ||
          Array.isArray(e)
        )
          return JSON.stringify(e);
        if ("function" == typeof e.toJSON) return k(e.toJSON());
        throw Error("[unstorage] Cannot stringify value!");
      }
      let D = "base64:";
      function U(e) {
        return (
          (e &&
            e
              .split("?")[0]
              ?.replace(/[/\\]/g, ":")
              .replace(/:+/g, ":")
              .replace(/^:|:$/g, "")) ||
          ""
        );
      }
      function L(e) {
        return (e = U(e)) ? e + ":" : "";
      }
      let M = () => {
        let e = new Map();
        return {
          name: "memory",
          getInstance: () => e,
          hasItem: (t) => e.has(t),
          getItem: (t) => e.get(t) ?? null,
          getItemRaw: (t) => e.get(t) ?? null,
          setItem(t, r) {
            e.set(t, r);
          },
          setItemRaw(t, r) {
            e.set(t, r);
          },
          removeItem(t) {
            e.delete(t);
          },
          getKeys: () => [...e.keys()],
          clear() {
            e.clear();
          },
          dispose() {
            e.clear();
          },
        };
      };
      function j(e, t, r) {
        return e.watch ? e.watch((e, i) => t(e, r + i)) : () => {};
      }
      async function $(e) {
        "function" == typeof e.dispose && (await R(e.dispose));
      }
      function B(e) {
        return new Promise((t, r) => {
          (e.oncomplete = e.onsuccess = () => t(e.result)),
            (e.onabort = e.onerror = () => r(e.error));
        });
      }
      function F(e, t) {
        let r,
          i = () => {
            if (r) return r;
            let i = indexedDB.open(e);
            return (
              (i.onupgradeneeded = () => i.result.createObjectStore(t)),
              (r = B(i)).then(
                (e) => {
                  e.onclose = () => (r = void 0);
                },
                () => {}
              ),
              r
            );
          };
        return (e, r) => i().then((i) => r(i.transaction(t, e).objectStore(t)));
      }
      function W() {
        return i || (i = F("keyval-store", "keyval")), i;
      }
      function q(e, t = W()) {
        return t("readonly", (t) => B(t.get(e)));
      }
      var H = r(71075),
        z = (e = {}) => {
          let t,
            r = e.base && e.base.length > 0 ? `${e.base}:` : "",
            i = (e) => r + e;
          return (
            e.dbName && e.storeName && (t = F(e.dbName, e.storeName)),
            {
              name: "idb-keyval",
              options: e,
              hasItem: async (e) => !(typeof (await q(i(e), t)) > "u"),
              getItem: async (e) => (await q(i(e), t)) ?? null,
              setItem: (e, r) =>
                (function (e, t, r = W()) {
                  return r("readwrite", (r) => (r.put(t, e), B(r.transaction)));
                })(i(e), r, t),
              removeItem: (e) =>
                (function (e, t = W()) {
                  return t("readwrite", (t) => (t.delete(e), B(t.transaction)));
                })(i(e), t),
              getKeys: () =>
                (function (e = W()) {
                  return e("readonly", (e) => {
                    var t, r;
                    if (e.getAllKeys) return B(e.getAllKeys());
                    let i = [];
                    return ((t = e),
                    (r = (e) => i.push(e.key)),
                    (t.openCursor().onsuccess = function () {
                      this.result && (r(this.result), this.result.continue());
                    }),
                    B(t.transaction)).then(() => i);
                  });
                })(t),
              clear: () =>
                (function (e = W()) {
                  return e("readwrite", (e) => (e.clear(), B(e.transaction)));
                })(t),
            }
          );
        };
      class V {
        constructor() {
          this.indexedDb = (function (e = {}) {
            let t = {
                mounts: { "": e.driver || M() },
                mountpoints: [""],
                watching: !1,
                watchListeners: [],
                unwatch: {},
              },
              r = (e) => {
                for (let r of t.mountpoints)
                  if (e.startsWith(r))
                    return {
                      base: r,
                      relativeKey: e.slice(r.length),
                      driver: t.mounts[r],
                    };
                return { base: "", relativeKey: e, driver: t.mounts[""] };
              },
              i = (e, r) =>
                t.mountpoints
                  .filter((t) => t.startsWith(e) || (r && e.startsWith(t)))
                  .map((r) => ({
                    relativeBase:
                      e.length > r.length ? e.slice(r.length) : void 0,
                    mountpoint: r,
                    driver: t.mounts[r],
                  })),
              s = (e, r) => {
                if (t.watching)
                  for (let i of ((r = U(r)), t.watchListeners)) i(e, r);
              },
              n = async () => {
                if (!t.watching)
                  for (let e in ((t.watching = !0), t.mounts))
                    t.unwatch[e] = await j(t.mounts[e], s, e);
              },
              a = async () => {
                if (t.watching) {
                  for (let e in t.unwatch) await t.unwatch[e]();
                  (t.unwatch = {}), (t.watching = !1);
                }
              },
              o = (e, t, i) => {
                let s = new Map(),
                  n = (e) => {
                    let t = s.get(e.base);
                    return (
                      t ||
                        ((t = { driver: e.driver, base: e.base, items: [] }),
                        s.set(e.base, t)),
                      t
                    );
                  };
                for (let i of e) {
                  let e = "string" == typeof i,
                    s = U(e ? i : i.key),
                    a = e ? void 0 : i.value,
                    o = e || !i.options ? t : { ...t, ...i.options },
                    c = r(s);
                  n(c).items.push({
                    key: s,
                    value: a,
                    relativeKey: c.relativeKey,
                    options: o,
                  });
                }
                return Promise.all([...s.values()].map((e) => i(e))).then((e) =>
                  e.flat()
                );
              },
              c = {
                hasItem(e, t = {}) {
                  let { relativeKey: i, driver: s } = r((e = U(e)));
                  return R(s.hasItem, i, t);
                },
                getItem(e, t = {}) {
                  let { relativeKey: i, driver: s } = r((e = U(e)));
                  return R(s.getItem, i, t).then((e) => x(e));
                },
                getItems: (e, t = {}) =>
                  o(e, t, (e) =>
                    e.driver.getItems
                      ? R(
                          e.driver.getItems,
                          e.items.map((e) => ({
                            key: e.relativeKey,
                            options: e.options,
                          })),
                          t
                        ).then((t) =>
                          t.map((t) => ({
                            key: (function (...e) {
                              return U(e.join(":"));
                            })(e.base, t.key),
                            value: x(t.value),
                          }))
                        )
                      : Promise.all(
                          e.items.map((t) =>
                            R(e.driver.getItem, t.relativeKey, t.options).then(
                              (e) => ({ key: t.key, value: x(e) })
                            )
                          )
                        )
                  ),
                getItemRaw(e, t = {}) {
                  let { relativeKey: i, driver: s } = r((e = U(e)));
                  return s.getItemRaw
                    ? R(s.getItemRaw, i, t)
                    : R(s.getItem, i, t).then((e) => {
                        var t;
                        return "string" == typeof e && e.startsWith(D)
                          ? ((t = e.slice(D.length)),
                            globalThis.Buffer
                              ? P.from(t, "base64")
                              : Uint8Array.from(globalThis.atob(t), (e) =>
                                  e.codePointAt(0)
                                ))
                          : e;
                      });
                },
                async setItem(e, t, i = {}) {
                  if (void 0 === t) return c.removeItem(e);
                  let { relativeKey: n, driver: a } = r((e = U(e)));
                  a.setItem &&
                    (await R(a.setItem, n, k(t), i), a.watch || s("update", e));
                },
                async setItems(e, t) {
                  await o(e, t, async (e) => {
                    if (e.driver.setItems)
                      return R(
                        e.driver.setItems,
                        e.items.map((e) => ({
                          key: e.relativeKey,
                          value: k(e.value),
                          options: e.options,
                        })),
                        t
                      );
                    e.driver.setItem &&
                      (await Promise.all(
                        e.items.map((t) =>
                          R(
                            e.driver.setItem,
                            t.relativeKey,
                            k(t.value),
                            t.options
                          )
                        )
                      ));
                  });
                },
                async setItemRaw(e, t, i = {}) {
                  if (void 0 === t) return c.removeItem(e, i);
                  let { relativeKey: n, driver: a } = r((e = U(e)));
                  if (a.setItemRaw) await R(a.setItemRaw, n, t, i);
                  else {
                    var o;
                    if (!a.setItem) return;
                    await R(
                      a.setItem,
                      n,
                      "string" == typeof t
                        ? t
                        : D +
                            ((o = t),
                            globalThis.Buffer
                              ? P.from(o).toString("base64")
                              : globalThis.btoa(String.fromCodePoint(...o))),
                      i
                    );
                  }
                  a.watch || s("update", e);
                },
                async removeItem(e, t = {}) {
                  "boolean" == typeof t && (t = { removeMeta: t });
                  let { relativeKey: i, driver: n } = r((e = U(e)));
                  n.removeItem &&
                    (await R(n.removeItem, i, t),
                    (t.removeMeta || t.removeMata) &&
                      (await R(n.removeItem, i + "$", t)),
                    n.watch || s("remove", e));
                },
                async getMeta(e, t = {}) {
                  "boolean" == typeof t && (t = { nativeOnly: t });
                  let { relativeKey: i, driver: s } = r((e = U(e))),
                    n = Object.create(null);
                  if (
                    (s.getMeta && Object.assign(n, await R(s.getMeta, i, t)),
                    !t.nativeOnly)
                  ) {
                    let e = await R(s.getItem, i + "$", t).then((e) => x(e));
                    e &&
                      "object" == typeof e &&
                      ("string" == typeof e.atime &&
                        (e.atime = new Date(e.atime)),
                      "string" == typeof e.mtime &&
                        (e.mtime = new Date(e.mtime)),
                      Object.assign(n, e));
                  }
                  return n;
                },
                setMeta(e, t, r = {}) {
                  return this.setItem(e + "$", t, r);
                },
                removeMeta(e, t = {}) {
                  return this.removeItem(e + "$", t);
                },
                async getKeys(e, t = {}) {
                  let r = i((e = L(e)), !0),
                    s = [],
                    n = [],
                    a = !0;
                  for (let e of r) {
                    for (let r of (e.driver.flags?.maxDepth || (a = !1),
                    await R(e.driver.getKeys, e.relativeBase, t))) {
                      let t = e.mountpoint + U(r);
                      s.some((e) => t.startsWith(e)) || n.push(t);
                    }
                    s = [
                      e.mountpoint,
                      ...s.filter((t) => !t.startsWith(e.mountpoint)),
                    ];
                  }
                  let o = void 0 !== t.maxDepth && !a;
                  return n.filter((r) => {
                    var i;
                    return (
                      (!o ||
                        (function (e, t) {
                          if (void 0 === t) return !0;
                          let r = 0,
                            i = e.indexOf(":");
                          for (; i > -1; ) r++, (i = e.indexOf(":", i + 1));
                          return r <= t;
                        })(r, t.maxDepth)) &&
                      ((i = e)
                        ? r.startsWith(i) && "$" !== r[r.length - 1]
                        : "$" !== r[r.length - 1])
                    );
                  });
                },
                async clear(e, t = {}) {
                  (e = L(e)),
                    await Promise.all(
                      i(e, !1).map(async (e) =>
                        e.driver.clear
                          ? R(e.driver.clear, e.relativeBase, t)
                          : e.driver.removeItem
                          ? Promise.all(
                              (
                                await e.driver.getKeys(e.relativeBase || "", t)
                              ).map((r) => e.driver.removeItem(r, t))
                            )
                          : void 0
                      )
                    );
                },
                async dispose() {
                  await Promise.all(Object.values(t.mounts).map((e) => $(e)));
                },
                watch: async (e) => (
                  await n(),
                  t.watchListeners.push(e),
                  async () => {
                    (t.watchListeners = t.watchListeners.filter(
                      (t) => t !== e
                    )),
                      0 === t.watchListeners.length && (await a());
                  }
                ),
                async unwatch() {
                  (t.watchListeners = []), await a();
                },
                mount(e, r) {
                  if ((e = L(e)) && t.mounts[e])
                    throw Error(`already mounted at ${e}`);
                  return (
                    e &&
                      (t.mountpoints.push(e),
                      t.mountpoints.sort((e, t) => t.length - e.length)),
                    (t.mounts[e] = r),
                    t.watching &&
                      Promise.resolve(j(r, s, e))
                        .then((r) => {
                          t.unwatch[e] = r;
                        })
                        .catch(console.error),
                    c
                  );
                },
                async unmount(e, r = !0) {
                  (e = L(e)) &&
                    t.mounts[e] &&
                    (t.watching &&
                      e in t.unwatch &&
                      (t.unwatch[e]?.(), delete t.unwatch[e]),
                    r && (await $(t.mounts[e])),
                    (t.mountpoints = t.mountpoints.filter((t) => t !== e)),
                    delete t.mounts[e]);
                },
                getMount(e = "") {
                  let t = r((e = U(e) + ":"));
                  return { driver: t.driver, base: t.base };
                },
                getMounts: (e = "", t = {}) =>
                  i((e = U(e)), t.parents).map((e) => ({
                    driver: e.driver,
                    base: e.mountpoint,
                  })),
                keys: (e, t = {}) => c.getKeys(e, t),
                get: (e, t = {}) => c.getItem(e, t),
                set: (e, t, r = {}) => c.setItem(e, t, r),
                has: (e, t = {}) => c.hasItem(e, t),
                del: (e, t = {}) => c.removeItem(e, t),
                remove: (e, t = {}) => c.removeItem(e, t),
              };
            return c;
          })({
            driver: z({
              dbName: "WALLET_CONNECT_V2_INDEXED_DB",
              storeName: "keyvaluestorage",
            }),
          });
        }
        async getKeys() {
          return this.indexedDb.getKeys();
        }
        async getEntries() {
          return (
            await this.indexedDb.getItems(await this.indexedDb.getKeys())
          ).map((e) => [e.key, e.value]);
        }
        async getItem(e) {
          let t = await this.indexedDb.getItem(e);
          if (null !== t) return t;
        }
        async setItem(e, t) {
          await this.indexedDb.setItem(e, (0, H.h)(t));
        }
        async removeItem(e) {
          await this.indexedDb.removeItem(e);
        }
      }
      var K =
          "u" > typeof globalThis
            ? globalThis
            : "u" > typeof window
            ? window
            : "u" > typeof r.g
            ? r.g
            : "u" > typeof self
            ? self
            : {},
        G = { exports: {} };
      function Y(e) {
        var t;
        return [e[0], (0, H.j)(null != (t = e[1]) ? t : "")];
      }
      !(function () {
        function e() {}
        (e.prototype.getItem = function (e) {
          return this.hasOwnProperty(e) ? String(this[e]) : null;
        }),
          (e.prototype.setItem = function (e, t) {
            this[e] = String(t);
          }),
          (e.prototype.removeItem = function (e) {
            delete this[e];
          }),
          (e.prototype.clear = function () {
            let e = this;
            Object.keys(e).forEach(function (t) {
              (e[t] = void 0), delete e[t];
            });
          }),
          (e.prototype.key = function (e) {
            return (e = e || 0), Object.keys(this)[e];
          }),
          e.prototype.__defineGetter__("length", function () {
            return Object.keys(this).length;
          }),
          "u" > typeof K && K.localStorage
            ? (G.exports = K.localStorage)
            : "u" > typeof window && window.localStorage
            ? (G.exports = window.localStorage)
            : (G.exports = new e());
      })();
      class Z {
        constructor() {
          this.localStorage = G.exports;
        }
        async getKeys() {
          return Object.keys(this.localStorage);
        }
        async getEntries() {
          return Object.entries(this.localStorage).map(Y);
        }
        async getItem(e) {
          let t = this.localStorage.getItem(e);
          if (null !== t) return (0, H.j)(t);
        }
        async setItem(e, t) {
          this.localStorage.setItem(e, (0, H.h)(t));
        }
        async removeItem(e) {
          this.localStorage.removeItem(e);
        }
      }
      let J = async (e, t, r) => {
          let i = "wc_storage_version",
            s = await t.getItem(i);
          if (s && s >= 1) return void r(t);
          let n = await e.getKeys();
          if (!n.length) return void r(t);
          let a = [];
          for (; n.length; ) {
            let r = n.shift();
            if (!r) continue;
            let i = r.toLowerCase();
            if (
              i.includes("wc@") ||
              i.includes("walletconnect") ||
              i.includes("wc_") ||
              i.includes("wallet_connect")
            ) {
              let i = await e.getItem(r);
              await t.setItem(r, i), a.push(r);
            }
          }
          await t.setItem(i, 1), r(t), X(e, a);
        },
        X = async (e, t) => {
          t.length &&
            t.forEach(async (t) => {
              await e.removeItem(t);
            });
        };
      class Q {
        constructor() {
          (this.initialized = !1),
            (this.setInitialized = (e) => {
              (this.storage = e), (this.initialized = !0);
            });
          let e = new Z();
          this.storage = e;
          try {
            let t = new V();
            J(e, t, this.setInitialized);
          } catch {
            this.initialized = !0;
          }
        }
        async getKeys() {
          return await this.initialize(), this.storage.getKeys();
        }
        async getEntries() {
          return await this.initialize(), this.storage.getEntries();
        }
        async getItem(e) {
          return await this.initialize(), this.storage.getItem(e);
        }
        async setItem(e, t) {
          return await this.initialize(), this.storage.setItem(e, t);
        }
        async removeItem(e) {
          return await this.initialize(), this.storage.removeItem(e);
        }
        async initialize() {
          this.initialized ||
            (await new Promise((e) => {
              let t = setInterval(() => {
                this.initialized && (clearInterval(t), e());
              }, 20);
            }));
        }
      }
      var ee = r(19655),
        et = Object.defineProperty,
        er = (e, t, r) =>
          t in e
            ? et(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        ei = (e, t, r) => er(e, "symbol" != typeof t ? t + "" : t, r);
      class es extends E {
        constructor(e) {
          super(),
            (this.opts = e),
            ei(this, "protocol", "wc"),
            ei(this, "version", 2);
        }
      }
      var en = Object.defineProperty,
        ea = (e, t, r) =>
          t in e
            ? en(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        eo = (e, t, r) => ea(e, "symbol" != typeof t ? t + "" : t, r);
      class ec extends E {
        constructor(e, t) {
          super(),
            (this.core = e),
            (this.logger = t),
            eo(this, "records", new Map());
        }
      }
      class el {
        constructor(e, t) {
          (this.logger = e), (this.core = t);
        }
      }
      class eu extends E {
        constructor(e, t) {
          super(), (this.relayer = e), (this.logger = t);
        }
      }
      class ed extends E {
        constructor(e) {
          super();
        }
      }
      class eh {
        constructor(e, t, r, i) {
          (this.core = e), (this.logger = t), (this.name = r);
        }
      }
      var ep = Object.defineProperty;
      class ef extends E {
        constructor(e, t) {
          super(), (this.relayer = e), (this.logger = t);
        }
      }
      class eg extends E {
        constructor(e, t) {
          super(), (this.core = e), (this.logger = t);
        }
      }
      class em {
        constructor(e, t, r) {
          (this.core = e), (this.logger = t), (this.store = r);
        }
      }
      class ey {
        constructor(e, t) {
          (this.projectId = e), (this.logger = t);
        }
      }
      class eb {
        constructor(e, t, r) {
          (this.core = e), (this.logger = t), (this.telemetryEnabled = r);
        }
      }
      var ew = Object.defineProperty,
        ev = (e, t, r) =>
          t in e
            ? ew(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        eE = (e, t, r) => ev(e, "symbol" != typeof t ? t + "" : t, r);
      w();
      class e_ {
        constructor(e) {
          (this.opts = e), eE(this, "protocol", "wc"), eE(this, "version", 2);
        }
      }
      b.EventEmitter;
      class eC {
        constructor(e) {
          this.client = e;
        }
      }
      function eA(e, ...t) {
        if (
          !(
            e instanceof Uint8Array ||
            (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
          )
        )
          throw Error("Uint8Array expected");
        if (t.length > 0 && !t.includes(e.length))
          throw Error(
            "Uint8Array expected of length " + t + ", got length=" + e.length
          );
      }
      function eI(e, t = !0) {
        if (e.destroyed) throw Error("Hash instance has been destroyed");
        if (t && e.finished)
          throw Error("Hash#digest() has already been called");
      }
      let eS =
          "object" == typeof globalThis && "crypto" in globalThis
            ? globalThis.crypto
            : void 0,
        eN = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
      function eT(e) {
        return (
          "string" == typeof e &&
            (e = (function (e) {
              if ("string" != typeof e)
                throw Error("utf8ToBytes expected string, got " + typeof e);
              return new Uint8Array(new TextEncoder().encode(e));
            })(e)),
          eA(e),
          e
        );
      }
      class eO {
        clone() {
          return this._cloneInto();
        }
      }
      function ex(e = 32) {
        if (eS && "function" == typeof eS.getRandomValues)
          return eS.getRandomValues(new Uint8Array(e));
        if (eS && "function" == typeof eS.randomBytes) return eS.randomBytes(e);
        throw Error("crypto.getRandomValues must be defined");
      }
      class eP extends eO {
        constructor(e, t, r, i) {
          super(),
            (this.blockLen = e),
            (this.outputLen = t),
            (this.padOffset = r),
            (this.isLE = i),
            (this.finished = !1),
            (this.length = 0),
            (this.pos = 0),
            (this.destroyed = !1),
            (this.buffer = new Uint8Array(e)),
            (this.view = eN(this.buffer));
        }
        update(e) {
          eI(this);
          let { view: t, buffer: r, blockLen: i } = this,
            s = (e = eT(e)).length;
          for (let n = 0; n < s; ) {
            let a = Math.min(i - this.pos, s - n);
            if (a === i) {
              let t = eN(e);
              for (; i <= s - n; n += i) this.process(t, n);
              continue;
            }
            r.set(e.subarray(n, n + a), this.pos),
              (this.pos += a),
              (n += a),
              this.pos === i && (this.process(t, 0), (this.pos = 0));
          }
          return (this.length += e.length), this.roundClean(), this;
        }
        digestInto(e) {
          eI(this),
            (function (e, t) {
              eA(e);
              let r = t.outputLen;
              if (e.length < r)
                throw Error(
                  "digestInto() expects output buffer of length at least " + r
                );
            })(e, this),
            (this.finished = !0);
          let { buffer: t, view: r, blockLen: i, isLE: s } = this,
            { pos: n } = this;
          (t[n++] = 128),
            this.buffer.subarray(n).fill(0),
            this.padOffset > i - n && (this.process(r, 0), (n = 0));
          for (let e = n; e < i; e++) t[e] = 0;
          (function (e, t, r, i) {
            if ("function" == typeof e.setBigUint64)
              return e.setBigUint64(t, r, i);
            let s = BigInt(32),
              n = BigInt(0xffffffff),
              a = Number((r >> s) & n),
              o = Number(r & n),
              c = 4 * !!i,
              l = 4 * !i;
            e.setUint32(t + c, a, i), e.setUint32(t + l, o, i);
          })(r, i - 8, BigInt(8 * this.length), s),
            this.process(r, 0);
          let a = eN(e),
            o = this.outputLen;
          if (o % 4) throw Error("_sha2: outputLen should be aligned to 32bit");
          let c = o / 4,
            l = this.get();
          if (c > l.length) throw Error("_sha2: outputLen bigger than state");
          for (let e = 0; e < c; e++) a.setUint32(4 * e, l[e], s);
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let r = e.slice(0, t);
          return this.destroy(), r;
        }
        _cloneInto(e) {
          e || (e = new this.constructor()), e.set(...this.get());
          let {
            blockLen: t,
            buffer: r,
            length: i,
            finished: s,
            destroyed: n,
            pos: a,
          } = this;
          return (
            (e.length = i),
            (e.pos = a),
            (e.finished = s),
            (e.destroyed = n),
            i % t && e.buffer.set(r),
            e
          );
        }
      }
      let eR = BigInt(0x100000000 - 1),
        ek = BigInt(32),
        eD = {
          split: function (e, t = !1) {
            let r = new Uint32Array(e.length),
              i = new Uint32Array(e.length);
            for (let s = 0; s < e.length; s++) {
              let { h: n, l: a } = (function (e, t = !1) {
                return t
                  ? { h: Number(e & eR), l: Number((e >> ek) & eR) }
                  : { h: 0 | Number((e >> ek) & eR), l: 0 | Number(e & eR) };
              })(e[s], t);
              [r[s], i[s]] = [n, a];
            }
            return [r, i];
          },
          shrSH: (e, t, r) => e >>> r,
          shrSL: (e, t, r) => (e << (32 - r)) | (t >>> r),
          rotrSH: (e, t, r) => (e >>> r) | (t << (32 - r)),
          rotrSL: (e, t, r) => (e << (32 - r)) | (t >>> r),
          rotrBH: (e, t, r) => (e << (64 - r)) | (t >>> (r - 32)),
          rotrBL: (e, t, r) => (e >>> (r - 32)) | (t << (64 - r)),
          add: function (e, t, r, i) {
            let s = (t >>> 0) + (i >>> 0);
            return { h: (e + r + ((s / 0x100000000) | 0)) | 0, l: 0 | s };
          },
          add3L: (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0),
          add3H: (e, t, r, i) => (t + r + i + ((e / 0x100000000) | 0)) | 0,
          add4L: (e, t, r, i) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0),
          add4H: (e, t, r, i, s) =>
            (t + r + i + s + ((e / 0x100000000) | 0)) | 0,
          add5H: (e, t, r, i, s, n) =>
            (t + r + i + s + n + ((e / 0x100000000) | 0)) | 0,
          add5L: (e, t, r, i, s) =>
            (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0) + (s >>> 0),
        },
        [eU, eL] = eD.split(
          [
            "0x428a2f98d728ae22",
            "0x7137449123ef65cd",
            "0xb5c0fbcfec4d3b2f",
            "0xe9b5dba58189dbbc",
            "0x3956c25bf348b538",
            "0x59f111f1b605d019",
            "0x923f82a4af194f9b",
            "0xab1c5ed5da6d8118",
            "0xd807aa98a3030242",
            "0x12835b0145706fbe",
            "0x243185be4ee4b28c",
            "0x550c7dc3d5ffb4e2",
            "0x72be5d74f27b896f",
            "0x80deb1fe3b1696b1",
            "0x9bdc06a725c71235",
            "0xc19bf174cf692694",
            "0xe49b69c19ef14ad2",
            "0xefbe4786384f25e3",
            "0x0fc19dc68b8cd5b5",
            "0x240ca1cc77ac9c65",
            "0x2de92c6f592b0275",
            "0x4a7484aa6ea6e483",
            "0x5cb0a9dcbd41fbd4",
            "0x76f988da831153b5",
            "0x983e5152ee66dfab",
            "0xa831c66d2db43210",
            "0xb00327c898fb213f",
            "0xbf597fc7beef0ee4",
            "0xc6e00bf33da88fc2",
            "0xd5a79147930aa725",
            "0x06ca6351e003826f",
            "0x142929670a0e6e70",
            "0x27b70a8546d22ffc",
            "0x2e1b21385c26c926",
            "0x4d2c6dfc5ac42aed",
            "0x53380d139d95b3df",
            "0x650a73548baf63de",
            "0x766a0abb3c77b2a8",
            "0x81c2c92e47edaee6",
            "0x92722c851482353b",
            "0xa2bfe8a14cf10364",
            "0xa81a664bbc423001",
            "0xc24b8b70d0f89791",
            "0xc76c51a30654be30",
            "0xd192e819d6ef5218",
            "0xd69906245565a910",
            "0xf40e35855771202a",
            "0x106aa07032bbd1b8",
            "0x19a4c116b8d2d0c8",
            "0x1e376c085141ab53",
            "0x2748774cdf8eeb99",
            "0x34b0bcb5e19b48a8",
            "0x391c0cb3c5c95a63",
            "0x4ed8aa4ae3418acb",
            "0x5b9cca4f7763e373",
            "0x682e6ff3d6b2b8a3",
            "0x748f82ee5defb2fc",
            "0x78a5636f43172f60",
            "0x84c87814a1f0ab72",
            "0x8cc702081a6439ec",
            "0x90befffa23631e28",
            "0xa4506cebde82bde9",
            "0xbef9a3f7b2c67915",
            "0xc67178f2e372532b",
            "0xca273eceea26619c",
            "0xd186b8c721c0c207",
            "0xeada7dd6cde0eb1e",
            "0xf57d4f7fee6ed178",
            "0x06f067aa72176fba",
            "0x0a637dc5a2c898a6",
            "0x113f9804bef90dae",
            "0x1b710b35131c471b",
            "0x28db77f523047d84",
            "0x32caab7b40c72493",
            "0x3c9ebe0a15c9bebc",
            "0x431d67c49c100d4c",
            "0x4cc5d4becb3e42b6",
            "0x597f299cfc657e2a",
            "0x5fcb6fab3ad6faec",
            "0x6c44198c4a475817",
          ].map((e) => BigInt(e))
        ),
        eM = new Uint32Array(80),
        ej = new Uint32Array(80);
      class e$ extends eP {
        constructor() {
          super(128, 64, 16, !1),
            (this.Ah = 0x6a09e667),
            (this.Al = -0xc4336f8),
            (this.Bh = -0x4498517b),
            (this.Bl = -0x7b3558c5),
            (this.Ch = 0x3c6ef372),
            (this.Cl = -0x16b07d5),
            (this.Dh = -0x5ab00ac6),
            (this.Dl = 0x5f1d36f1),
            (this.Eh = 0x510e527f),
            (this.El = -0x52197d2f),
            (this.Fh = -0x64fa9774),
            (this.Fl = 0x2b3e6c1f),
            (this.Gh = 0x1f83d9ab),
            (this.Gl = -0x4be4295),
            (this.Hh = 0x5be0cd19),
            (this.Hl = 0x137e2179);
        }
        get() {
          let {
            Ah: e,
            Al: t,
            Bh: r,
            Bl: i,
            Ch: s,
            Cl: n,
            Dh: a,
            Dl: o,
            Eh: c,
            El: l,
            Fh: u,
            Fl: d,
            Gh: h,
            Gl: p,
            Hh: f,
            Hl: g,
          } = this;
          return [e, t, r, i, s, n, a, o, c, l, u, d, h, p, f, g];
        }
        set(e, t, r, i, s, n, a, o, c, l, u, d, h, p, f, g) {
          (this.Ah = 0 | e),
            (this.Al = 0 | t),
            (this.Bh = 0 | r),
            (this.Bl = 0 | i),
            (this.Ch = 0 | s),
            (this.Cl = 0 | n),
            (this.Dh = 0 | a),
            (this.Dl = 0 | o),
            (this.Eh = 0 | c),
            (this.El = 0 | l),
            (this.Fh = 0 | u),
            (this.Fl = 0 | d),
            (this.Gh = 0 | h),
            (this.Gl = 0 | p),
            (this.Hh = 0 | f),
            (this.Hl = 0 | g);
        }
        process(e, t) {
          for (let r = 0; r < 16; r++, t += 4)
            (eM[r] = e.getUint32(t)), (ej[r] = e.getUint32((t += 4)));
          for (let e = 16; e < 80; e++) {
            let t = 0 | eM[e - 15],
              r = 0 | ej[e - 15],
              i = eD.rotrSH(t, r, 1) ^ eD.rotrSH(t, r, 8) ^ eD.shrSH(t, r, 7),
              s = eD.rotrSL(t, r, 1) ^ eD.rotrSL(t, r, 8) ^ eD.shrSL(t, r, 7),
              n = 0 | eM[e - 2],
              a = 0 | ej[e - 2],
              o = eD.rotrSH(n, a, 19) ^ eD.rotrBH(n, a, 61) ^ eD.shrSH(n, a, 6),
              c = eD.rotrSL(n, a, 19) ^ eD.rotrBL(n, a, 61) ^ eD.shrSL(n, a, 6),
              l = eD.add4L(s, c, ej[e - 7], ej[e - 16]),
              u = eD.add4H(l, i, o, eM[e - 7], eM[e - 16]);
            (eM[e] = 0 | u), (ej[e] = 0 | l);
          }
          let {
            Ah: r,
            Al: i,
            Bh: s,
            Bl: n,
            Ch: a,
            Cl: o,
            Dh: c,
            Dl: l,
            Eh: u,
            El: d,
            Fh: h,
            Fl: p,
            Gh: f,
            Gl: g,
            Hh: m,
            Hl: y,
          } = this;
          for (let e = 0; e < 80; e++) {
            let t =
                eD.rotrSH(u, d, 14) ^ eD.rotrSH(u, d, 18) ^ eD.rotrBH(u, d, 41),
              b =
                eD.rotrSL(u, d, 14) ^ eD.rotrSL(u, d, 18) ^ eD.rotrBL(u, d, 41),
              w = (u & h) ^ (~u & f),
              v = (d & p) ^ (~d & g),
              E = eD.add5L(y, b, v, eL[e], ej[e]),
              _ = eD.add5H(E, m, t, w, eU[e], eM[e]),
              C = 0 | E,
              A =
                eD.rotrSH(r, i, 28) ^ eD.rotrBH(r, i, 34) ^ eD.rotrBH(r, i, 39),
              I =
                eD.rotrSL(r, i, 28) ^ eD.rotrBL(r, i, 34) ^ eD.rotrBL(r, i, 39),
              S = (r & s) ^ (r & a) ^ (s & a),
              N = (i & n) ^ (i & o) ^ (n & o);
            (m = 0 | f),
              (y = 0 | g),
              (f = 0 | h),
              (g = 0 | p),
              (h = 0 | u),
              (p = 0 | d),
              ({ h: u, l: d } = eD.add(0 | c, 0 | l, 0 | _, 0 | C)),
              (c = 0 | a),
              (l = 0 | o),
              (a = 0 | s),
              (o = 0 | n),
              (s = 0 | r),
              (n = 0 | i);
            let T = eD.add3L(C, I, N);
            (r = eD.add3H(T, _, A, S)), (i = 0 | T);
          }
          ({ h: r, l: i } = eD.add(0 | this.Ah, 0 | this.Al, 0 | r, 0 | i)),
            ({ h: s, l: n } = eD.add(0 | this.Bh, 0 | this.Bl, 0 | s, 0 | n)),
            ({ h: a, l: o } = eD.add(0 | this.Ch, 0 | this.Cl, 0 | a, 0 | o)),
            ({ h: c, l: l } = eD.add(0 | this.Dh, 0 | this.Dl, 0 | c, 0 | l)),
            ({ h: u, l: d } = eD.add(0 | this.Eh, 0 | this.El, 0 | u, 0 | d)),
            ({ h: h, l: p } = eD.add(0 | this.Fh, 0 | this.Fl, 0 | h, 0 | p)),
            ({ h: f, l: g } = eD.add(0 | this.Gh, 0 | this.Gl, 0 | f, 0 | g)),
            ({ h: m, l: y } = eD.add(0 | this.Hh, 0 | this.Hl, 0 | m, 0 | y)),
            this.set(r, i, s, n, a, o, c, l, u, d, h, p, f, g, m, y);
        }
        roundClean() {
          eM.fill(0), ej.fill(0);
        }
        destroy() {
          this.buffer.fill(0),
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      }
      let eB = (function (e) {
          let t = (t) => e().update(eT(t)).digest(),
            r = e();
          return (
            (t.outputLen = r.outputLen),
            (t.blockLen = r.blockLen),
            (t.create = () => e()),
            t
          );
        })(() => new e$()),
        eF = BigInt(0),
        eW = BigInt(1),
        eq = BigInt(2);
      function eH(e) {
        return (
          e instanceof Uint8Array ||
          (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
        );
      }
      function ez(e) {
        if (!eH(e)) throw Error("Uint8Array expected");
      }
      function eV(e, t) {
        if ("boolean" != typeof t)
          throw Error(e + " boolean expected, got " + t);
      }
      let eK = Array.from({ length: 256 }, (e, t) =>
        t.toString(16).padStart(2, "0")
      );
      function eG(e) {
        ez(e);
        let t = "";
        for (let r = 0; r < e.length; r++) t += eK[e[r]];
        return t;
      }
      function eY(e) {
        if ("string" != typeof e)
          throw Error("hex string expected, got " + typeof e);
        return "" === e ? eF : BigInt("0x" + e);
      }
      let eZ = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      function eJ(e) {
        return e >= eZ._0 && e <= eZ._9
          ? e - eZ._0
          : e >= eZ.A && e <= eZ.F
          ? e - (eZ.A - 10)
          : e >= eZ.a && e <= eZ.f
          ? e - (eZ.a - 10)
          : void 0;
      }
      function eX(e) {
        if ("string" != typeof e)
          throw Error("hex string expected, got " + typeof e);
        let t = e.length,
          r = t / 2;
        if (t % 2)
          throw Error("hex string expected, got unpadded hex of length " + t);
        let i = new Uint8Array(r);
        for (let t = 0, s = 0; t < r; t++, s += 2) {
          let r = eJ(e.charCodeAt(s)),
            n = eJ(e.charCodeAt(s + 1));
          if (void 0 === r || void 0 === n)
            throw Error(
              'hex string expected, got non-hex character "' +
                (e[s] + e[s + 1]) +
                '" at index ' +
                s
            );
          i[t] = 16 * r + n;
        }
        return i;
      }
      function eQ(e) {
        return ez(e), eY(eG(Uint8Array.from(e).reverse()));
      }
      function e0(e, t) {
        return eX(e.toString(16).padStart(2 * t, "0"));
      }
      function e1(e, t) {
        return e0(e, t).reverse();
      }
      function e2(e, t, r) {
        let i;
        if ("string" == typeof t)
          try {
            i = eX(t);
          } catch (t) {
            throw Error(e + " must be hex string or Uint8Array, cause: " + t);
          }
        else if (eH(t)) i = Uint8Array.from(t);
        else throw Error(e + " must be hex string or Uint8Array");
        let s = i.length;
        if ("number" == typeof r && s !== r)
          throw Error(e + " of length " + r + " expected, got " + s);
        return i;
      }
      function e3(...e) {
        let t = 0;
        for (let r = 0; r < e.length; r++) {
          let i = e[r];
          ez(i), (t += i.length);
        }
        let r = new Uint8Array(t);
        for (let t = 0, i = 0; t < e.length; t++) {
          let s = e[t];
          r.set(s, i), (i += s.length);
        }
        return r;
      }
      let e5 = (e) => "bigint" == typeof e && eF <= e;
      function e8(e, t, r, i) {
        if (!(e5(t) && e5(r) && e5(i)) || !(r <= t) || !(t < i))
          throw Error(
            "expected valid " + e + ": " + r + " <= n < " + i + ", got " + t
          );
      }
      let e6 = (e) => (eq << BigInt(e - 1)) - eW,
        e4 = {
          bigint: (e) => "bigint" == typeof e,
          function: (e) => "function" == typeof e,
          boolean: (e) => "boolean" == typeof e,
          string: (e) => "string" == typeof e,
          stringOrUint8Array: (e) => "string" == typeof e || eH(e),
          isSafeInteger: (e) => Number.isSafeInteger(e),
          array: (e) => Array.isArray(e),
          field: (e, t) => t.Fp.isValid(e),
          hash: (e) =>
            "function" == typeof e && Number.isSafeInteger(e.outputLen),
        };
      function e9(e, t, r = {}) {
        let i = (t, r, i) => {
          let s = e4[r];
          if ("function" != typeof s) throw Error("invalid validator function");
          let n = e[t];
          if (!(i && void 0 === n) && !s(n, e))
            throw Error(
              "param " + String(t) + " is invalid. Expected " + r + ", got " + n
            );
        };
        for (let [e, r] of Object.entries(t)) i(e, r, !1);
        for (let [e, t] of Object.entries(r)) i(e, t, !0);
        return e;
      }
      function e7(e) {
        let t = new WeakMap();
        return (r, ...i) => {
          let s = t.get(r);
          if (void 0 !== s) return s;
          let n = e(r, ...i);
          return t.set(r, n), n;
        };
      }
      let te = BigInt(0),
        tt = BigInt(1),
        tr = BigInt(2),
        ti = BigInt(3),
        ts = BigInt(4),
        tn = BigInt(5),
        ta = BigInt(8);
      function to(e, t) {
        let r = e % t;
        return r >= te ? r : t + r;
      }
      function tc(e, t, r) {
        let i = e;
        for (; t-- > te; ) (i *= i), (i %= r);
        return i;
      }
      function tl(e, t) {
        if (e === te) throw Error("invert: expected non-zero number");
        if (t <= te) throw Error("invert: expected positive modulus, got " + t);
        let r = to(e, t),
          i = t,
          s = te,
          n = tt;
        for (; r !== te; ) {
          let e = i / r,
            t = i % r,
            a = s - n * e;
          (i = r), (r = t), (s = n), (n = a);
        }
        if (i !== tt) throw Error("invert: does not exist");
        return to(s, t);
      }
      let tu = (e, t) => (to(e, t) & tt) === tt,
        td = [
          "create",
          "isValid",
          "is0",
          "neg",
          "inv",
          "sqrt",
          "sqr",
          "eql",
          "add",
          "sub",
          "mul",
          "pow",
          "div",
          "addN",
          "subN",
          "mulN",
          "sqrN",
        ];
      function th(e, t) {
        let r = void 0 !== t ? t : e.toString(2).length,
          i = Math.ceil(r / 8);
        return { nBitLength: r, nByteLength: i };
      }
      function tp(e, t, r = !1, i = {}) {
        let s;
        if (e <= te) throw Error("invalid field: expected ORDER > 0, got " + e);
        let { nBitLength: n, nByteLength: a } = th(e, t);
        if (a > 2048)
          throw Error("invalid field: expected ORDER of <= 2048 bytes");
        let o = Object.freeze({
          ORDER: e,
          isLE: r,
          BITS: n,
          BYTES: a,
          MASK: e6(n),
          ZERO: te,
          ONE: tt,
          create: (t) => to(t, e),
          isValid: (t) => {
            if ("bigint" != typeof t)
              throw Error(
                "invalid field element: expected bigint, got " + typeof t
              );
            return te <= t && t < e;
          },
          is0: (e) => e === te,
          isOdd: (e) => (e & tt) === tt,
          neg: (t) => to(-t, e),
          eql: (e, t) => e === t,
          sqr: (t) => to(t * t, e),
          add: (t, r) => to(t + r, e),
          sub: (t, r) => to(t - r, e),
          mul: (t, r) => to(t * r, e),
          pow: (e, t) =>
            (function (e, t, r) {
              if (r < te)
                throw Error("invalid exponent, negatives unsupported");
              if (r === te) return e.ONE;
              if (r === tt) return t;
              let i = e.ONE,
                s = t;
              for (; r > te; )
                r & tt && (i = e.mul(i, s)), (s = e.sqr(s)), (r >>= tt);
              return i;
            })(o, e, t),
          div: (t, r) => to(t * tl(r, e), e),
          sqrN: (e) => e * e,
          addN: (e, t) => e + t,
          subN: (e, t) => e - t,
          mulN: (e, t) => e * t,
          inv: (t) => tl(t, e),
          sqrt:
            i.sqrt ||
            ((t) => (
              s ||
                (s = (function (e) {
                  if (e % ts === ti) {
                    let t = (e + tt) / ts;
                    return function (e, r) {
                      let i = e.pow(r, t);
                      if (!e.eql(e.sqr(i), r))
                        throw Error("Cannot find square root");
                      return i;
                    };
                  }
                  if (e % ta === tn) {
                    let t = (e - tn) / ta;
                    return function (e, r) {
                      let i = e.mul(r, tr),
                        s = e.pow(i, t),
                        n = e.mul(r, s),
                        a = e.mul(e.mul(n, tr), s),
                        o = e.mul(n, e.sub(a, e.ONE));
                      if (!e.eql(e.sqr(o), r))
                        throw Error("Cannot find square root");
                      return o;
                    };
                  }
                  return (function (e) {
                    let t,
                      r,
                      i,
                      s = (e - tt) / tr;
                    for (t = e - tt, r = 0; t % tr === te; t /= tr, r++);
                    for (
                      i = tr;
                      i < e &&
                      (function (e, t, r) {
                        if (t < te)
                          throw Error(
                            "invalid exponent, negatives unsupported"
                          );
                        if (r <= te) throw Error("invalid modulus");
                        if (r === tt) return te;
                        let i = tt;
                        for (; t > te; )
                          t & tt && (i = (i * e) % r),
                            (e = (e * e) % r),
                            (t >>= tt);
                        return i;
                      })(i, s, e) !==
                        e - tt;
                      i++
                    )
                      if (i > 1e3)
                        throw Error(
                          "Cannot find square root: likely non-prime P"
                        );
                    if (1 === r) {
                      let t = (e + tt) / ts;
                      return function (e, r) {
                        let i = e.pow(r, t);
                        if (!e.eql(e.sqr(i), r))
                          throw Error("Cannot find square root");
                        return i;
                      };
                    }
                    let n = (t + tt) / tr;
                    return function (e, a) {
                      if (e.pow(a, s) === e.neg(e.ONE))
                        throw Error("Cannot find square root");
                      let o = r,
                        c = e.pow(e.mul(e.ONE, i), t),
                        l = e.pow(a, n),
                        u = e.pow(a, t);
                      for (; !e.eql(u, e.ONE); ) {
                        if (e.eql(u, e.ZERO)) return e.ZERO;
                        let t = 1;
                        for (let r = e.sqr(u); t < o && !e.eql(r, e.ONE); t++)
                          r = e.sqr(r);
                        let r = e.pow(c, tt << BigInt(o - t - 1));
                        (c = e.sqr(r)),
                          (l = e.mul(l, r)),
                          (u = e.mul(u, c)),
                          (o = t);
                      }
                      return l;
                    };
                  })(e);
                })(e)),
              s(o, t)
            )),
          invertBatch: (e) =>
            (function (e, t) {
              let r = Array(t.length),
                i = t.reduce(
                  (t, i, s) => (e.is0(i) ? t : ((r[s] = t), e.mul(t, i))),
                  e.ONE
                ),
                s = e.inv(i);
              return (
                t.reduceRight(
                  (t, i, s) =>
                    e.is0(i) ? t : ((r[s] = e.mul(t, r[s])), e.mul(t, i)),
                  s
                ),
                r
              );
            })(o, e),
          cmov: (e, t, r) => (r ? t : e),
          toBytes: (e) => (r ? e1(e, a) : e0(e, a)),
          fromBytes: (e) => {
            if (e.length !== a)
              throw Error(
                "Field.fromBytes: expected " + a + " bytes, got " + e.length
              );
            return r ? eQ(e) : eY(eG(e));
          },
        });
        return Object.freeze(o);
      }
      let tf = BigInt(0),
        tg = BigInt(1);
      function tm(e, t) {
        let r = t.negate();
        return e ? r : t;
      }
      function ty(e, t) {
        if (!Number.isSafeInteger(e) || e <= 0 || e > t)
          throw Error(
            "invalid window size, expected [1.." + t + "], got W=" + e
          );
      }
      function tb(e, t) {
        return (
          ty(e, t), { windows: Math.ceil(t / e) + 1, windowSize: 2 ** (e - 1) }
        );
      }
      let tw = new WeakMap(),
        tv = new WeakMap();
      function tE(e) {
        return tv.get(e) || 1;
      }
      let t_ = BigInt(0),
        tC = BigInt(1),
        tA = BigInt(2),
        tI = BigInt(8),
        tS = { zip215: !0 };
      BigInt(0), BigInt(1);
      let tN = BigInt(
          "57896044618658097711785492504343953926634992332820282019728792003956564819949"
        ),
        tT = BigInt(
          "19681161376707505956807079304988542015446066515923890162744021073123829784752"
        );
      BigInt(0);
      let tO = BigInt(1),
        tx = BigInt(2);
      BigInt(3);
      let tP = BigInt(5),
        tR = BigInt(8),
        tk = tp(tN, void 0, !0),
        tD = (function (e) {
          var t;
          let r = (function (e) {
              let t =
                (e9(
                  e.Fp,
                  td.reduce((e, t) => ((e[t] = "function"), e), {
                    ORDER: "bigint",
                    MASK: "bigint",
                    BYTES: "isSafeInteger",
                    BITS: "isSafeInteger",
                  })
                ),
                e9(
                  e,
                  { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
                  { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
                ),
                Object.freeze({
                  ...th(e.n, e.nBitLength),
                  ...e,
                  p: e.Fp.ORDER,
                }));
              return (
                e9(
                  e,
                  {
                    hash: "function",
                    a: "bigint",
                    d: "bigint",
                    randomBytes: "function",
                  },
                  {
                    adjustScalarBytes: "function",
                    domain: "function",
                    uvRatio: "function",
                    mapToCurve: "function",
                  }
                ),
                Object.freeze({ ...t })
              );
            })(e),
            {
              Fp: i,
              n: s,
              prehash: n,
              hash: a,
              randomBytes: o,
              nByteLength: c,
              h: l,
            } = r,
            u = tA << (BigInt(8 * c) - tC),
            d = i.create,
            h = tp(r.n, r.nBitLength),
            p =
              r.uvRatio ||
              ((e, t) => {
                try {
                  return { isValid: !0, value: i.sqrt(e * i.inv(t)) };
                } catch {
                  return { isValid: !1, value: t_ };
                }
              }),
            f = r.adjustScalarBytes || ((e) => e),
            g =
              r.domain ||
              ((e, t, r) => {
                if ((eV("phflag", r), t.length || r))
                  throw Error("Contexts/pre-hash are not supported");
                return e;
              });
          function m(e, t) {
            e8("coordinate " + e, t, t_, u);
          }
          function y(e) {
            if (!(e instanceof v)) throw Error("ExtendedPoint expected");
          }
          let b = e7((e, t) => {
              let { ex: r, ey: s, ez: n } = e,
                a = e.is0();
              null == t && (t = a ? tI : i.inv(n));
              let o = d(r * t),
                c = d(s * t),
                l = d(n * t);
              if (a) return { x: t_, y: tC };
              if (l !== tC) throw Error("invZ was invalid");
              return { x: o, y: c };
            }),
            w = e7((e) => {
              let { a: t, d: i } = r;
              if (e.is0()) throw Error("bad point: ZERO");
              let { ex: s, ey: n, ez: a, et: o } = e,
                c = d(s * s),
                l = d(n * n),
                u = d(a * a),
                h = d(u * u),
                p = d(c * t);
              if (d(u * d(p + l)) !== d(h + d(i * d(c * l))))
                throw Error("bad point: equation left != right (1)");
              if (d(s * n) !== d(a * o))
                throw Error("bad point: equation left != right (2)");
              return !0;
            });
          class v {
            constructor(e, t, r, i) {
              (this.ex = e),
                (this.ey = t),
                (this.ez = r),
                (this.et = i),
                m("x", e),
                m("y", t),
                m("z", r),
                m("t", i),
                Object.freeze(this);
            }
            get x() {
              return this.toAffine().x;
            }
            get y() {
              return this.toAffine().y;
            }
            static fromAffine(e) {
              if (e instanceof v) throw Error("extended point not allowed");
              let { x: t, y: r } = e || {};
              return m("x", t), m("y", r), new v(t, r, tC, d(t * r));
            }
            static normalizeZ(e) {
              let t = i.invertBatch(e.map((e) => e.ez));
              return e.map((e, r) => e.toAffine(t[r])).map(v.fromAffine);
            }
            static msm(e, t) {
              return (function (e, t, r, i) {
                if (
                  ((function (e, t) {
                    if (!Array.isArray(e)) throw Error("array expected");
                    e.forEach((e, r) => {
                      if (!(e instanceof t))
                        throw Error("invalid point at index " + r);
                    });
                  })(r, e),
                  (function (e, t) {
                    if (!Array.isArray(e))
                      throw Error("array of scalars expected");
                    e.forEach((e, r) => {
                      if (!t.isValid(e))
                        throw Error("invalid scalar at index " + r);
                    });
                  })(i, t),
                  r.length !== i.length)
                )
                  throw Error(
                    "arrays of points and scalars must have equal length"
                  );
                let s = e.ZERO,
                  n = (function (e) {
                    let t;
                    for (t = 0; e > eF; e >>= eW, t += 1);
                    return t;
                  })(BigInt(r.length)),
                  a = n > 12 ? n - 3 : n > 4 ? n - 2 : n ? 2 : 1,
                  o = (1 << a) - 1,
                  c = Array(o + 1).fill(s),
                  l = Math.floor((t.BITS - 1) / a) * a,
                  u = s;
                for (let e = l; e >= 0; e -= a) {
                  c.fill(s);
                  for (let t = 0; t < i.length; t++) {
                    let s = Number((i[t] >> BigInt(e)) & BigInt(o));
                    c[s] = c[s].add(r[t]);
                  }
                  let t = s;
                  for (let e = c.length - 1, r = s; e > 0; e--)
                    (r = r.add(c[e])), (t = t.add(r));
                  if (((u = u.add(t)), 0 !== e))
                    for (let e = 0; e < a; e++) u = u.double();
                }
                return u;
              })(v, h, e, t);
            }
            _setWindowSize(e) {
              C.setWindowSize(this, e);
            }
            assertValidity() {
              w(this);
            }
            equals(e) {
              y(e);
              let { ex: t, ey: r, ez: i } = this,
                { ex: s, ey: n, ez: a } = e,
                o = d(t * a),
                c = d(s * i),
                l = d(r * a),
                u = d(n * i);
              return o === c && l === u;
            }
            is0() {
              return this.equals(v.ZERO);
            }
            negate() {
              return new v(d(-this.ex), this.ey, this.ez, d(-this.et));
            }
            double() {
              let { a: e } = r,
                { ex: t, ey: i, ez: s } = this,
                n = d(t * t),
                a = d(i * i),
                o = d(tA * d(s * s)),
                c = d(e * n),
                l = t + i,
                u = d(d(l * l) - n - a),
                h = c + a,
                p = h - o,
                f = c - a,
                g = d(u * p),
                m = d(h * f),
                y = d(u * f);
              return new v(g, m, d(p * h), y);
            }
            add(e) {
              y(e);
              let { a: t, d: i } = r,
                { ex: s, ey: n, ez: a, et: o } = this,
                { ex: c, ey: l, ez: u, et: h } = e;
              if (t === BigInt(-1)) {
                let e = d((n - s) * (l + c)),
                  t = d((n + s) * (l - c)),
                  r = d(t - e);
                if (r === t_) return this.double();
                let i = d(a * tA * h),
                  p = d(o * tA * u),
                  f = p + i,
                  g = t + e,
                  m = p - i,
                  y = d(f * r),
                  b = d(g * m),
                  w = d(f * m);
                return new v(y, b, d(r * g), w);
              }
              let p = d(s * c),
                f = d(n * l),
                g = d(o * i * h),
                m = d(a * u),
                b = d((s + n) * (c + l) - p - f),
                w = m - g,
                E = m + g,
                _ = d(f - t * p),
                C = d(b * w),
                A = d(E * _),
                I = d(b * _);
              return new v(C, A, d(w * E), I);
            }
            subtract(e) {
              return this.add(e.negate());
            }
            wNAF(e) {
              return C.wNAFCached(this, e, v.normalizeZ);
            }
            multiply(e) {
              e8("scalar", e, tC, s);
              let { p: t, f: r } = this.wNAF(e);
              return v.normalizeZ([t, r])[0];
            }
            multiplyUnsafe(e, t = v.ZERO) {
              return (
                e8("scalar", e, t_, s),
                e === t_
                  ? _
                  : this.is0() || e === tC
                  ? this
                  : C.wNAFCachedUnsafe(this, e, v.normalizeZ, t)
              );
            }
            isSmallOrder() {
              return this.multiplyUnsafe(l).is0();
            }
            isTorsionFree() {
              return C.unsafeLadder(this, s).is0();
            }
            toAffine(e) {
              return b(this, e);
            }
            clearCofactor() {
              let { h: e } = r;
              return e === tC ? this : this.multiplyUnsafe(e);
            }
            static fromHex(e, t = !1) {
              let { d: s, a: n } = r,
                a = i.BYTES;
              (e = e2("pointHex", e, a)), eV("zip215", t);
              let o = e.slice(),
                c = e[a - 1];
              o[a - 1] = -129 & c;
              let l = eQ(o);
              e8("pointHex.y", l, t_, t ? u : i.ORDER);
              let h = d(l * l),
                { isValid: f, value: g } = p(d(h - tC), d(s * h - n));
              if (!f) throw Error("Point.fromHex: invalid y coordinate");
              let m = (g & tC) === tC,
                y = (128 & c) != 0;
              if (!t && g === t_ && y)
                throw Error("Point.fromHex: x=0 and x_0=1");
              return y !== m && (g = d(-g)), v.fromAffine({ x: g, y: l });
            }
            static fromPrivateKey(e) {
              return A(e).point;
            }
            toRawBytes() {
              let { x: e, y: t } = this.toAffine(),
                r = e1(t, i.BYTES);
              return (r[r.length - 1] |= e & tC ? 128 : 0), r;
            }
            toHex() {
              return eG(this.toRawBytes());
            }
          }
          (v.BASE = new v(r.Gx, r.Gy, tC, d(r.Gx * r.Gy))),
            (v.ZERO = new v(t_, tC, tC, t_));
          let { BASE: E, ZERO: _ } = v,
            C =
              ((t = 8 * c),
              {
                constTimeNegate: tm,
                hasPrecomputes: (e) => 1 !== tE(e),
                unsafeLadder(e, t, r = v.ZERO) {
                  let i = e;
                  for (; t > tf; )
                    t & tg && (r = r.add(i)), (i = i.double()), (t >>= tg);
                  return r;
                },
                precomputeWindow(e, r) {
                  let { windows: i, windowSize: s } = tb(r, t),
                    n = [],
                    a = e,
                    o = a;
                  for (let e = 0; e < i; e++) {
                    (o = a), n.push(o);
                    for (let e = 1; e < s; e++) (o = o.add(a)), n.push(o);
                    a = o.double();
                  }
                  return n;
                },
                wNAF(e, r, i) {
                  let { windows: s, windowSize: n } = tb(e, t),
                    a = v.ZERO,
                    o = v.BASE,
                    c = BigInt(2 ** e - 1),
                    l = 2 ** e,
                    u = BigInt(e);
                  for (let e = 0; e < s; e++) {
                    let t = e * n,
                      s = Number(i & c);
                    (i >>= u), s > n && ((s -= l), (i += tg));
                    let d = t + Math.abs(s) - 1,
                      h = e % 2 != 0,
                      p = s < 0;
                    0 === s
                      ? (o = o.add(tm(h, r[t])))
                      : (a = a.add(tm(p, r[d])));
                  }
                  return { p: a, f: o };
                },
                wNAFUnsafe(e, r, i, s = v.ZERO) {
                  let { windows: n, windowSize: a } = tb(e, t),
                    o = BigInt(2 ** e - 1),
                    c = 2 ** e,
                    l = BigInt(e);
                  for (let e = 0; e < n; e++) {
                    let t = e * a;
                    if (i === tf) break;
                    let n = Number(i & o);
                    if (((i >>= l), n > a && ((n -= c), (i += tg)), 0 === n))
                      continue;
                    let u = r[t + Math.abs(n) - 1];
                    n < 0 && (u = u.negate()), (s = s.add(u));
                  }
                  return s;
                },
                getPrecomputes(e, t, r) {
                  let i = tw.get(t);
                  return (
                    i ||
                      ((i = this.precomputeWindow(t, e)),
                      1 !== e && tw.set(t, r(i))),
                    i
                  );
                },
                wNAFCached(e, t, r) {
                  let i = tE(e);
                  return this.wNAF(i, this.getPrecomputes(i, e, r), t);
                },
                wNAFCachedUnsafe(e, t, r, i) {
                  let s = tE(e);
                  return 1 === s
                    ? this.unsafeLadder(e, t, i)
                    : this.wNAFUnsafe(s, this.getPrecomputes(s, e, r), t, i);
                },
                setWindowSize(e, r) {
                  ty(r, t), tv.set(e, r), tw.delete(e);
                },
              });
          function A(e) {
            let t = i.BYTES;
            e = e2("private key", e, t);
            let r = e2("hashed private key", a(e), 2 * t),
              n = f(r.slice(0, t)),
              o = r.slice(t, 2 * t),
              c = to(eQ(n), s),
              l = E.multiply(c),
              u = l.toRawBytes();
            return { head: n, prefix: o, scalar: c, point: l, pointBytes: u };
          }
          function I(e = new Uint8Array(), ...t) {
            return to(eQ(a(g(e3(...t), e2("context", e), !!n))), s);
          }
          return (
            E._setWindowSize(8),
            {
              CURVE: r,
              getPublicKey: function (e) {
                return A(e).pointBytes;
              },
              sign: function (e, t, r = {}) {
                (e = e2("message", e)), n && (e = n(e));
                let { prefix: a, scalar: o, pointBytes: c } = A(t),
                  l = I(r.context, a, e),
                  u = E.multiply(l).toRawBytes(),
                  d = to(l + I(r.context, u, c, e) * o, s);
                return (
                  e8("signature.s", d, t_, s),
                  e2("result", e3(u, e1(d, i.BYTES)), 2 * i.BYTES)
                );
              },
              verify: function (e, t, r, s = tS) {
                let a,
                  o,
                  c,
                  { context: l, zip215: u } = s,
                  d = i.BYTES;
                (e = e2("signature", e, 2 * d)),
                  (t = e2("message", t)),
                  (r = e2("publicKey", r, d)),
                  void 0 !== u && eV("zip215", u),
                  n && (t = n(t));
                let h = eQ(e.slice(d, 2 * d));
                try {
                  (a = v.fromHex(r, u)),
                    (o = v.fromHex(e.slice(0, d), u)),
                    (c = E.multiplyUnsafe(h));
                } catch {
                  return !1;
                }
                if (!u && a.isSmallOrder()) return !1;
                let p = I(l, o.toRawBytes(), a.toRawBytes(), t);
                return o
                  .add(a.multiplyUnsafe(p))
                  .subtract(c)
                  .clearCofactor()
                  .equals(v.ZERO);
              },
              ExtendedPoint: v,
              utils: {
                getExtendedPublicKey: A,
                randomPrivateKey: () => o(i.BYTES),
                precompute: (e = 8, t = v.BASE) => (
                  t._setWindowSize(e), t.multiply(BigInt(3)), t
                ),
              },
            }
          );
        })({
          a: BigInt(-1),
          d: BigInt(
            "37095705934669439343138083508754565189542113879843219016388785533085940283555"
          ),
          Fp: tk,
          n: BigInt(
            "7237005577332262213973186563042994240857116359379907606001950938285454250989"
          ),
          h: tR,
          Gx: BigInt(
            "15112221349535400772501151409588531511454012693041857206046113283949847762202"
          ),
          Gy: BigInt(
            "46316835694926478169428394003475163141307993866256225615783033603165251855960"
          ),
          hash: eB,
          randomBytes: ex,
          adjustScalarBytes: function (e) {
            return (e[0] &= 248), (e[31] &= 127), (e[31] |= 64), e;
          },
          uvRatio: function (e, t) {
            let r = to(t * t * t, tN),
              i = (function (e) {
                let t = BigInt(10),
                  r = BigInt(20),
                  i = BigInt(40),
                  s = BigInt(80),
                  n = (((e * e) % tN) * e) % tN,
                  a = (tc(n, tx, tN) * n) % tN,
                  o = (tc(a, tO, tN) * e) % tN,
                  c = (tc(o, tP, tN) * o) % tN,
                  l = (tc(c, t, tN) * c) % tN,
                  u = (tc(l, r, tN) * l) % tN,
                  d = (tc(u, i, tN) * u) % tN,
                  h = (tc(d, s, tN) * d) % tN,
                  p = (tc(h, s, tN) * d) % tN,
                  f = (tc(p, t, tN) * c) % tN;
                return { pow_p_5_8: (tc(f, tx, tN) * e) % tN, b2: n };
              })(e * to(r * r * t, tN)).pow_p_5_8,
              s = to(e * r * i, tN),
              n = to(t * s * s, tN),
              a = s,
              o = to(s * tT, tN),
              c = n === e,
              l = n === to(-e, tN),
              u = n === to(-e * tT, tN);
            return (
              c && (s = a),
              (l || u) && (s = o),
              tu(s, tN) && (s = to(-s, tN)),
              { isValid: c || l, value: s }
            );
          },
        }),
        tU = "base64url",
        tL = "utf8",
        tM = "utf8",
        tj = "base58btc";
      function t$(e) {
        return null != globalThis.Buffer
          ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
          : e;
      }
      function tB(e = 0) {
        return null != globalThis.Buffer &&
          null != globalThis.Buffer.allocUnsafe
          ? t$(globalThis.Buffer.allocUnsafe(e))
          : new Uint8Array(e);
      }
      function tF(e, t) {
        t || (t = e.reduce((e, t) => e + t.length, 0));
        let r = tB(t),
          i = 0;
        for (let t of e) r.set(t, i), (i += t.length);
        return t$(r);
      }
      var tW = function (e, t) {
        if (e.length >= 255) throw TypeError("Alphabet too long");
        for (var r = new Uint8Array(256), i = 0; i < r.length; i++) r[i] = 255;
        for (var s = 0; s < e.length; s++) {
          var n = e.charAt(s),
            a = n.charCodeAt(0);
          if (255 !== r[a]) throw TypeError(n + " is ambiguous");
          r[a] = s;
        }
        var o = e.length,
          c = e.charAt(0),
          l = Math.log(o) / Math.log(256),
          u = Math.log(256) / Math.log(o);
        function d(e) {
          if ("string" != typeof e) throw TypeError("Expected String");
          if (0 === e.length) return new Uint8Array();
          var t = 0;
          if (" " !== e[0]) {
            for (var i = 0, s = 0; e[t] === c; ) i++, t++;
            for (
              var n = ((e.length - t) * l + 1) >>> 0, a = new Uint8Array(n);
              e[t];

            ) {
              var u = r[e.charCodeAt(t)];
              if (255 === u) return;
              for (
                var d = 0, h = n - 1;
                (0 !== u || d < s) && -1 !== h;
                h--, d++
              )
                (u += (o * a[h]) >>> 0),
                  (a[h] = u % 256 >>> 0),
                  (u = (u / 256) >>> 0);
              if (0 !== u) throw Error("Non-zero carry");
              (s = d), t++;
            }
            if (" " !== e[t]) {
              for (var p = n - s; p !== n && 0 === a[p]; ) p++;
              for (var f = new Uint8Array(i + (n - p)), g = i; p !== n; )
                f[g++] = a[p++];
              return f;
            }
          }
        }
        return {
          encode: function (t) {
            if (
              (t instanceof Uint8Array ||
                (ArrayBuffer.isView(t)
                  ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                  : Array.isArray(t) && (t = Uint8Array.from(t))),
              !(t instanceof Uint8Array))
            )
              throw TypeError("Expected Uint8Array");
            if (0 === t.length) return "";
            for (var r = 0, i = 0, s = 0, n = t.length; s !== n && 0 === t[s]; )
              s++, r++;
            for (
              var a = ((n - s) * u + 1) >>> 0, l = new Uint8Array(a);
              s !== n;

            ) {
              for (
                var d = t[s], h = 0, p = a - 1;
                (0 !== d || h < i) && -1 !== p;
                p--, h++
              )
                (d += (256 * l[p]) >>> 0),
                  (l[p] = d % o >>> 0),
                  (d = (d / o) >>> 0);
              if (0 !== d) throw Error("Non-zero carry");
              (i = h), s++;
            }
            for (var f = a - i; f !== a && 0 === l[f]; ) f++;
            for (var g = c.repeat(r); f < a; ++f) g += e.charAt(l[f]);
            return g;
          },
          decodeUnsafe: d,
          decode: function (e) {
            var r = d(e);
            if (r) return r;
            throw Error(`Non-${t} character`);
          },
        };
      };
      let tq = (e) => {
          if (e instanceof Uint8Array && "Uint8Array" === e.constructor.name)
            return e;
          if (e instanceof ArrayBuffer) return new Uint8Array(e);
          if (ArrayBuffer.isView(e))
            return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
          throw Error("Unknown type, must be binary type");
        },
        tH = (e) => new TextEncoder().encode(e),
        tz = (e) => new TextDecoder().decode(e);
      class tV {
        constructor(e, t, r) {
          (this.name = e), (this.prefix = t), (this.baseEncode = r);
        }
        encode(e) {
          if (e instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(e)}`;
          throw Error("Unknown type, must be binary type");
        }
      }
      class tK {
        constructor(e, t, r) {
          if (((this.name = e), (this.prefix = t), void 0 === t.codePointAt(0)))
            throw Error("Invalid prefix character");
          (this.prefixCodePoint = t.codePointAt(0)), (this.baseDecode = r);
        }
        decode(e) {
          if ("string" == typeof e) {
            if (e.codePointAt(0) !== this.prefixCodePoint)
              throw Error(
                `Unable to decode multibase string ${JSON.stringify(e)}, ${
                  this.name
                } decoder only supports inputs prefixed with ${this.prefix}`
              );
            return this.baseDecode(e.slice(this.prefix.length));
          }
          throw Error("Can only multibase decode strings");
        }
        or(e) {
          return tY(this, e);
        }
      }
      class tG {
        constructor(e) {
          this.decoders = e;
        }
        or(e) {
          return tY(this, e);
        }
        decode(e) {
          let t = e[0],
            r = this.decoders[t];
          if (r) return r.decode(e);
          throw RangeError(
            `Unable to decode multibase string ${JSON.stringify(
              e
            )}, only inputs prefixed with ${Object.keys(
              this.decoders
            )} are supported`
          );
        }
      }
      let tY = (e, t) =>
        new tG({
          ...(e.decoders || { [e.prefix]: e }),
          ...(t.decoders || { [t.prefix]: t }),
        });
      class tZ {
        constructor(e, t, r, i) {
          (this.name = e),
            (this.prefix = t),
            (this.baseEncode = r),
            (this.baseDecode = i),
            (this.encoder = new tV(e, t, r)),
            (this.decoder = new tK(e, t, i));
        }
        encode(e) {
          return this.encoder.encode(e);
        }
        decode(e) {
          return this.decoder.decode(e);
        }
      }
      let tJ = ({ name: e, prefix: t, encode: r, decode: i }) =>
          new tZ(e, t, r, i),
        tX = ({ prefix: e, name: t, alphabet: r }) => {
          let { encode: i, decode: s } = tW(r, t);
          return tJ({ prefix: e, name: t, encode: i, decode: (e) => tq(s(e)) });
        },
        tQ = (e, t, r, i) => {
          let s = {};
          for (let e = 0; e < t.length; ++e) s[t[e]] = e;
          let n = e.length;
          for (; "=" === e[n - 1]; ) --n;
          let a = new Uint8Array(((n * r) / 8) | 0),
            o = 0,
            c = 0,
            l = 0;
          for (let t = 0; t < n; ++t) {
            let n = s[e[t]];
            if (void 0 === n) throw SyntaxError(`Non-${i} character`);
            (c = (c << r) | n),
              (o += r) >= 8 && ((o -= 8), (a[l++] = 255 & (c >> o)));
          }
          if (o >= r || 255 & (c << (8 - o)))
            throw SyntaxError("Unexpected end of data");
          return a;
        },
        t0 = (e, t, r) => {
          let i = "=" === t[t.length - 1],
            s = (1 << r) - 1,
            n = "",
            a = 0,
            o = 0;
          for (let i = 0; i < e.length; ++i)
            for (o = (o << 8) | e[i], a += 8; a > r; )
              (a -= r), (n += t[s & (o >> a)]);
          if ((a && (n += t[s & (o << (r - a))]), i))
            for (; (n.length * r) & 7; ) n += "=";
          return n;
        },
        t1 = ({ name: e, prefix: t, bitsPerChar: r, alphabet: i }) =>
          tJ({
            prefix: t,
            name: e,
            encode: (e) => t0(e, i, r),
            decode: (t) => tQ(t, i, r, e),
          });
      var t2 = Object.freeze({
          __proto__: null,
          identity: tJ({
            prefix: "\0",
            name: "identity",
            encode: (e) => tz(e),
            decode: (e) => tH(e),
          }),
        }),
        t3 = Object.freeze({
          __proto__: null,
          base2: t1({
            prefix: "0",
            name: "base2",
            alphabet: "01",
            bitsPerChar: 1,
          }),
        }),
        t5 = Object.freeze({
          __proto__: null,
          base8: t1({
            prefix: "7",
            name: "base8",
            alphabet: "01234567",
            bitsPerChar: 3,
          }),
        }),
        t8 = Object.freeze({
          __proto__: null,
          base10: tX({ prefix: "9", name: "base10", alphabet: "0123456789" }),
        }),
        t6 = Object.freeze({
          __proto__: null,
          base16: t1({
            prefix: "f",
            name: "base16",
            alphabet: "0123456789abcdef",
            bitsPerChar: 4,
          }),
          base16upper: t1({
            prefix: "F",
            name: "base16upper",
            alphabet: "0123456789ABCDEF",
            bitsPerChar: 4,
          }),
        });
      let t4 = t1({
          prefix: "b",
          name: "base32",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567",
          bitsPerChar: 5,
        }),
        t9 = t1({
          prefix: "B",
          name: "base32upper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
          bitsPerChar: 5,
        }),
        t7 = t1({
          prefix: "c",
          name: "base32pad",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
          bitsPerChar: 5,
        }),
        re = t1({
          prefix: "C",
          name: "base32padupper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
          bitsPerChar: 5,
        }),
        rt = t1({
          prefix: "v",
          name: "base32hex",
          alphabet: "0123456789abcdefghijklmnopqrstuv",
          bitsPerChar: 5,
        }),
        rr = t1({
          prefix: "V",
          name: "base32hexupper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
          bitsPerChar: 5,
        }),
        ri = t1({
          prefix: "t",
          name: "base32hexpad",
          alphabet: "0123456789abcdefghijklmnopqrstuv=",
          bitsPerChar: 5,
        });
      var rs = Object.freeze({
          __proto__: null,
          base32: t4,
          base32upper: t9,
          base32pad: t7,
          base32padupper: re,
          base32hex: rt,
          base32hexupper: rr,
          base32hexpad: ri,
          base32hexpadupper: t1({
            prefix: "T",
            name: "base32hexpadupper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
            bitsPerChar: 5,
          }),
          base32z: t1({
            prefix: "h",
            name: "base32z",
            alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
            bitsPerChar: 5,
          }),
        }),
        rn = Object.freeze({
          __proto__: null,
          base36: tX({
            prefix: "k",
            name: "base36",
            alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
          }),
          base36upper: tX({
            prefix: "K",
            name: "base36upper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
          }),
        }),
        ra = Object.freeze({
          __proto__: null,
          base58btc: tX({
            name: "base58btc",
            prefix: "z",
            alphabet:
              "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
          }),
          base58flickr: tX({
            name: "base58flickr",
            prefix: "Z",
            alphabet:
              "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
          }),
        });
      let ro = t1({
          prefix: "m",
          name: "base64",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          bitsPerChar: 6,
        }),
        rc = t1({
          prefix: "M",
          name: "base64pad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          bitsPerChar: 6,
        });
      var rl = Object.freeze({
        __proto__: null,
        base64: ro,
        base64pad: rc,
        base64url: t1({
          prefix: "u",
          name: "base64url",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
          bitsPerChar: 6,
        }),
        base64urlpad: t1({
          prefix: "U",
          name: "base64urlpad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
          bitsPerChar: 6,
        }),
      });
      let ru = Array.from(
          "\uD83D\uDE80\uD83E\uDE90\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\uD83E\uDD19\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\uD83C\uDF1E\uD83C\uDF88\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\uD83D\uDC8E\uD83D\uDCB8\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"
        ),
        rd = ru.reduce((e, t, r) => ((e[r] = t), e), []),
        rh = ru.reduce((e, t, r) => ((e[t.codePointAt(0)] = r), e), []);
      var rp = Object.freeze({
        __proto__: null,
        base256emoji: tJ({
          prefix: "\uD83D\uDE80",
          name: "base256emoji",
          encode: function (e) {
            return e.reduce((e, t) => (e += rd[t]), "");
          },
          decode: function (e) {
            let t = [];
            for (let r of e) {
              let e = rh[r.codePointAt(0)];
              if (void 0 === e) throw Error(`Non-base256emoji character: ${r}`);
              t.push(e);
            }
            return new Uint8Array(t);
          },
        }),
      });
      function rf(e, t, r) {
        (t = t || []), (r = r || 0);
        for (var i = r; e >= 0x80000000; )
          (t[r++] = (255 & e) | 128), (e /= 128);
        for (; -128 & e; ) (t[r++] = (255 & e) | 128), (e >>>= 7);
        return (t[r] = 0 | e), (rf.bytes = r - i + 1), t;
      }
      function rg(e, t) {
        var r,
          i = 0,
          t = t || 0,
          s = 0,
          n = t,
          a = e.length;
        do {
          if (n >= a)
            throw ((rg.bytes = 0), RangeError("Could not decode varint"));
          (r = e[n++]),
            (i += s < 28 ? (127 & r) << s : (127 & r) * Math.pow(2, s)),
            (s += 7);
        } while (r >= 128);
        return (rg.bytes = n - t), i;
      }
      var rm = {
        encode: rf,
        encodingLength: function (e) {
          return e < 128
            ? 1
            : e < 16384
            ? 2
            : e < 2097152
            ? 3
            : e < 0x10000000
            ? 4
            : e < 0x800000000
            ? 5
            : e < 0x40000000000
            ? 6
            : e < 0x2000000000000
            ? 7
            : e < 0x100000000000000
            ? 8
            : e < 0x8000000000000000
            ? 9
            : 10;
        },
      };
      let ry = (e, t, r = 0) => (rm.encode(e, t, r), t),
        rb = (e) => rm.encodingLength(e),
        rw = (e, t) => {
          let r = t.byteLength,
            i = rb(e),
            s = i + rb(r),
            n = new Uint8Array(s + r);
          return ry(e, n, 0), ry(r, n, i), n.set(t, s), new rv(e, r, t, n);
        };
      class rv {
        constructor(e, t, r, i) {
          (this.code = e), (this.size = t), (this.digest = r), (this.bytes = i);
        }
      }
      let rE = ({ name: e, code: t, encode: r }) => new r_(e, t, r);
      class r_ {
        constructor(e, t, r) {
          (this.name = e), (this.code = t), (this.encode = r);
        }
        digest(e) {
          if (e instanceof Uint8Array) {
            let t = this.encode(e);
            return t instanceof Uint8Array
              ? rw(this.code, t)
              : t.then((e) => rw(this.code, e));
          }
          throw Error("Unknown type, must be binary type");
        }
      }
      let rC = (e) => async (t) =>
        new Uint8Array(await crypto.subtle.digest(e, t));
      var rA = Object.freeze({
          __proto__: null,
          sha256: rE({ name: "sha2-256", code: 18, encode: rC("SHA-256") }),
          sha512: rE({ name: "sha2-512", code: 19, encode: rC("SHA-512") }),
        }),
        rI = Object.freeze({
          __proto__: null,
          identity: {
            code: 0,
            name: "identity",
            encode: tq,
            digest: (e) => rw(0, tq(e)),
          },
        });
      new TextEncoder(), new TextDecoder();
      let rS = {
        ...t2,
        ...t3,
        ...t5,
        ...t8,
        ...t6,
        ...rs,
        ...rn,
        ...ra,
        ...rl,
        ...rp,
      };
      function rN(e, t, r, i) {
        return {
          name: e,
          prefix: t,
          encoder: { name: e, prefix: t, encode: r },
          decoder: { decode: i },
        };
      }
      ({ ...rA, ...rI });
      let rT = rN(
          "utf8",
          "u",
          (e) => "u" + new TextDecoder("utf8").decode(e),
          (e) => new TextEncoder().encode(e.substring(1))
        ),
        rO = rN(
          "ascii",
          "a",
          (e) => {
            let t = "a";
            for (let r = 0; r < e.length; r++) t += String.fromCharCode(e[r]);
            return t;
          },
          (e) => {
            let t = tB((e = e.substring(1)).length);
            for (let r = 0; r < e.length; r++) t[r] = e.charCodeAt(r);
            return t;
          }
        ),
        rx = {
          utf8: rT,
          "utf-8": rT,
          hex: rS.base16,
          latin1: rO,
          ascii: rO,
          binary: rO,
          ...rS,
        };
      function rP(e, t = "utf8") {
        let r = rx[t];
        if (!r) throw Error(`Unsupported encoding "${t}"`);
        return ("utf8" === t || "utf-8" === t) &&
          null != globalThis.Buffer &&
          null != globalThis.Buffer.from
          ? globalThis.Buffer.from(
              e.buffer,
              e.byteOffset,
              e.byteLength
            ).toString("utf8")
          : r.encoder.encode(e).substring(1);
      }
      function rR(e, t = "utf8") {
        let r = rx[t];
        if (!r) throw Error(`Unsupported encoding "${t}"`);
        return ("utf8" === t || "utf-8" === t) &&
          null != globalThis.Buffer &&
          null != globalThis.Buffer.from
          ? t$(globalThis.Buffer.from(e, "utf-8"))
          : r.decoder.decode(`${r.prefix}${e}`);
      }
      function rk(e) {
        return (0, H.j)(rP(rR(e, tU), tL));
      }
      function rD(e) {
        return rP(rR((0, H.h)(e), tL), tU);
      }
      function rU(e) {
        return ["did", "key", "z" + rP(tF([rR("K36", tj), e]), tj)].join(":");
      }
      function rL(e) {
        let t = e.split("."),
          r = rk(t[0]),
          i = rk(t[1]);
        return {
          header: r,
          payload: i,
          signature: rR(t[2], tU),
          data: rR(t.slice(0, 2).join("."), tM),
        };
      }
      function rM(e = ex(32)) {
        let t = tD.getPublicKey(e);
        return { secretKey: tF([e, t]), publicKey: t };
      }
      async function rj(e, t, r, i, s = (0, v.fromMiliseconds)(Date.now())) {
        let n = { alg: "EdDSA", typ: "JWT" },
          a = { iss: rU(i.publicKey), sub: e, aud: t, iat: s, exp: s + r },
          o = rR(
            [rD((c = { header: n, payload: a }).header), rD(c.payload)].join(
              "."
            ),
            tM
          );
        var c,
          l = {
            header: n,
            payload: a,
            signature: tD.sign(o, i.secretKey.slice(0, 32)),
          };
        return [rD(l.header), rD(l.payload), rP(l.signature, tU)].join(".");
      }
      var r$ = r(49509),
        rB = function (e, t, r) {
          if (r || 2 == arguments.length)
            for (var i, s = 0, n = t.length; s < n; s++)
              (!i && s in t) ||
                (i || (i = Array.prototype.slice.call(t, 0, s)), (i[s] = t[s]));
          return e.concat(i || Array.prototype.slice.call(t));
        },
        rF = function (e, t, r) {
          (this.name = e),
            (this.version = t),
            (this.os = r),
            (this.type = "browser");
        },
        rW = function (e) {
          (this.version = e),
            (this.type = "node"),
            (this.name = "node"),
            (this.os = r$.platform);
        },
        rq = function (e, t, r, i) {
          (this.name = e),
            (this.version = t),
            (this.os = r),
            (this.bot = i),
            (this.type = "bot-device");
        },
        rH = function () {
          (this.type = "bot"),
            (this.bot = !0),
            (this.name = "bot"),
            (this.version = null),
            (this.os = null);
        },
        rz = function () {
          (this.type = "react-native"),
            (this.name = "react-native"),
            (this.version = null),
            (this.os = null);
        },
        rV =
          /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
        rK = [
          ["aol", /AOLShield\/([0-9\._]+)/],
          ["edge", /Edge\/([0-9\._]+)/],
          ["edge-ios", /EdgiOS\/([0-9\._]+)/],
          ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
          ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
          ["samsung", /SamsungBrowser\/([0-9\.]+)/],
          ["silk", /\bSilk\/([0-9._-]+)\b/],
          ["miui", /MiuiBrowser\/([0-9\.]+)$/],
          ["beaker", /BeakerBrowser\/([0-9\.]+)/],
          ["edge-chromium", /EdgA?\/([0-9\.]+)/],
          [
            "chromium-webview",
            /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
          ],
          ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
          ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
          ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
          ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
          ["fxios", /FxiOS\/([0-9\.]+)/],
          ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
          ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
          ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
          ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
          [
            "pie",
            /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/,
          ],
          ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
          ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
          ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
          ["ie", /MSIE\s(7\.0)/],
          ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
          ["android", /Android\s([0-9\.]+)/],
          ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
          ["safari", /Version\/([0-9\._]+).*Safari/],
          ["facebook", /FB[AS]V\/([0-9\.]+)/],
          ["instagram", /Instagram\s([0-9\.]+)/],
          ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
          ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
          ["curl", /^curl\/([0-9\.]+)$/],
          [
            "searchbot",
            /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,
          ],
        ],
        rG = [
          ["iOS", /iP(hone|od|ad)/],
          ["Android OS", /Android/],
          ["BlackBerry OS", /BlackBerry|BB10/],
          ["Windows Mobile", /IEMobile/],
          ["Amazon OS", /Kindle/],
          ["Windows 3.11", /Win16/],
          ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
          ["Windows 98", /(Windows 98)|(Win98)/],
          ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
          ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
          ["Windows Server 2003", /(Windows NT 5.2)/],
          ["Windows Vista", /(Windows NT 6.0)/],
          ["Windows 7", /(Windows NT 6.1)/],
          ["Windows 8", /(Windows NT 6.2)/],
          ["Windows 8.1", /(Windows NT 6.3)/],
          ["Windows 10", /(Windows NT 10.0)/],
          ["Windows ME", /Windows ME/],
          ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
          ["Open BSD", /OpenBSD/],
          ["Sun OS", /SunOS/],
          ["Chrome OS", /CrOS/],
          ["Linux", /(Linux)|(X11)/],
          ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
          ["QNX", /QNX/],
          ["BeOS", /BeOS/],
          ["OS/2", /OS\/2/],
        ],
        rY = r(621),
        rZ = r(28094);
      let rJ = "2.23.2",
        rX = {
          getDocsUrl: ({ docsBaseUrl: e, docsPath: t = "", docsSlug: r }) =>
            t ? `${e ?? "https://viem.sh"}${t}${r ? `#${r}` : ""}` : void 0,
          version: `viem@${rJ}`,
        };
      class rQ extends Error {
        constructor(e, t = {}) {
          let r =
              t.cause instanceof rQ
                ? t.cause.details
                : t.cause?.message
                ? t.cause.message
                : t.details,
            i = (t.cause instanceof rQ && t.cause.docsPath) || t.docsPath,
            s = rX.getDocsUrl?.({ ...t, docsPath: i });
          super(
            [
              e || "An error occurred.",
              "",
              ...(t.metaMessages ? [...t.metaMessages, ""] : []),
              ...(s ? [`Docs: ${s}`] : []),
              ...(r ? [`Details: ${r}`] : []),
              ...(rX.version ? [`Version: ${rX.version}`] : []),
            ].join("\n"),
            t.cause ? { cause: t.cause } : void 0
          ),
            Object.defineProperty(this, "details", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "docsPath", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "metaMessages", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "shortMessage", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "version", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "BaseError",
            }),
            (this.details = r),
            (this.docsPath = i),
            (this.metaMessages = t.metaMessages),
            (this.name = t.name ?? this.name),
            (this.shortMessage = e),
            (this.version = rJ);
        }
        walk(e) {
          return (function e(t, r) {
            return r?.(t)
              ? t
              : t && "object" == typeof t && "cause" in t && void 0 !== t.cause
              ? e(t.cause, r)
              : r
              ? null
              : t;
          })(this, e);
        }
      }
      function r0(e, { strict: t = !0 } = {}) {
        return (
          !!e &&
          "string" == typeof e &&
          (t ? /^0x[0-9a-fA-F]*$/.test(e) : e.startsWith("0x"))
        );
      }
      class r1 extends rQ {
        constructor({ size: e, targetSize: t, type: r }) {
          super(
            `${r.charAt(0).toUpperCase()}${r
              .slice(1)
              .toLowerCase()} size (${e}) exceeds padding size (${t}).`,
            { name: "SizeExceedsPaddingSizeError" }
          );
        }
      }
      function r2(e, { dir: t, size: r = 32 } = {}) {
        return "string" == typeof e
          ? (function (e, { dir: t, size: r = 32 } = {}) {
              if (null === r) return e;
              let i = e.replace("0x", "");
              if (i.length > 2 * r)
                throw new r1({
                  size: Math.ceil(i.length / 2),
                  targetSize: r,
                  type: "hex",
                });
              return `0x${i["right" === t ? "padEnd" : "padStart"](
                2 * r,
                "0"
              )}`;
            })(e, { dir: t, size: r })
          : (function (e, { dir: t, size: r = 32 } = {}) {
              if (null === r) return e;
              if (e.length > r)
                throw new r1({ size: e.length, targetSize: r, type: "bytes" });
              let i = new Uint8Array(r);
              for (let s = 0; s < r; s++) {
                let n = "right" === t;
                i[n ? s : r - s - 1] = e[n ? s : e.length - s - 1];
              }
              return i;
            })(e, { dir: t, size: r });
      }
      class r3 extends rQ {
        constructor({ max: e, min: t, signed: r, size: i, value: s }) {
          super(
            `Number "${s}" is not in safe ${
              i ? `${8 * i}-bit ${r ? "signed" : "unsigned"} ` : ""
            }integer range ${e ? `(${t} to ${e})` : `(above ${t})`}`,
            { name: "IntegerOutOfRangeError" }
          );
        }
      }
      class r5 extends rQ {
        constructor({ givenSize: e, maxSize: t }) {
          super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`, {
            name: "SizeOverflowError",
          });
        }
      }
      function r8(e) {
        return r0(e, { strict: !1 }) ? Math.ceil((e.length - 2) / 2) : e.length;
      }
      function r6(e, { size: t }) {
        if (r8(e) > t) throw new r5({ givenSize: r8(e), maxSize: t });
      }
      function r4(e, t = {}) {
        let { signed: r } = t;
        t.size && r6(e, { size: t.size });
        let i = BigInt(e);
        if (!r) return i;
        let s = (e.length - 2) / 2;
        return i <= (1n << (8n * BigInt(s) - 1n)) - 1n
          ? i
          : i - BigInt(`0x${"f".padStart(2 * s, "f")}`) - 1n;
      }
      let r9 = Array.from({ length: 256 }, (e, t) =>
        t.toString(16).padStart(2, "0")
      );
      function r7(e, t = {}) {
        return "number" == typeof e || "bigint" == typeof e
          ? it(e, t)
          : "string" == typeof e
          ? (function (e, t = {}) {
              return ie(ir.encode(e), t);
            })(e, t)
          : "boolean" == typeof e
          ? (function (e, t = {}) {
              let r = `0x${Number(e)}`;
              return "number" == typeof t.size
                ? (r6(r, { size: t.size }), r2(r, { size: t.size }))
                : r;
            })(e, t)
          : ie(e, t);
      }
      function ie(e, t = {}) {
        let r = "";
        for (let t = 0; t < e.length; t++) r += r9[e[t]];
        let i = `0x${r}`;
        return "number" == typeof t.size
          ? (r6(i, { size: t.size }), r2(i, { dir: "right", size: t.size }))
          : i;
      }
      function it(e, t = {}) {
        let r,
          { signed: i, size: s } = t,
          n = BigInt(e);
        s
          ? (r = i
              ? (1n << (8n * BigInt(s) - 1n)) - 1n
              : 2n ** (8n * BigInt(s)) - 1n)
          : "number" == typeof e && (r = BigInt(Number.MAX_SAFE_INTEGER));
        let a = "bigint" == typeof r && i ? -r - 1n : 0;
        if ((r && n > r) || n < a) {
          let t = "bigint" == typeof e ? "n" : "";
          throw new r3({
            max: r ? `${r}${t}` : void 0,
            min: `${a}${t}`,
            signed: i,
            size: s,
            value: `${e}${t}`,
          });
        }
        let o = `0x${(i && n < 0
          ? (1n << BigInt(8 * s)) + BigInt(n)
          : n
        ).toString(16)}`;
        return s ? r2(o, { size: s }) : o;
      }
      let ir = new TextEncoder(),
        ii = new TextEncoder(),
        is = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
      function ia(e) {
        return e >= is.zero && e <= is.nine
          ? e - is.zero
          : e >= is.A && e <= is.F
          ? e - (is.A - 10)
          : e >= is.a && e <= is.f
          ? e - (is.a - 10)
          : void 0;
      }
      function io(e, t = {}) {
        let r = e;
        t.size &&
          (r6(r, { size: t.size }),
          (r = r2(r, { dir: "right", size: t.size })));
        let i = r.slice(2);
        i.length % 2 && (i = `0${i}`);
        let s = i.length / 2,
          n = new Uint8Array(s);
        for (let e = 0, t = 0; e < s; e++) {
          let r = ia(i.charCodeAt(t++)),
            s = ia(i.charCodeAt(t++));
          if (void 0 === r || void 0 === s)
            throw new rQ(
              `Invalid byte sequence ("${i[t - 2]}${i[t - 1]}" in "${i}").`
            );
          n[e] = 16 * r + s;
        }
        return n;
      }
      function ic(e, t = {}) {
        let r = ii.encode(e);
        return "number" == typeof t.size
          ? (r6(r, { size: t.size }), r2(r, { dir: "right", size: t.size }))
          : r;
      }
      var il = r(91281);
      let iu = BigInt(0x100000000 - 1),
        id = BigInt(32),
        ih = (e, t, r) => (e << r) | (t >>> (32 - r)),
        ip = (e, t, r) => (t << r) | (e >>> (32 - r)),
        ig = (e, t, r) => (t << (r - 32)) | (e >>> (64 - r)),
        im = (e, t, r) => (e << (r - 32)) | (t >>> (64 - r));
      var iy = r(2767);
      let ib = [],
        iw = [],
        iv = [],
        iE = BigInt(0),
        i_ = BigInt(1),
        iC = BigInt(2),
        iA = BigInt(7),
        iI = BigInt(256),
        iS = BigInt(113);
      for (let e = 0, t = i_, r = 1, i = 0; e < 24; e++) {
        ([r, i] = [i, (2 * r + 3 * i) % 5]),
          ib.push(2 * (5 * i + r)),
          iw.push((((e + 1) * (e + 2)) / 2) % 64);
        let s = iE;
        for (let e = 0; e < 7; e++)
          (t = ((t << i_) ^ ((t >> iA) * iS)) % iI) & iC &&
            (s ^= i_ << ((i_ << BigInt(e)) - i_));
        iv.push(s);
      }
      let [iN, iT] = (function (e, t = !1) {
          let r = new Uint32Array(e.length),
            i = new Uint32Array(e.length);
          for (let s = 0; s < e.length; s++) {
            let { h: n, l: a } = (function (e, t = !1) {
              return t
                ? { h: Number(e & iu), l: Number((e >> id) & iu) }
                : { h: 0 | Number((e >> id) & iu), l: 0 | Number(e & iu) };
            })(e[s], t);
            [r[s], i[s]] = [n, a];
          }
          return [r, i];
        })(iv, !0),
        iO = (e, t, r) => (r > 32 ? ig(e, t, r) : ih(e, t, r)),
        ix = (e, t, r) => (r > 32 ? im(e, t, r) : ip(e, t, r));
      class iP extends iy.Vw {
        constructor(e, t, r, i = !1, s = 24) {
          if (
            (super(),
            (this.blockLen = e),
            (this.suffix = t),
            (this.outputLen = r),
            (this.enableXOF = i),
            (this.rounds = s),
            (this.pos = 0),
            (this.posOut = 0),
            (this.finished = !1),
            (this.destroyed = !1),
            (0, il.Fe)(r),
            0 >= this.blockLen || this.blockLen >= 200)
          )
            throw Error("Sha3 supports only keccak-f1600 function");
          (this.state = new Uint8Array(200)),
            (this.state32 = (0, iy.DH)(this.state));
        }
        keccak() {
          iy.qv || (0, iy.Fc)(this.state32),
            (function (e, t = 24) {
              let r = new Uint32Array(10);
              for (let i = 24 - t; i < 24; i++) {
                for (let t = 0; t < 10; t++)
                  r[t] = e[t] ^ e[t + 10] ^ e[t + 20] ^ e[t + 30] ^ e[t + 40];
                for (let t = 0; t < 10; t += 2) {
                  let i = (t + 8) % 10,
                    s = (t + 2) % 10,
                    n = r[s],
                    a = r[s + 1],
                    o = iO(n, a, 1) ^ r[i],
                    c = ix(n, a, 1) ^ r[i + 1];
                  for (let r = 0; r < 50; r += 10)
                    (e[t + r] ^= o), (e[t + r + 1] ^= c);
                }
                let t = e[2],
                  s = e[3];
                for (let r = 0; r < 24; r++) {
                  let i = iw[r],
                    n = iO(t, s, i),
                    a = ix(t, s, i),
                    o = ib[r];
                  (t = e[o]), (s = e[o + 1]), (e[o] = n), (e[o + 1] = a);
                }
                for (let t = 0; t < 50; t += 10) {
                  for (let i = 0; i < 10; i++) r[i] = e[t + i];
                  for (let i = 0; i < 10; i++)
                    e[t + i] ^= ~r[(i + 2) % 10] & r[(i + 4) % 10];
                }
                (e[0] ^= iN[i]), (e[1] ^= iT[i]);
              }
              r.fill(0);
            })(this.state32, this.rounds),
            iy.qv || (0, iy.Fc)(this.state32),
            (this.posOut = 0),
            (this.pos = 0);
        }
        update(e) {
          (0, il.CC)(this);
          let { blockLen: t, state: r } = this,
            i = (e = (0, iy.ZJ)(e)).length;
          for (let s = 0; s < i; ) {
            let n = Math.min(t - this.pos, i - s);
            for (let t = 0; t < n; t++) r[this.pos++] ^= e[s++];
            this.pos === t && this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished) return;
          this.finished = !0;
          let { state: e, suffix: t, pos: r, blockLen: i } = this;
          (e[r] ^= t),
            (128 & t) != 0 && r === i - 1 && this.keccak(),
            (e[i - 1] ^= 128),
            this.keccak();
        }
        writeInto(e) {
          (0, il.CC)(this, !1), (0, il.DO)(e), this.finish();
          let t = this.state,
            { blockLen: r } = this;
          for (let i = 0, s = e.length; i < s; ) {
            this.posOut >= r && this.keccak();
            let n = Math.min(r - this.posOut, s - i);
            e.set(t.subarray(this.posOut, this.posOut + n), i),
              (this.posOut += n),
              (i += n);
          }
          return e;
        }
        xofInto(e) {
          if (!this.enableXOF)
            throw Error("XOF is not possible for this instance");
          return this.writeInto(e);
        }
        xof(e) {
          return (0, il.Fe)(e), this.xofInto(new Uint8Array(e));
        }
        digestInto(e) {
          if (((0, il.Ht)(e, this), this.finished))
            throw Error("digest() was already called");
          return this.writeInto(e), this.destroy(), e;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          (this.destroyed = !0), this.state.fill(0);
        }
        _cloneInto(e) {
          let {
            blockLen: t,
            suffix: r,
            outputLen: i,
            rounds: s,
            enableXOF: n,
          } = this;
          return (
            e || (e = new iP(t, r, i, n, s)),
            e.state32.set(this.state32),
            (e.pos = this.pos),
            (e.posOut = this.posOut),
            (e.finished = this.finished),
            (e.rounds = s),
            (e.suffix = r),
            (e.outputLen = i),
            (e.enableXOF = n),
            (e.destroyed = this.destroyed),
            e
          );
        }
      }
      let iR = (0, iy.ld)(() => new iP(136, 1, 32));
      function ik(e, t) {
        let r = iR(
          r0(e, { strict: !1 })
            ? (function (e, t = {}) {
                return "number" == typeof e || "bigint" == typeof e
                  ? io(it(e, t))
                  : "boolean" == typeof e
                  ? (function (e, t = {}) {
                      let r = new Uint8Array(1);
                      return ((r[0] = Number(e)), "number" == typeof t.size)
                        ? (r6(r, { size: t.size }), r2(r, { size: t.size }))
                        : r;
                    })(e, t)
                  : r0(e)
                  ? io(e, t)
                  : ic(e, t);
              })(e)
            : e
        );
        return "bytes" === (t || "hex") ? r : r7(r);
      }
      class iD extends Map {
        constructor(e) {
          super(),
            Object.defineProperty(this, "maxSize", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.maxSize = e);
        }
        get(e) {
          let t = super.get(e);
          return (
            super.has(e) && void 0 !== t && (this.delete(e), super.set(e, t)), t
          );
        }
        set(e, t) {
          if ((super.set(e, t), this.maxSize && this.size > this.maxSize)) {
            let e = this.keys().next().value;
            e && this.delete(e);
          }
          return this;
        }
      }
      let iU = new iD(8192);
      async function iL({ hash: e, signature: t }) {
        let i = r0(e) ? e : r7(e),
          { secp256k1: s } = await r.e(111).then(r.bind(r, 10111)),
          n = (() => {
            if ("object" == typeof t && "r" in t && "s" in t) {
              let { r: e, s: r, v: i, yParity: n } = t,
                a = iM(Number(n ?? i));
              return new s.Signature(r4(e), r4(r)).addRecoveryBit(a);
            }
            let e = r0(t) ? t : r7(t),
              r = iM(
                (function (e, t = {}) {
                  return Number(r4(e, t));
                })(`0x${e.slice(130)}`)
              );
            return s.Signature.fromCompact(e.substring(2, 130)).addRecoveryBit(
              r
            );
          })()
            .recoverPublicKey(i.substring(2))
            .toHex(!1);
        return `0x${n}`;
      }
      function iM(e) {
        if (0 === e || 1 === e) return e;
        if (27 === e) return 0;
        if (28 === e) return 1;
        throw Error("Invalid yParityOrV value");
      }
      async function ij({ hash: e, signature: t }) {
        var r = await iL({ hash: e, signature: t });
        let i = ik(`0x${r.substring(4)}`).substring(26);
        return (function (e, t) {
          if (iU.has(`${e}.${void 0}`)) return iU.get(`${e}.${t}`);
          let r = t ? `${t}${e.toLowerCase()}` : e.substring(2).toLowerCase(),
            i = ik(ic(r), "bytes"),
            s = (t ? r.substring(`${t}0x`.length) : r).split("");
          for (let e = 0; e < 40; e += 2)
            i[e >> 1] >> 4 >= 8 && s[e] && (s[e] = s[e].toUpperCase()),
              (15 & i[e >> 1]) >= 8 &&
                s[e + 1] &&
                (s[e + 1] = s[e + 1].toUpperCase());
          let n = `0x${s.join("")}`;
          return iU.set(`${e}.${t}`, n), n;
        })(`0x${i}`);
      }
      var i$ = r(42552);
      function iB(e = 0) {
        return null != globalThis.Buffer &&
          null != globalThis.Buffer.allocUnsafe
          ? globalThis.Buffer.allocUnsafe(e)
          : new Uint8Array(e);
      }
      function iF(e, t) {
        t || (t = e.reduce((e, t) => e + t.length, 0));
        let r = iB(t),
          i = 0;
        for (let t of e) r.set(t, i), (i += t.length);
        return r;
      }
      let iW = function (e, t) {
        if (e.length >= 255) throw TypeError("Alphabet too long");
        for (var r = new Uint8Array(256), i = 0; i < r.length; i++) r[i] = 255;
        for (var s = 0; s < e.length; s++) {
          var n = e.charAt(s),
            a = n.charCodeAt(0);
          if (255 !== r[a]) throw TypeError(n + " is ambiguous");
          r[a] = s;
        }
        var o = e.length,
          c = e.charAt(0),
          l = Math.log(o) / Math.log(256),
          u = Math.log(256) / Math.log(o);
        function d(e) {
          if ("string" != typeof e) throw TypeError("Expected String");
          if (0 === e.length) return new Uint8Array();
          var t = 0;
          if (" " !== e[0]) {
            for (var i = 0, s = 0; e[t] === c; ) i++, t++;
            for (
              var n = ((e.length - t) * l + 1) >>> 0, a = new Uint8Array(n);
              e[t];

            ) {
              var u = r[e.charCodeAt(t)];
              if (255 === u) return;
              for (
                var d = 0, h = n - 1;
                (0 !== u || d < s) && -1 !== h;
                h--, d++
              )
                (u += (o * a[h]) >>> 0),
                  (a[h] = u % 256 >>> 0),
                  (u = (u / 256) >>> 0);
              if (0 !== u) throw Error("Non-zero carry");
              (s = d), t++;
            }
            if (" " !== e[t]) {
              for (var p = n - s; p !== n && 0 === a[p]; ) p++;
              for (var f = new Uint8Array(i + (n - p)), g = i; p !== n; )
                f[g++] = a[p++];
              return f;
            }
          }
        }
        return {
          encode: function (t) {
            if (
              (t instanceof Uint8Array ||
                (ArrayBuffer.isView(t)
                  ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                  : Array.isArray(t) && (t = Uint8Array.from(t))),
              !(t instanceof Uint8Array))
            )
              throw TypeError("Expected Uint8Array");
            if (0 === t.length) return "";
            for (var r = 0, i = 0, s = 0, n = t.length; s !== n && 0 === t[s]; )
              s++, r++;
            for (
              var a = ((n - s) * u + 1) >>> 0, l = new Uint8Array(a);
              s !== n;

            ) {
              for (
                var d = t[s], h = 0, p = a - 1;
                (0 !== d || h < i) && -1 !== p;
                p--, h++
              )
                (d += (256 * l[p]) >>> 0),
                  (l[p] = d % o >>> 0),
                  (d = (d / o) >>> 0);
              if (0 !== d) throw Error("Non-zero carry");
              (i = h), s++;
            }
            for (var f = a - i; f !== a && 0 === l[f]; ) f++;
            for (var g = c.repeat(r); f < a; ++f) g += e.charAt(l[f]);
            return g;
          },
          decodeUnsafe: d,
          decode: function (e) {
            var r = d(e);
            if (r) return r;
            throw Error(`Non-${t} character`);
          },
        };
      };
      new Uint8Array(0);
      let iq = (e, t) => {
          if (e === t) return !0;
          if (e.byteLength !== t.byteLength) return !1;
          for (let r = 0; r < e.byteLength; r++) if (e[r] !== t[r]) return !1;
          return !0;
        },
        iH = (e) => {
          if (e instanceof Uint8Array && "Uint8Array" === e.constructor.name)
            return e;
          if (e instanceof ArrayBuffer) return new Uint8Array(e);
          if (ArrayBuffer.isView(e))
            return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
          throw Error("Unknown type, must be binary type");
        },
        iz = (e) => new TextEncoder().encode(e),
        iV = (e) => new TextDecoder().decode(e);
      class iK {
        constructor(e, t, r) {
          (this.name = e), (this.prefix = t), (this.baseEncode = r);
        }
        encode(e) {
          if (e instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(e)}`;
          throw Error("Unknown type, must be binary type");
        }
      }
      class iG {
        constructor(e, t, r) {
          if (((this.name = e), (this.prefix = t), void 0 === t.codePointAt(0)))
            throw Error("Invalid prefix character");
          (this.prefixCodePoint = t.codePointAt(0)), (this.baseDecode = r);
        }
        decode(e) {
          if ("string" == typeof e) {
            if (e.codePointAt(0) !== this.prefixCodePoint)
              throw Error(
                `Unable to decode multibase string ${JSON.stringify(e)}, ${
                  this.name
                } decoder only supports inputs prefixed with ${this.prefix}`
              );
            return this.baseDecode(e.slice(this.prefix.length));
          }
          throw Error("Can only multibase decode strings");
        }
        or(e) {
          return iZ(this, e);
        }
      }
      class iY {
        constructor(e) {
          this.decoders = e;
        }
        or(e) {
          return iZ(this, e);
        }
        decode(e) {
          let t = e[0],
            r = this.decoders[t];
          if (r) return r.decode(e);
          throw RangeError(
            `Unable to decode multibase string ${JSON.stringify(
              e
            )}, only inputs prefixed with ${Object.keys(
              this.decoders
            )} are supported`
          );
        }
      }
      let iZ = (e, t) =>
        new iY({
          ...(e.decoders || { [e.prefix]: e }),
          ...(t.decoders || { [t.prefix]: t }),
        });
      class iJ {
        constructor(e, t, r, i) {
          (this.name = e),
            (this.prefix = t),
            (this.baseEncode = r),
            (this.baseDecode = i),
            (this.encoder = new iK(e, t, r)),
            (this.decoder = new iG(e, t, i));
        }
        encode(e) {
          return this.encoder.encode(e);
        }
        decode(e) {
          return this.decoder.decode(e);
        }
      }
      let iX = ({ name: e, prefix: t, encode: r, decode: i }) =>
          new iJ(e, t, r, i),
        iQ = ({ prefix: e, name: t, alphabet: r }) => {
          let { encode: i, decode: s } = iW(r, t);
          return iX({ prefix: e, name: t, encode: i, decode: (e) => iH(s(e)) });
        },
        i0 = (e, t, r, i) => {
          let s = {};
          for (let e = 0; e < t.length; ++e) s[t[e]] = e;
          let n = e.length;
          for (; "=" === e[n - 1]; ) --n;
          let a = new Uint8Array(((n * r) / 8) | 0),
            o = 0,
            c = 0,
            l = 0;
          for (let t = 0; t < n; ++t) {
            let n = s[e[t]];
            if (void 0 === n) throw SyntaxError(`Non-${i} character`);
            (c = (c << r) | n),
              (o += r) >= 8 && ((o -= 8), (a[l++] = 255 & (c >> o)));
          }
          if (o >= r || 255 & (c << (8 - o)))
            throw SyntaxError("Unexpected end of data");
          return a;
        },
        i1 = (e, t, r) => {
          let i = "=" === t[t.length - 1],
            s = (1 << r) - 1,
            n = "",
            a = 0,
            o = 0;
          for (let i = 0; i < e.length; ++i)
            for (o = (o << 8) | e[i], a += 8; a > r; )
              (a -= r), (n += t[s & (o >> a)]);
          if ((a && (n += t[s & (o << (r - a))]), i))
            for (; (n.length * r) & 7; ) n += "=";
          return n;
        },
        i2 = ({ name: e, prefix: t, bitsPerChar: r, alphabet: i }) =>
          iX({
            prefix: t,
            name: e,
            encode: (e) => i1(e, i, r),
            decode: (t) => i0(t, i, r, e),
          }),
        i3 = iX({
          prefix: "\0",
          name: "identity",
          encode: (e) => iV(e),
          decode: (e) => iz(e),
        }),
        i5 = i2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 }),
        i8 = i2({
          prefix: "7",
          name: "base8",
          alphabet: "01234567",
          bitsPerChar: 3,
        }),
        i6 = iQ({ prefix: "9", name: "base10", alphabet: "0123456789" }),
        i4 = i2({
          prefix: "f",
          name: "base16",
          alphabet: "0123456789abcdef",
          bitsPerChar: 4,
        }),
        i9 = i2({
          prefix: "F",
          name: "base16upper",
          alphabet: "0123456789ABCDEF",
          bitsPerChar: 4,
        }),
        i7 = i2({
          prefix: "b",
          name: "base32",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567",
          bitsPerChar: 5,
        }),
        se = i2({
          prefix: "B",
          name: "base32upper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
          bitsPerChar: 5,
        }),
        st = i2({
          prefix: "c",
          name: "base32pad",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
          bitsPerChar: 5,
        }),
        sr = i2({
          prefix: "C",
          name: "base32padupper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
          bitsPerChar: 5,
        }),
        si = i2({
          prefix: "v",
          name: "base32hex",
          alphabet: "0123456789abcdefghijklmnopqrstuv",
          bitsPerChar: 5,
        }),
        ss = i2({
          prefix: "V",
          name: "base32hexupper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
          bitsPerChar: 5,
        }),
        sn = i2({
          prefix: "t",
          name: "base32hexpad",
          alphabet: "0123456789abcdefghijklmnopqrstuv=",
          bitsPerChar: 5,
        }),
        sa = i2({
          prefix: "T",
          name: "base32hexpadupper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
          bitsPerChar: 5,
        }),
        so = i2({
          prefix: "h",
          name: "base32z",
          alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
          bitsPerChar: 5,
        }),
        sc = iQ({
          prefix: "k",
          name: "base36",
          alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
        }),
        sl = iQ({
          prefix: "K",
          name: "base36upper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        }),
        su = iQ({
          name: "base58btc",
          prefix: "z",
          alphabet:
            "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
        }),
        sd = iQ({
          name: "base58flickr",
          prefix: "Z",
          alphabet:
            "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
        }),
        sh = i2({
          prefix: "m",
          name: "base64",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          bitsPerChar: 6,
        }),
        sp = i2({
          prefix: "M",
          name: "base64pad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          bitsPerChar: 6,
        }),
        sf = i2({
          prefix: "u",
          name: "base64url",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
          bitsPerChar: 6,
        }),
        sg = i2({
          prefix: "U",
          name: "base64urlpad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
          bitsPerChar: 6,
        }),
        sm = Array.from(
          "\uD83D\uDE80\uD83E\uDE90\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\uD83E\uDD19\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\uD83C\uDF1E\uD83C\uDF88\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\uD83D\uDC8E\uD83D\uDCB8\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"
        ),
        sy = sm.reduce((e, t, r) => ((e[r] = t), e), []),
        sb = sm.reduce((e, t, r) => ((e[t.codePointAt(0)] = r), e), []),
        sw = iX({
          prefix: "\uD83D\uDE80",
          name: "base256emoji",
          encode: function (e) {
            return e.reduce((e, t) => (e += sy[t]), "");
          },
          decode: function (e) {
            let t = [];
            for (let r of e) {
              let e = sb[r.codePointAt(0)];
              if (void 0 === e) throw Error(`Non-base256emoji character: ${r}`);
              t.push(e);
            }
            return new Uint8Array(t);
          },
        });
      function sv(e, t, r) {
        t = t || [];
        for (var i = (r = r || 0); e >= 0x80000000; )
          (t[r++] = (255 & e) | 128), (e /= 128);
        for (; -128 & e; ) (t[r++] = (255 & e) | 128), (e >>>= 7);
        return (t[r] = 0 | e), (sv.bytes = r - i + 1), t;
      }
      function sE(e, t) {
        var r,
          i = 0,
          t = t || 0,
          s = 0,
          n = t,
          a = e.length;
        do {
          if (n >= a)
            throw ((sE.bytes = 0), RangeError("Could not decode varint"));
          (r = e[n++]),
            (i += s < 28 ? (127 & r) << s : (127 & r) * Math.pow(2, s)),
            (s += 7);
        } while (r >= 128);
        return (sE.bytes = n - t), i;
      }
      let s_ = {
          encode: sv,
          decode: sE,
          encodingLength: function (e) {
            return e < 128
              ? 1
              : e < 16384
              ? 2
              : e < 2097152
              ? 3
              : e < 0x10000000
              ? 4
              : e < 0x800000000
              ? 5
              : e < 0x40000000000
              ? 6
              : e < 0x2000000000000
              ? 7
              : e < 0x100000000000000
              ? 8
              : e < 0x8000000000000000
              ? 9
              : 10;
          },
        },
        sC = (e, t = 0) => [s_.decode(e, t), s_.decode.bytes],
        sA = (e, t, r = 0) => (s_.encode(e, t, r), t),
        sI = (e) => s_.encodingLength(e),
        sS = (e, t) => {
          let r = t.byteLength,
            i = sI(e),
            s = i + sI(r),
            n = new Uint8Array(s + r);
          return sA(e, n, 0), sA(r, n, i), n.set(t, s), new sO(e, r, t, n);
        },
        sN = (e) => {
          let t = iH(e),
            [r, i] = sC(t),
            [s, n] = sC(t.subarray(i)),
            a = t.subarray(i + n);
          if (a.byteLength !== s) throw Error("Incorrect length");
          return new sO(r, s, a, t);
        },
        sT = (e, t) =>
          e === t ||
          (e.code === t.code && e.size === t.size && iq(e.bytes, t.bytes));
      class sO {
        constructor(e, t, r, i) {
          (this.code = e), (this.size = t), (this.digest = r), (this.bytes = i);
        }
      }
      let sx = ({ name: e, code: t, encode: r }) => new sP(e, t, r);
      class sP {
        constructor(e, t, r) {
          (this.name = e), (this.code = t), (this.encode = r);
        }
        digest(e) {
          if (e instanceof Uint8Array) {
            let t = this.encode(e);
            return t instanceof Uint8Array
              ? sS(this.code, t)
              : t.then((e) => sS(this.code, e));
          }
          throw Error("Unknown type, must be binary type");
        }
      }
      let sR = (e) => async (t) =>
          new Uint8Array(await crypto.subtle.digest(e, t)),
        sk = sx({ name: "sha2-256", code: 18, encode: sR("SHA-256") }),
        sD = sx({ name: "sha2-512", code: 19, encode: sR("SHA-512") }),
        sU = {
          code: 0,
          name: "identity",
          encode: iH,
          digest: (e) => sS(0, iH(e)),
        },
        sL = "raw",
        sM = 85,
        sj = (e) => iH(e),
        s$ = (e) => iH(e),
        sB = new TextEncoder(),
        sF = new TextDecoder(),
        sW = "json",
        sq = 512,
        sH = (e) => sB.encode(JSON.stringify(e)),
        sz = (e) => JSON.parse(sF.decode(e));
      class sV {
        constructor(e, t, r, i) {
          (this.code = t),
            (this.version = e),
            (this.multihash = r),
            (this.bytes = i),
            (this.byteOffset = i.byteOffset),
            (this.byteLength = i.byteLength),
            (this.asCID = this),
            (this._baseCache = new Map()),
            Object.defineProperties(this, {
              byteOffset: s1,
              byteLength: s1,
              code: s0,
              version: s0,
              multihash: s0,
              bytes: s0,
              _baseCache: s1,
              asCID: s1,
            });
        }
        toV0() {
          if (0 === this.version) return this;
          {
            let { code: e, multihash: t } = this;
            if (e !== sZ)
              throw Error("Cannot convert a non dag-pb CID to CIDv0");
            if (t.code !== sJ)
              throw Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            return sV.createV0(t);
          }
        }
        toV1() {
          switch (this.version) {
            case 0: {
              let { code: e, digest: t } = this.multihash,
                r = sS(e, t);
              return sV.createV1(this.code, r);
            }
            case 1:
              return this;
            default:
              throw Error(
                `Can not convert CID version ${this.version} to version 0. This is a bug please report`
              );
          }
        }
        equals(e) {
          return (
            e &&
            this.code === e.code &&
            this.version === e.version &&
            sT(this.multihash, e.multihash)
          );
        }
        toString(e) {
          let { bytes: t, version: r, _baseCache: i } = this;
          return 0 === r
            ? sG(t, i, e || su.encoder)
            : sY(t, i, e || i7.encoder);
        }
        toJSON() {
          return {
            code: this.code,
            version: this.version,
            hash: this.multihash.bytes,
          };
        }
        get [Symbol.toStringTag]() {
          return "CID";
        }
        [Symbol.for("nodejs.util.inspect.custom")]() {
          return "CID(" + this.toString() + ")";
        }
        static isCID(e) {
          return s2(/^0\.0/, s3), !!(e && (e[sQ] || e.asCID === e));
        }
        get toBaseEncodedString() {
          throw Error("Deprecated, use .toString()");
        }
        get codec() {
          throw Error(
            '"codec" property is deprecated, use integer "code" property instead'
          );
        }
        get buffer() {
          throw Error(
            "Deprecated .buffer property, use .bytes to get Uint8Array instead"
          );
        }
        get multibaseName() {
          throw Error('"multibaseName" property is deprecated');
        }
        get prefix() {
          throw Error('"prefix" property is deprecated');
        }
        static asCID(e) {
          if (e instanceof sV) return e;
          if (null != e && e.asCID === e) {
            let { version: t, code: r, multihash: i, bytes: s } = e;
            return new sV(t, r, i, s || sX(t, r, i.bytes));
          }
          if (null == e || !0 !== e[sQ]) return null;
          {
            let { version: t, multihash: r, code: i } = e,
              s = sN(r);
            return sV.create(t, i, s);
          }
        }
        static create(e, t, r) {
          if ("number" != typeof t)
            throw Error("String codecs are no longer supported");
          switch (e) {
            case 0:
              if (t === sZ) return new sV(e, t, r, r.bytes);
              throw Error(
                `Version 0 CID must use dag-pb (code: ${sZ}) block encoding`
              );
            case 1: {
              let i = sX(e, t, r.bytes);
              return new sV(e, t, r, i);
            }
            default:
              throw Error("Invalid version");
          }
        }
        static createV0(e) {
          return sV.create(0, sZ, e);
        }
        static createV1(e, t) {
          return sV.create(1, e, t);
        }
        static decode(e) {
          let [t, r] = sV.decodeFirst(e);
          if (r.length) throw Error("Incorrect length");
          return t;
        }
        static decodeFirst(e) {
          let t = sV.inspectBytes(e),
            r = t.size - t.multihashSize,
            i = iH(e.subarray(r, r + t.multihashSize));
          if (i.byteLength !== t.multihashSize) throw Error("Incorrect length");
          let s = i.subarray(t.multihashSize - t.digestSize),
            n = new sO(t.multihashCode, t.digestSize, s, i);
          return [
            0 === t.version ? sV.createV0(n) : sV.createV1(t.codec, n),
            e.subarray(t.size),
          ];
        }
        static inspectBytes(e) {
          let t = 0,
            r = () => {
              let [r, i] = sC(e.subarray(t));
              return (t += i), r;
            },
            i = r(),
            s = sZ;
          if (
            (18 === i ? ((i = 0), (t = 0)) : 1 === i && (s = r()),
            0 !== i && 1 !== i)
          )
            throw RangeError(`Invalid CID version ${i}`);
          let n = t,
            a = r(),
            o = r(),
            c = t + o;
          return {
            version: i,
            codec: s,
            multihashCode: a,
            digestSize: o,
            multihashSize: c - n,
            size: c,
          };
        }
        static parse(e, t) {
          let [r, i] = sK(e, t),
            s = sV.decode(i);
          return s._baseCache.set(r, e), s;
        }
      }
      let sK = (e, t) => {
          switch (e[0]) {
            case "Q": {
              let r = t || su;
              return [su.prefix, r.decode(`${su.prefix}${e}`)];
            }
            case su.prefix: {
              let r = t || su;
              return [su.prefix, r.decode(e)];
            }
            case i7.prefix: {
              let r = t || i7;
              return [i7.prefix, r.decode(e)];
            }
            default:
              if (null == t)
                throw Error(
                  "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
                );
              return [e[0], t.decode(e)];
          }
        },
        sG = (e, t, r) => {
          let { prefix: i } = r;
          if (i !== su.prefix)
            throw Error(`Cannot string encode V0 in ${r.name} encoding`);
          let s = t.get(i);
          if (null != s) return s;
          {
            let s = r.encode(e).slice(1);
            return t.set(i, s), s;
          }
        },
        sY = (e, t, r) => {
          let { prefix: i } = r,
            s = t.get(i);
          if (null != s) return s;
          {
            let s = r.encode(e);
            return t.set(i, s), s;
          }
        },
        sZ = 112,
        sJ = 18,
        sX = (e, t, r) => {
          let i = sI(e),
            s = i + sI(t),
            n = new Uint8Array(s + r.byteLength);
          return sA(e, n, 0), sA(t, n, i), n.set(r, s), n;
        },
        sQ = Symbol.for("@ipld/js-cid/CID"),
        s0 = { writable: !1, configurable: !1, enumerable: !0 },
        s1 = { writable: !1, enumerable: !1, configurable: !1 },
        s2 = (e, t) => {
          if (e.test("0.0.0-dev")) console.warn(t);
          else throw Error(t);
        },
        s3 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`,
        s5 = { ...s, ...n, ...a, ...o, ...c, ...l, ...u, ...d, ...h, ...p };
      function s8(e, t, r, i) {
        return {
          name: e,
          prefix: t,
          encoder: { name: e, prefix: t, encode: r },
          decoder: { decode: i },
        };
      }
      ({ ...f, ...g });
      let s6 = s8(
          "utf8",
          "u",
          (e) => "u" + new TextDecoder("utf8").decode(e),
          (e) => new TextEncoder().encode(e.substring(1))
        ),
        s4 = s8(
          "ascii",
          "a",
          (e) => {
            let t = "a";
            for (let r = 0; r < e.length; r++) t += String.fromCharCode(e[r]);
            return t;
          },
          (e) => {
            let t = iB((e = e.substring(1)).length);
            for (let r = 0; r < e.length; r++) t[r] = e.charCodeAt(r);
            return t;
          }
        ),
        s9 = {
          utf8: s6,
          "utf-8": s6,
          hex: s5.base16,
          latin1: s4,
          ascii: s4,
          binary: s4,
          ...s5,
        };
      function s7(e, t = "utf8") {
        let r = s9[t];
        if (!r) throw Error(`Unsupported encoding "${t}"`);
        return ("utf8" === t || "utf-8" === t) &&
          null != globalThis.Buffer &&
          null != globalThis.Buffer.from
          ? globalThis.Buffer.from(e, "utf8")
          : r.decoder.decode(`${r.prefix}${e}`);
      }
      function ne(e, t = "utf8") {
        let r = s9[t];
        if (!r) throw Error(`Unsupported encoding "${t}"`);
        return ("utf8" === t || "utf-8" === t) &&
          null != globalThis.Buffer &&
          null != globalThis.Buffer.from
          ? globalThis.Buffer.from(
              e.buffer,
              e.byteOffset,
              e.byteLength
            ).toString("utf8")
          : r.encoder.encode(e).substring(1);
      }
      function nt(e, t, r) {
        var i, s;
        let n;
        return (
          (r.length
            ? ((i = t.length),
              Array.isArray(e) ? e.length >= i : Object.keys(e).length >= i)
            : ((s = t.length),
              Array.isArray(e)
                ? e.length === s
                : Object.keys(e).length === s)) &&
          ((n = !0),
          t.forEach((t) => {
            t in e || (n = !1);
          }),
          n)
        );
      }
      function nr(e, t, r = "_") {
        let i = e.split(r);
        return i[i.length - 1].trim().toLowerCase() === t.trim().toLowerCase();
      }
      let ni = {
        waku: {
          publish: "waku_publish",
          batchPublish: "waku_batchPublish",
          subscribe: "waku_subscribe",
          batchSubscribe: "waku_batchSubscribe",
          subscription: "waku_subscription",
          unsubscribe: "waku_unsubscribe",
          batchUnsubscribe: "waku_batchUnsubscribe",
          batchFetchMessages: "waku_batchFetchMessages",
        },
        irn: {
          publish: "irn_publish",
          batchPublish: "irn_batchPublish",
          subscribe: "irn_subscribe",
          batchSubscribe: "irn_batchSubscribe",
          subscription: "irn_subscription",
          unsubscribe: "irn_unsubscribe",
          batchUnsubscribe: "irn_batchUnsubscribe",
          batchFetchMessages: "irn_batchFetchMessages",
        },
        iridium: {
          publish: "iridium_publish",
          batchPublish: "iridium_batchPublish",
          subscribe: "iridium_subscribe",
          batchSubscribe: "iridium_batchSubscribe",
          subscription: "iridium_subscription",
          unsubscribe: "iridium_unsubscribe",
          batchUnsubscribe: "iridium_batchUnsubscribe",
          batchFetchMessages: "iridium_batchFetchMessages",
        },
      };
      var ns = r(49509),
        nn = r(44134).Buffer;
      function na(e) {
        let [t, r] = e.split(":");
        return { namespace: t, reference: r };
      }
      function no(e) {
        let [t, r, i] = e.split(":");
        return { namespace: t, reference: r, address: i };
      }
      function nc(e, t) {
        return e.includes(":") ? [e] : t.chains || [];
      }
      var nl = Object.defineProperty,
        nu = Object.defineProperties,
        nd = Object.getOwnPropertyDescriptors,
        nh = Object.getOwnPropertySymbols,
        np = Object.prototype.hasOwnProperty,
        nf = Object.prototype.propertyIsEnumerable,
        ng = (e, t, r) =>
          t in e
            ? nl(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        nm = (e, t) => {
          for (var r in t || (t = {})) np.call(t, r) && ng(e, r, t[r]);
          if (nh) for (var r of nh(t)) nf.call(t, r) && ng(e, r, t[r]);
          return e;
        },
        ny = (e, t) => nu(e, nd(t));
      let nb = {
        reactNative: "react-native",
        node: "node",
        browser: "browser",
        unknown: "unknown",
      };
      function nw() {
        return (
          "u" > typeof ns &&
          "u" > typeof ns.versions &&
          "u" > typeof ns.versions.node
        );
      }
      function nv() {
        return (
          !(0, rY.getDocument)() &&
          !!(0, rY.getNavigator)() &&
          "ReactNative" === navigator.product
        );
      }
      function nE() {
        return !nw() && !!(0, rY.getNavigator)() && !!(0, rY.getDocument)();
      }
      function n_() {
        return nv()
          ? nb.reactNative
          : nw()
          ? nb.node
          : nE()
          ? nb.browser
          : nb.unknown;
      }
      function nC() {
        var e;
        try {
          return nv() &&
            "u" > typeof r.g &&
            "u" > typeof (null == r.g ? void 0 : r.g.Application)
            ? null == (e = r.g.Application)
              ? void 0
              : e.applicationId
            : void 0;
        } catch {
          return;
        }
      }
      function nA() {
        return (
          (0, rZ.g)() || { name: "", description: "", url: "", icons: [""] }
        );
      }
      function nI(e, t, i) {
        let s = (function () {
            if (
              n_() === nb.reactNative &&
              "u" > typeof r.g &&
              "u" > typeof (null == r.g ? void 0 : r.g.Platform)
            ) {
              let { OS: e, Version: t } = r.g.Platform;
              return [e, t].join("-");
            }
            let e =
              "undefined" == typeof document &&
              "undefined" != typeof navigator &&
              "ReactNative" === navigator.product
                ? new rz()
                : "undefined" != typeof navigator
                ? (function (e) {
                    var t,
                      r =
                        "" !== (t = e) &&
                        rK.reduce(function (e, r) {
                          var i = r[0],
                            s = r[1];
                          if (e) return e;
                          var n = s.exec(t);
                          return !!n && [i, n];
                        }, !1);
                    if (!r) return null;
                    var i = r[0],
                      s = r[1];
                    if ("searchbot" === i) return new rH();
                    var n =
                      s[1] && s[1].split(".").join("_").split("_").slice(0, 3);
                    n
                      ? n.length < 3 &&
                        (n = rB(
                          rB([], n, !0),
                          (function (e) {
                            for (var t = [], r = 0; r < e; r++) t.push("0");
                            return t;
                          })(3 - n.length),
                          !0
                        ))
                      : (n = []);
                    var a = n.join("."),
                      o = (function (e) {
                        for (var t = 0, r = rG.length; t < r; t++) {
                          var i = rG[t],
                            s = i[0];
                          if (i[1].exec(e)) return s;
                        }
                        return null;
                      })(e),
                      c = rV.exec(e);
                    return c && c[1] ? new rq(i, a, o, c[1]) : new rF(i, a, o);
                  })(navigator.userAgent)
                : void 0 !== r$ && r$.version
                ? new rW(r$.version.slice(1))
                : null;
            if (null === e) return "unknown";
            let t = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
            return "browser" === e.type
              ? [t, e.name, e.version].join("-")
              : [t, e.version].join("-");
          })(),
          n = (function () {
            var e;
            let t = n_();
            return t === nb.browser
              ? [
                  t,
                  (null == (e = (0, rY.getLocation)()) ? void 0 : e.host) ||
                    "unknown",
                ].join(":")
              : t;
          })();
        return [[e, t].join("-"), ["js", i].join("-"), s, n].join("/");
      }
      function nS(e, t) {
        return e.filter((e) => t.includes(e)).length === e.length;
      }
      function nN(e) {
        return Object.fromEntries(e.entries());
      }
      function nT(e) {
        return new Map(Object.entries(e));
      }
      function nO(e = v.FIVE_MINUTES, t) {
        let r,
          i,
          s,
          n,
          a = (0, v.toMiliseconds)(e || v.FIVE_MINUTES);
        return {
          resolve: (e) => {
            s && r && (clearTimeout(s), r(e), (n = Promise.resolve(e)));
          },
          reject: (e) => {
            s && i && (clearTimeout(s), i(e));
          },
          done: () =>
            new Promise((e, o) => {
              if (n) return e(n);
              (s = setTimeout(() => {
                let e = Error(t);
                (n = Promise.reject(e)), o(e);
              }, a)),
                (r = e),
                (i = o);
            }),
        };
      }
      function nx(e, t, r) {
        return new Promise(async (i, s) => {
          let n = setTimeout(() => s(Error(r)), t);
          try {
            let t = await e;
            i(t);
          } catch (e) {
            s(e);
          }
          clearTimeout(n);
        });
      }
      function nP(e, t) {
        if ("string" == typeof t && t.startsWith(`${e}:`)) return t;
        if ("topic" === e.toLowerCase()) {
          if ("string" != typeof t)
            throw Error(
              'Value must be "string" for expirer target type: topic'
            );
          return `topic:${t}`;
        }
        if ("id" === e.toLowerCase()) {
          if ("number" != typeof t)
            throw Error('Value must be "number" for expirer target type: id');
          return `id:${t}`;
        }
        throw Error(`Unknown expirer target type: ${e}`);
      }
      function nR(e) {
        let [t, r] = e.split(":"),
          i = { id: void 0, topic: void 0 };
        if ("topic" === t && "string" == typeof r) i.topic = r;
        else if ("id" === t && Number.isInteger(Number(r))) i.id = Number(r);
        else
          throw Error(
            `Invalid target, expected id:number or topic:string, got ${t}:${r}`
          );
        return i;
      }
      function nk(e, t) {
        return (0, v.fromMiliseconds)(
          (t || Date.now()) + (0, v.toMiliseconds)(e)
        );
      }
      function nD(e) {
        return Date.now() >= (0, v.toMiliseconds)(e);
      }
      function nU(e, t) {
        return `${e}${t ? `:${t}` : ""}`;
      }
      function nL(e = [], t = []) {
        return [...new Set([...e, ...t])];
      }
      async function nM({ id: e, topic: t, wcDeepLink: i }) {
        var s, n;
        try {
          if (!i) return;
          let a = "string" == typeof i ? JSON.parse(i) : i,
            o = a?.href;
          if ("string" != typeof o) return;
          let c = (function (e, t, r) {
              let i = `requestId=${t}&sessionTopic=${r}`;
              e.endsWith("/") && (e = e.slice(0, -1));
              let s = `${e}`;
              if (e.startsWith("https://t.me")) {
                let t = e.includes("?") ? "&startapp=" : "?startapp=";
                s = `${s}${t}${(function (e, t = !1) {
                  let r = nn.from(e).toString("base64");
                  return t ? r.replace(/[=]/g, "") : r;
                })(i, !0)}`;
              } else s = `${s}/wc?${i}`;
              return s;
            })(o, e, t),
            l = n_();
          if (l === nb.browser) {
            let e;
            if (!(null != (s = (0, rY.getDocument)()) && s.hasFocus()))
              return void console.warn(
                "Document does not have focus, skipping deeplink."
              );
            (n = c),
              (e = "_self"),
              !(function () {
                try {
                  return window.self !== window.top;
                } catch {
                  return !1;
                }
              })()
                ? (("u" > typeof window &&
                    (window.TelegramWebviewProxy ||
                      window.Telegram ||
                      window.TelegramWebviewProxyProto)) ||
                    n.startsWith("https://") ||
                    n.startsWith("http://")) &&
                  (e = "_blank")
                : (e = "_top"),
              window.open(n, e, "noreferrer noopener");
          } else
            l === nb.reactNative &&
              "u" > typeof (null == r.g ? void 0 : r.g.Linking) &&
              (await r.g.Linking.openURL(c));
        } catch (e) {
          console.error(e);
        }
      }
      async function nj(e, t) {
        let r = "";
        try {
          if (nE() && (r = localStorage.getItem(t))) return r;
          r = await e.getItem(t);
        } catch (e) {
          console.error(e);
        }
        return r;
      }
      function n$(e, t) {
        if (!e.includes(t)) return null;
        let r = e.split(/([&,?,=])/),
          i = r.indexOf(t);
        return r[i + 2];
      }
      function nB() {
        return "u" > typeof crypto && null != crypto && crypto.randomUUID
          ? crypto.randomUUID()
          : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e) => {
              let t = (16 * Math.random()) | 0;
              return ("x" === e ? t : (3 & t) | 8).toString(16);
            });
      }
      function nF() {
        return "u" > typeof ns && "true" === ns.env.IS_VITEST;
      }
      function nW(e) {
        return nn.from(e, "base64").toString("utf-8");
      }
      function nq(e) {
        if (!Number.isSafeInteger(e) || e < 0)
          throw Error("positive integer expected, got " + e);
      }
      function nH(e, ...t) {
        if (
          !(
            e instanceof Uint8Array ||
            (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
          )
        )
          throw Error("Uint8Array expected");
        if (t.length > 0 && !t.includes(e.length))
          throw Error(
            "Uint8Array expected of length " + t + ", got length=" + e.length
          );
      }
      function nz(e) {
        if ("function" != typeof e || "function" != typeof e.create)
          throw Error("Hash should be wrapped by utils.wrapConstructor");
        nq(e.outputLen), nq(e.blockLen);
      }
      function nV(e, t = !0) {
        if (e.destroyed) throw Error("Hash instance has been destroyed");
        if (t && e.finished)
          throw Error("Hash#digest() has already been called");
      }
      function nK(e, t) {
        nH(e);
        let r = t.outputLen;
        if (e.length < r)
          throw Error(
            "digestInto() expects output buffer of length at least " + r
          );
      }
      let nG = BigInt(0x100000000 - 1),
        nY = BigInt(32),
        nZ = (e, t, r) => (e << r) | (t >>> (32 - r)),
        nJ = (e, t, r) => (t << r) | (e >>> (32 - r)),
        nX = (e, t, r) => (t << (r - 32)) | (e >>> (64 - r)),
        nQ = (e, t, r) => (e << (r - 32)) | (t >>> (64 - r)),
        n0 =
          "object" == typeof globalThis && "crypto" in globalThis
            ? globalThis.crypto
            : void 0;
      function n1(e) {
        return new DataView(e.buffer, e.byteOffset, e.byteLength);
      }
      function n2(e, t) {
        return (e << (32 - t)) | (e >>> t);
      }
      let n3 = 68 === new Uint8Array(new Uint32Array([0x11223344]).buffer)[0];
      function n5(e) {
        for (let r = 0; r < e.length; r++) {
          var t;
          e[r] =
            (((t = e[r]) << 24) & 0xff000000) |
            ((t << 8) & 0xff0000) |
            ((t >>> 8) & 65280) |
            ((t >>> 24) & 255);
        }
      }
      function n8(e) {
        return (
          "string" == typeof e &&
            (e = (function (e) {
              if ("string" != typeof e)
                throw Error("utf8ToBytes expected string, got " + typeof e);
              return new Uint8Array(new TextEncoder().encode(e));
            })(e)),
          nH(e),
          e
        );
      }
      class n6 {
        clone() {
          return this._cloneInto();
        }
      }
      function n4(e) {
        let t = (t) => e().update(n8(t)).digest(),
          r = e();
        return (
          (t.outputLen = r.outputLen),
          (t.blockLen = r.blockLen),
          (t.create = () => e()),
          t
        );
      }
      function n9(e = 32) {
        if (n0 && "function" == typeof n0.getRandomValues)
          return n0.getRandomValues(new Uint8Array(e));
        if (n0 && "function" == typeof n0.randomBytes) return n0.randomBytes(e);
        throw Error("crypto.getRandomValues must be defined");
      }
      let n7 = [],
        ae = [],
        at = [],
        ar = BigInt(0),
        ai = BigInt(1),
        as = BigInt(2),
        an = BigInt(7),
        aa = BigInt(256),
        ao = BigInt(113);
      for (let e = 0, t = ai, r = 1, i = 0; e < 24; e++) {
        ([r, i] = [i, (2 * r + 3 * i) % 5]),
          n7.push(2 * (5 * i + r)),
          ae.push((((e + 1) * (e + 2)) / 2) % 64);
        let s = ar;
        for (let e = 0; e < 7; e++)
          (t = ((t << ai) ^ ((t >> an) * ao)) % aa) & as &&
            (s ^= ai << ((ai << BigInt(e)) - ai));
        at.push(s);
      }
      let [ac, al] = (function (e, t = !1) {
          let r = new Uint32Array(e.length),
            i = new Uint32Array(e.length);
          for (let s = 0; s < e.length; s++) {
            let { h: n, l: a } = (function (e, t = !1) {
              return t
                ? { h: Number(e & nG), l: Number((e >> nY) & nG) }
                : { h: 0 | Number((e >> nY) & nG), l: 0 | Number(e & nG) };
            })(e[s], t);
            [r[s], i[s]] = [n, a];
          }
          return [r, i];
        })(at, !0),
        au = (e, t, r) => (r > 32 ? nX(e, t, r) : nZ(e, t, r)),
        ad = (e, t, r) => (r > 32 ? nQ(e, t, r) : nJ(e, t, r));
      class ah extends n6 {
        constructor(e, t, r, i = !1, s = 24) {
          if (
            (super(),
            (this.blockLen = e),
            (this.suffix = t),
            (this.outputLen = r),
            (this.enableXOF = i),
            (this.rounds = s),
            (this.pos = 0),
            (this.posOut = 0),
            (this.finished = !1),
            (this.destroyed = !1),
            nq(r),
            0 >= this.blockLen || this.blockLen >= 200)
          )
            throw Error("Sha3 supports only keccak-f1600 function");
          (this.state = new Uint8Array(200)),
            (this.state32 = (function (e) {
              return new Uint32Array(
                e.buffer,
                e.byteOffset,
                Math.floor(e.byteLength / 4)
              );
            })(this.state));
        }
        keccak() {
          n3 || n5(this.state32),
            (function (e, t = 24) {
              let r = new Uint32Array(10);
              for (let i = 24 - t; i < 24; i++) {
                for (let t = 0; t < 10; t++)
                  r[t] = e[t] ^ e[t + 10] ^ e[t + 20] ^ e[t + 30] ^ e[t + 40];
                for (let t = 0; t < 10; t += 2) {
                  let i = (t + 8) % 10,
                    s = (t + 2) % 10,
                    n = r[s],
                    a = r[s + 1],
                    o = au(n, a, 1) ^ r[i],
                    c = ad(n, a, 1) ^ r[i + 1];
                  for (let r = 0; r < 50; r += 10)
                    (e[t + r] ^= o), (e[t + r + 1] ^= c);
                }
                let t = e[2],
                  s = e[3];
                for (let r = 0; r < 24; r++) {
                  let i = ae[r],
                    n = au(t, s, i),
                    a = ad(t, s, i),
                    o = n7[r];
                  (t = e[o]), (s = e[o + 1]), (e[o] = n), (e[o + 1] = a);
                }
                for (let t = 0; t < 50; t += 10) {
                  for (let i = 0; i < 10; i++) r[i] = e[t + i];
                  for (let i = 0; i < 10; i++)
                    e[t + i] ^= ~r[(i + 2) % 10] & r[(i + 4) % 10];
                }
                (e[0] ^= ac[i]), (e[1] ^= al[i]);
              }
              r.fill(0);
            })(this.state32, this.rounds),
            n3 || n5(this.state32),
            (this.posOut = 0),
            (this.pos = 0);
        }
        update(e) {
          nV(this);
          let { blockLen: t, state: r } = this,
            i = (e = n8(e)).length;
          for (let s = 0; s < i; ) {
            let n = Math.min(t - this.pos, i - s);
            for (let t = 0; t < n; t++) r[this.pos++] ^= e[s++];
            this.pos === t && this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished) return;
          this.finished = !0;
          let { state: e, suffix: t, pos: r, blockLen: i } = this;
          (e[r] ^= t),
            (128 & t) != 0 && r === i - 1 && this.keccak(),
            (e[i - 1] ^= 128),
            this.keccak();
        }
        writeInto(e) {
          nV(this, !1), nH(e), this.finish();
          let t = this.state,
            { blockLen: r } = this;
          for (let i = 0, s = e.length; i < s; ) {
            this.posOut >= r && this.keccak();
            let n = Math.min(r - this.posOut, s - i);
            e.set(t.subarray(this.posOut, this.posOut + n), i),
              (this.posOut += n),
              (i += n);
          }
          return e;
        }
        xofInto(e) {
          if (!this.enableXOF)
            throw Error("XOF is not possible for this instance");
          return this.writeInto(e);
        }
        xof(e) {
          return nq(e), this.xofInto(new Uint8Array(e));
        }
        digestInto(e) {
          if ((nK(e, this), this.finished))
            throw Error("digest() was already called");
          return this.writeInto(e), this.destroy(), e;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          (this.destroyed = !0), this.state.fill(0);
        }
        _cloneInto(e) {
          let {
            blockLen: t,
            suffix: r,
            outputLen: i,
            rounds: s,
            enableXOF: n,
          } = this;
          return (
            e || (e = new ah(t, r, i, n, s)),
            e.state32.set(this.state32),
            (e.pos = this.pos),
            (e.posOut = this.posOut),
            (e.finished = this.finished),
            (e.rounds = s),
            (e.suffix = r),
            (e.outputLen = i),
            (e.enableXOF = n),
            (e.destroyed = this.destroyed),
            e
          );
        }
      }
      let ap = n4(() => new ah(136, 1, 32));
      function af(e) {
        let t = `Ethereum Signed Message:
${e.length}`,
          r = new TextEncoder().encode(t + e);
        return "0x" + nn.from(ap(r)).toString("hex");
      }
      async function ag(e, t, r, i, s, n) {
        switch (r.t) {
          case "eip191":
            return await am(e, t, r.s);
          case "eip1271":
            return await ay(e, t, r.s, i, s, n);
          default:
            throw Error(
              `verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${r.t}`
            );
        }
      }
      async function am(e, t, r) {
        return (
          (await ij({ hash: af(t), signature: r })).toLowerCase() ===
          e.toLowerCase()
        );
      }
      async function ay(e, t, r, i, s, n) {
        let a = na(i);
        if (!a.namespace || !a.reference)
          throw Error(
            `isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${i}`
          );
        try {
          let a = "0x1626ba7e",
            o = r.substring(2),
            c = af(t).substring(2),
            l =
              a +
              c +
              "00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000041" +
              o,
            u = await fetch(
              `${
                n || "https://rpc.walletconnect.org/v1"
              }/?chainId=${i}&projectId=${s}`,
              {
                method: "POST",
                body: JSON.stringify({
                  id: Date.now() + Math.floor(1e3 * Math.random()),
                  jsonrpc: "2.0",
                  method: "eth_call",
                  params: [{ to: e, data: l }, "latest"],
                }),
              }
            ),
            { result: d } = await u.json();
          return !!d && d.slice(0, a.length).toLowerCase() === a.toLowerCase();
        } catch (e) {
          return console.error("isValidEip1271Signature: ", e), !1;
        }
      }
      var ab = Object.defineProperty,
        aw = Object.defineProperties,
        av = Object.getOwnPropertyDescriptors,
        aE = Object.getOwnPropertySymbols,
        a_ = Object.prototype.hasOwnProperty,
        aC = Object.prototype.propertyIsEnumerable,
        aA = (e, t, r) =>
          t in e
            ? ab(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        aI = (e, t) => {
          for (var r in t || (t = {})) a_.call(t, r) && aA(e, r, t[r]);
          if (aE) for (var r of aE(t)) aC.call(t, r) && aA(e, r, t[r]);
          return e;
        },
        aS = (e, t) => aw(e, av(t));
      let aN = (e) => e?.split(":"),
        aT = (e) => {
          let t = e && aN(e);
          if (t) return e.includes("did:pkh:") ? t[3] : t[1];
        },
        aO = (e) => {
          let t = e && aN(e);
          if (t) return t[2] + ":" + t[3];
        },
        ax = (e) => {
          let t = e && aN(e);
          if (t) return t.pop();
        };
      async function aP(e) {
        let { cacao: t, projectId: r } = e,
          { s: i, p: s } = t,
          n = aR(s, s.iss),
          a = ax(s.iss);
        return await ag(a, n, i, aO(s.iss), r);
      }
      let aR = (e, t) => {
        let r = `${e.domain} wants you to sign in with your Ethereum account:`,
          i = ax(t);
        if (!e.aud && !e.uri)
          throw Error(
            "Either `aud` or `uri` is required to construct the message"
          );
        let s = e.statement || void 0,
          n = `URI: ${e.aud || e.uri}`,
          a = `Version: ${e.version}`,
          o = `Chain ID: ${aT(t)}`,
          c = `Nonce: ${e.nonce}`,
          l = `Issued At: ${e.iat}`,
          u = e.exp ? `Expiration Time: ${e.exp}` : void 0,
          d = e.nbf ? `Not Before: ${e.nbf}` : void 0,
          h = e.requestId ? `Request ID: ${e.requestId}` : void 0,
          p = e.resources
            ? `Resources:${e.resources
                .map(
                  (e) => `
- ${e}`
                )
                .join("")}`
            : void 0,
          f = aj(e.resources);
        return (
          f &&
            (s = (function (e = "", t) {
              ak(t);
              let r =
                "I further authorize the stated URI to perform the following actions on my behalf: ";
              if (e.includes(r)) return e;
              let i = [],
                s = 0;
              Object.keys(t.att).forEach((e) => {
                let r = Object.keys(t.att[e]).map((e) => ({
                  ability: e.split("/")[0],
                  action: e.split("/")[1],
                }));
                r.sort((e, t) => e.action.localeCompare(t.action));
                let n = {};
                r.forEach((e) => {
                  n[e.ability] || (n[e.ability] = []),
                    n[e.ability].push(e.action);
                });
                let a = Object.keys(n).map(
                  (t) => (
                    s++, `(${s}) '${t}': '${n[t].join("', '")}' for '${e}'.`
                  )
                );
                i.push(a.join(", ").replace(".,", "."));
              });
              let n = i.join(" "),
                a = `${r}${n}`;
              return `${e ? e + " " : ""}${a}`;
            })(s, aU(f))),
          [r, i, "", s, "", n, a, o, c, l, u, d, h, p].filter((e) => null != e)
            .join(`
`)
        );
      };
      function ak(e) {
        if (!e) throw Error("No recap provided, value is undefined");
        if (!e.att) throw Error("No `att` property found");
        let t = Object.keys(e.att);
        if (!(null != t && t.length))
          throw Error("No resources found in `att` property");
        t.forEach((t) => {
          let r = e.att[t];
          if (Array.isArray(r) || "object" != typeof r)
            throw Error(`Resource must be an object: ${t}`);
          if (!Object.keys(r).length)
            throw Error(`Resource object is empty: ${t}`);
          Object.keys(r).forEach((e) => {
            let t = r[e];
            if (!Array.isArray(t))
              throw Error(
                `Ability limits ${e} must be an array of objects, found: ${t}`
              );
            if (!t.length)
              throw Error(
                `Value of ${e} is empty array, must be an array with objects`
              );
            t.forEach((t) => {
              if ("object" != typeof t)
                throw Error(
                  `Ability limits (${e}) must be an array of objects, found: ${t}`
                );
            });
          });
        });
      }
      function aD(e) {
        return (
          ak(e),
          `urn:recap:${nn
            .from(JSON.stringify(e))
            .toString("base64")
            .replace(/=/g, "")}`
        );
      }
      function aU(e) {
        var t;
        let r =
          ((t = e.replace("urn:recap:", "")),
          JSON.parse(nn.from(t, "base64").toString("utf-8")));
        return ak(r), r;
      }
      function aL(e) {
        var t;
        let r = aU(e);
        ak(r);
        let i = null == (t = r.att) ? void 0 : t.eip155;
        return i ? Object.keys(i).map((e) => e.split("/")[1]) : [];
      }
      function aM(e) {
        let t = aU(e);
        ak(t);
        let r = [];
        return (
          Object.values(t.att).forEach((e) => {
            Object.values(e).forEach((e) => {
              var t;
              null != (t = e?.[0]) && t.chains && r.push(e[0].chains);
            });
          }),
          [...new Set(r.flat())]
        );
      }
      function aj(e) {
        var t;
        if (!e) return;
        let r = e?.[e.length - 1];
        return (t = r) && t.includes("urn:recap:") ? r : void 0;
      }
      function a$(e) {
        if (!Number.isSafeInteger(e) || e < 0)
          throw Error("positive integer expected, got " + e);
      }
      function aB(e) {
        return (
          e instanceof Uint8Array ||
          (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
        );
      }
      function aF(e, ...t) {
        if (!aB(e)) throw Error("Uint8Array expected");
        if (t.length > 0 && !t.includes(e.length))
          throw Error(
            "Uint8Array expected of length " + t + ", got length=" + e.length
          );
      }
      function aW(e, t = !0) {
        if (e.destroyed) throw Error("Hash instance has been destroyed");
        if (t && e.finished)
          throw Error("Hash#digest() has already been called");
      }
      function aq(e) {
        if ("boolean" != typeof e) throw Error(`boolean expected, not ${e}`);
      }
      let aH = (e) =>
          new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)),
        az = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
      if (68 !== new Uint8Array(new Uint32Array([0x11223344]).buffer)[0])
        throw Error("Non little-endian hardware is not supported");
      function aV(e) {
        if ("string" == typeof e)
          e = (function (e) {
            if ("string" != typeof e) throw Error("string expected");
            return new Uint8Array(new TextEncoder().encode(e));
          })(e);
        else if (aB(e)) e = aY(e);
        else throw Error("Uint8Array expected, got " + typeof e);
        return e;
      }
      function aK(e, t, r = !0) {
        if (void 0 === t) return new Uint8Array(e);
        if (t.length !== e)
          throw Error(
            "invalid output length, expected " + e + ", got: " + t.length
          );
        if (r && t.byteOffset % 4 != 0)
          throw Error("invalid output, must be aligned");
        return t;
      }
      function aG(e, t, r, i) {
        if ("function" == typeof e.setBigUint64) return e.setBigUint64(t, r, i);
        let s = BigInt(32),
          n = BigInt(0xffffffff),
          a = Number((r >> s) & n),
          o = Number(r & n),
          c = 4 * !!i,
          l = 4 * !i;
        e.setUint32(t + c, a, i), e.setUint32(t + l, o, i);
      }
      function aY(e) {
        return Uint8Array.from(e);
      }
      function aZ(...e) {
        for (let t = 0; t < e.length; t++) e[t].fill(0);
      }
      let aJ = (e) => Uint8Array.from(e.split("").map((e) => e.charCodeAt(0))),
        aX = aJ("expand 16-byte k"),
        aQ = aJ("expand 32-byte k"),
        a0 = aH(aX),
        a1 = aH(aQ);
      function a2(e, t) {
        return (e << t) | (e >>> (32 - t));
      }
      function a3(e) {
        return e.byteOffset % 4 == 0;
      }
      let a5 = 0x100000000 - 1,
        a8 = new Uint32Array(),
        a6 = (e, t) => (255 & e[t++]) | ((255 & e[t++]) << 8);
      class a4 {
        constructor(e) {
          (this.blockLen = 16),
            (this.outputLen = 16),
            (this.buffer = new Uint8Array(16)),
            (this.r = new Uint16Array(10)),
            (this.h = new Uint16Array(10)),
            (this.pad = new Uint16Array(8)),
            (this.pos = 0),
            (this.finished = !1),
            aF((e = aV(e)), 32);
          let t = a6(e, 0),
            r = a6(e, 2),
            i = a6(e, 4),
            s = a6(e, 6),
            n = a6(e, 8),
            a = a6(e, 10),
            o = a6(e, 12),
            c = a6(e, 14);
          (this.r[0] = 8191 & t),
            (this.r[1] = ((t >>> 13) | (r << 3)) & 8191),
            (this.r[2] = ((r >>> 10) | (i << 6)) & 7939),
            (this.r[3] = ((i >>> 7) | (s << 9)) & 8191),
            (this.r[4] = ((s >>> 4) | (n << 12)) & 255),
            (this.r[5] = (n >>> 1) & 8190),
            (this.r[6] = ((n >>> 14) | (a << 2)) & 8191),
            (this.r[7] = ((a >>> 11) | (o << 5)) & 8065),
            (this.r[8] = ((o >>> 8) | (c << 8)) & 8191),
            (this.r[9] = (c >>> 5) & 127);
          for (let t = 0; t < 8; t++) this.pad[t] = a6(e, 16 + 2 * t);
        }
        process(e, t, r = !1) {
          let { h: i, r: s } = this,
            n = s[0],
            a = s[1],
            o = s[2],
            c = s[3],
            l = s[4],
            u = s[5],
            d = s[6],
            h = s[7],
            p = s[8],
            f = s[9],
            g = a6(e, t + 0),
            m = a6(e, t + 2),
            y = a6(e, t + 4),
            b = a6(e, t + 6),
            w = a6(e, t + 8),
            v = a6(e, t + 10),
            E = a6(e, t + 12),
            _ = a6(e, t + 14),
            C = i[0] + (8191 & g),
            A = i[1] + (((g >>> 13) | (m << 3)) & 8191),
            I = i[2] + (((m >>> 10) | (y << 6)) & 8191),
            S = i[3] + (((y >>> 7) | (b << 9)) & 8191),
            N = i[4] + (((b >>> 4) | (w << 12)) & 8191),
            T = i[5] + ((w >>> 1) & 8191),
            O = i[6] + (((w >>> 14) | (v << 2)) & 8191),
            x = i[7] + (((v >>> 11) | (E << 5)) & 8191),
            P = i[8] + (((E >>> 8) | (_ << 8)) & 8191),
            R = i[9] + ((_ >>> 5) | (2048 * !r)),
            k = 0,
            D = 0 + C * n + 5 * f * A + 5 * p * I + 5 * h * S + 5 * d * N;
          (k = D >>> 13),
            (D &= 8191),
            (D += 5 * u * T + 5 * l * O + 5 * c * x + 5 * o * P + 5 * a * R),
            (k += D >>> 13),
            (D &= 8191);
          let U = k + C * a + A * n + 5 * f * I + 5 * p * S + 5 * h * N;
          (k = U >>> 13),
            (U &= 8191),
            (U += 5 * d * T + 5 * u * O + 5 * l * x + 5 * c * P + 5 * o * R),
            (k += U >>> 13),
            (U &= 8191);
          let L = k + C * o + A * a + I * n + 5 * f * S + 5 * p * N;
          (k = L >>> 13),
            (L &= 8191),
            (L += 5 * h * T + 5 * d * O + 5 * u * x + 5 * l * P + 5 * c * R),
            (k += L >>> 13),
            (L &= 8191);
          let M = k + C * c + A * o + I * a + S * n + 5 * f * N;
          (k = M >>> 13),
            (M &= 8191),
            (M += 5 * p * T + 5 * h * O + 5 * d * x + 5 * u * P + 5 * l * R),
            (k += M >>> 13),
            (M &= 8191);
          let j = k + C * l + A * c + I * o + S * a + N * n;
          (k = j >>> 13),
            (j &= 8191),
            (j += 5 * f * T + 5 * p * O + 5 * h * x + 5 * d * P + 5 * u * R),
            (k += j >>> 13),
            (j &= 8191);
          let $ = k + C * u + A * l + I * c + S * o + N * a;
          (k = $ >>> 13),
            ($ &= 8191),
            ($ += T * n + 5 * f * O + 5 * p * x + 5 * h * P + 5 * d * R),
            (k += $ >>> 13),
            ($ &= 8191);
          let B = k + C * d + A * u + I * l + S * c + N * o;
          (k = B >>> 13),
            (B &= 8191),
            (B += T * a + O * n + 5 * f * x + 5 * p * P + 5 * h * R),
            (k += B >>> 13),
            (B &= 8191);
          let F = k + C * h + A * d + I * u + S * l + N * c;
          (k = F >>> 13),
            (F &= 8191),
            (F += T * o + O * a + x * n + 5 * f * P + 5 * p * R),
            (k += F >>> 13),
            (F &= 8191);
          let W = k + C * p + A * h + I * d + S * u + N * l;
          (k = W >>> 13),
            (W &= 8191),
            (W += T * c + O * o + x * a + P * n + 5 * f * R),
            (k += W >>> 13),
            (W &= 8191);
          let q = k + C * f + A * p + I * h + S * d + N * u;
          (k = q >>> 13),
            (q &= 8191),
            (q += T * l + O * c + x * o + P * a + R * n),
            (k += q >>> 13),
            (q &= 8191),
            (D = 8191 & (k = ((k = ((k << 2) + k) | 0) + D) | 0)),
            (k >>>= 13),
            (U += k),
            (i[0] = D),
            (i[1] = U),
            (i[2] = L),
            (i[3] = M),
            (i[4] = j),
            (i[5] = $),
            (i[6] = B),
            (i[7] = F),
            (i[8] = W),
            (i[9] = q);
        }
        finalize() {
          let { h: e, pad: t } = this,
            r = new Uint16Array(10),
            i = e[1] >>> 13;
          e[1] &= 8191;
          for (let t = 2; t < 10; t++)
            (e[t] += i), (i = e[t] >>> 13), (e[t] &= 8191);
          (e[0] += 5 * i),
            (i = e[0] >>> 13),
            (e[0] &= 8191),
            (e[1] += i),
            (i = e[1] >>> 13),
            (e[1] &= 8191),
            (e[2] += i),
            (r[0] = e[0] + 5),
            (i = r[0] >>> 13),
            (r[0] &= 8191);
          for (let t = 1; t < 10; t++)
            (r[t] = e[t] + i), (i = r[t] >>> 13), (r[t] &= 8191);
          r[9] -= 8192;
          let s = (1 ^ i) - 1;
          for (let e = 0; e < 10; e++) r[e] &= s;
          s = ~s;
          for (let t = 0; t < 10; t++) e[t] = (e[t] & s) | r[t];
          (e[0] = (e[0] | (e[1] << 13)) & 65535),
            (e[1] = ((e[1] >>> 3) | (e[2] << 10)) & 65535),
            (e[2] = ((e[2] >>> 6) | (e[3] << 7)) & 65535),
            (e[3] = ((e[3] >>> 9) | (e[4] << 4)) & 65535),
            (e[4] = ((e[4] >>> 12) | (e[5] << 1) | (e[6] << 14)) & 65535),
            (e[5] = ((e[6] >>> 2) | (e[7] << 11)) & 65535),
            (e[6] = ((e[7] >>> 5) | (e[8] << 8)) & 65535),
            (e[7] = ((e[8] >>> 8) | (e[9] << 5)) & 65535);
          let n = e[0] + t[0];
          e[0] = 65535 & n;
          for (let r = 1; r < 8; r++)
            (n = (((e[r] + t[r]) | 0) + (n >>> 16)) | 0), (e[r] = 65535 & n);
          aZ(r);
        }
        update(e) {
          aW(this);
          let { buffer: t, blockLen: r } = this,
            i = (e = aV(e)).length;
          for (let s = 0; s < i; ) {
            let n = Math.min(r - this.pos, i - s);
            if (n === r) {
              for (; r <= i - s; s += r) this.process(e, s);
              continue;
            }
            t.set(e.subarray(s, s + n), this.pos),
              (this.pos += n),
              (s += n),
              this.pos === r && (this.process(t, 0, !1), (this.pos = 0));
          }
          return this;
        }
        destroy() {
          aZ(this.h, this.r, this.buffer, this.pad);
        }
        digestInto(e) {
          aW(this),
            (function (e, t) {
              aF(e);
              let r = t.outputLen;
              if (e.length < r)
                throw Error(
                  "digestInto() expects output buffer of length at least " + r
                );
            })(e, this),
            (this.finished = !0);
          let { buffer: t, h: r } = this,
            { pos: i } = this;
          if (i) {
            for (t[i++] = 1; i < 16; i++) t[i] = 0;
            this.process(t, 0, !0);
          }
          this.finalize();
          let s = 0;
          for (let t = 0; t < 8; t++)
            (e[s++] = r[t] >>> 0), (e[s++] = r[t] >>> 8);
          return e;
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let r = e.slice(0, t);
          return this.destroy(), r;
        }
      }
      let a9 = (function (e) {
          let t = (t, r) => e(r).update(aV(t)).digest(),
            r = e(new Uint8Array(32));
          return (
            (t.outputLen = r.outputLen),
            (t.blockLen = r.blockLen),
            (t.create = (t) => e(t)),
            t
          );
        })((e) => new a4(e)),
        a7 = (function (e, t) {
          let {
            allowShortKeys: r,
            extendNonceFn: i,
            counterLength: s,
            counterRight: n,
            rounds: a,
          } = (function (e, t) {
            if (null == t || "object" != typeof t)
              throw Error("options must be defined");
            return Object.assign(e, t);
          })(
            {
              allowShortKeys: !1,
              counterLength: 8,
              counterRight: !1,
              rounds: 20,
            },
            t
          );
          if ("function" != typeof e) throw Error("core must be a function");
          return (
            a$(s),
            a$(a),
            aq(n),
            aq(r),
            (t, o, c, l, u = 0) => {
              aF(t), aF(o), aF(c);
              let d = c.length;
              if (
                (void 0 === l && (l = new Uint8Array(d)),
                aF(l),
                a$(u),
                u < 0 || u >= a5)
              )
                throw Error("arx: counter overflow");
              if (l.length < d)
                throw Error(
                  `arx: output (${l.length}) is shorter than data (${d})`
                );
              let h = [],
                p = t.length,
                f,
                g;
              if (32 === p) h.push((f = aY(t))), (g = a1);
              else if (16 === p && r)
                (f = new Uint8Array(32)).set(t),
                  f.set(t, 16),
                  (g = a0),
                  h.push(f);
              else throw Error(`arx: invalid 32-byte key, got length=${p}`);
              a3(o) || h.push((o = aY(o)));
              let m = aH(f);
              if (i) {
                if (24 !== o.length)
                  throw Error("arx: extended nonce must be 24 bytes");
                i(g, m, aH(o.subarray(0, 16)), m), (o = o.subarray(16));
              }
              let y = 16 - s;
              if (y !== o.length)
                throw Error(`arx: nonce must be ${y} or 16 bytes`);
              if (12 !== y) {
                let e = new Uint8Array(12);
                e.set(o, n ? 0 : 12 - o.length), (o = e), h.push(o);
              }
              return (
                (function (e, t, r, i, s, n, a, o) {
                  let c = s.length,
                    l = new Uint8Array(64),
                    u = aH(l),
                    d = a3(s) && a3(n),
                    h = d ? aH(s) : a8,
                    p = d ? aH(n) : a8;
                  for (let f = 0; f < c; a++) {
                    if ((e(t, r, i, u, a, o), a >= a5))
                      throw Error("arx: counter overflow");
                    let g = Math.min(64, c - f);
                    if (d && 64 === g) {
                      let e = f / 4;
                      if (f % 4 != 0)
                        throw Error("arx: invalid block position");
                      for (let t = 0, r; t < 16; t++)
                        p[(r = e + t)] = h[r] ^ u[t];
                      f += 64;
                      continue;
                    }
                    for (let e = 0, t; e < g; e++) n[(t = f + e)] = s[t] ^ l[e];
                    f += g;
                  }
                })(e, g, m, aH(o), c, l, u, a),
                aZ(...h),
                l
              );
            }
          );
        })(
          function (e, t, r, i, s, n = 20) {
            let a = e[0],
              o = e[1],
              c = e[2],
              l = e[3],
              u = t[0],
              d = t[1],
              h = t[2],
              p = t[3],
              f = t[4],
              g = t[5],
              m = t[6],
              y = t[7],
              b = r[0],
              w = r[1],
              v = r[2],
              E = a,
              _ = o,
              C = c,
              A = l,
              I = u,
              S = d,
              N = h,
              T = p,
              O = f,
              x = g,
              P = m,
              R = y,
              k = s,
              D = b,
              U = w,
              L = v;
            for (let e = 0; e < n; e += 2)
              (O = (O + (k = a2(k ^ (E = (E + I) | 0), 16))) | 0),
                (E = (E + (I = a2(I ^ O, 12))) | 0),
                (O = (O + (k = a2(k ^ E, 8))) | 0),
                (I = a2(I ^ O, 7)),
                (x = (x + (D = a2(D ^ (_ = (_ + S) | 0), 16))) | 0),
                (_ = (_ + (S = a2(S ^ x, 12))) | 0),
                (x = (x + (D = a2(D ^ _, 8))) | 0),
                (S = a2(S ^ x, 7)),
                (P = (P + (U = a2(U ^ (C = (C + N) | 0), 16))) | 0),
                (C = (C + (N = a2(N ^ P, 12))) | 0),
                (P = (P + (U = a2(U ^ C, 8))) | 0),
                (N = a2(N ^ P, 7)),
                (R = (R + (L = a2(L ^ (A = (A + T) | 0), 16))) | 0),
                (A = (A + (T = a2(T ^ R, 12))) | 0),
                (R = (R + (L = a2(L ^ A, 8))) | 0),
                (T = a2(T ^ R, 7)),
                (P = (P + (L = a2(L ^ (E = (E + S) | 0), 16))) | 0),
                (E = (E + (S = a2(S ^ P, 12))) | 0),
                (P = (P + (L = a2(L ^ E, 8))) | 0),
                (S = a2(S ^ P, 7)),
                (R = (R + (k = a2(k ^ (_ = (_ + N) | 0), 16))) | 0),
                (_ = (_ + (N = a2(N ^ R, 12))) | 0),
                (R = (R + (k = a2(k ^ _, 8))) | 0),
                (N = a2(N ^ R, 7)),
                (O = (O + (D = a2(D ^ (C = (C + T) | 0), 16))) | 0),
                (C = (C + (T = a2(T ^ O, 12))) | 0),
                (O = (O + (D = a2(D ^ C, 8))) | 0),
                (T = a2(T ^ O, 7)),
                (x = (x + (U = a2(U ^ (A = (A + I) | 0), 16))) | 0),
                (A = (A + (I = a2(I ^ x, 12))) | 0),
                (x = (x + (U = a2(U ^ A, 8))) | 0),
                (I = a2(I ^ x, 7));
            let M = 0;
            (i[M++] = (a + E) | 0),
              (i[M++] = (o + _) | 0),
              (i[M++] = (c + C) | 0),
              (i[M++] = (l + A) | 0),
              (i[M++] = (u + I) | 0),
              (i[M++] = (d + S) | 0),
              (i[M++] = (h + N) | 0),
              (i[M++] = (p + T) | 0),
              (i[M++] = (f + O) | 0),
              (i[M++] = (g + x) | 0),
              (i[M++] = (m + P) | 0),
              (i[M++] = (y + R) | 0),
              (i[M++] = (s + k) | 0),
              (i[M++] = (b + D) | 0),
              (i[M++] = (w + U) | 0),
              (i[M++] = (v + L) | 0);
          },
          { counterRight: !1, counterLength: 4, allowShortKeys: !1 }
        ),
        oe = new Uint8Array(16),
        ot = (e, t) => {
          e.update(t);
          let r = t.length % 16;
          r && e.update(oe.subarray(r));
        },
        or = new Uint8Array(32);
      function oi(e, t, r, i, s) {
        let n = e(t, r, or),
          a = a9.create(n);
        s && ot(a, s), ot(a, i);
        let o = new Uint8Array(16),
          c = az(o);
        aG(c, 0, BigInt(s ? s.length : 0), !0),
          aG(c, 8, BigInt(i.length), !0),
          a.update(o);
        let l = a.digest();
        return aZ(n, o), l;
      }
      let os = ((e, t) => {
        function r(i, ...s) {
          if ((aF(i), void 0 !== e.nonceLength)) {
            let t = s[0];
            if (!t) throw Error("nonce / iv required");
            e.varSizeNonce ? aF(t) : aF(t, e.nonceLength);
          }
          let n = e.tagLength;
          n && void 0 !== s[1] && aF(s[1]);
          let a = t(i, ...s),
            o = (e, t) => {
              if (void 0 !== t) {
                if (2 !== e) throw Error("cipher output not supported");
                aF(t);
              }
            },
            c = !1;
          return {
            encrypt(e, t) {
              if (c)
                throw Error("cannot encrypt() twice with same key + nonce");
              return (c = !0), aF(e), o(a.encrypt.length, t), a.encrypt(e, t);
            },
            decrypt(e, t) {
              if ((aF(e), n && e.length < n))
                throw Error(
                  "invalid ciphertext length: smaller than tagLength=" + n
                );
              return o(a.decrypt.length, t), a.decrypt(e, t);
            },
          };
        }
        return Object.assign(r, e), r;
      })(
        { blockSize: 64, nonceLength: 12, tagLength: 16 },
        ((e) => (t, r, i) => ({
          encrypt(s, n) {
            let a = s.length;
            (n = aK(a + 16, n, !1)).set(s);
            let o = n.subarray(0, -16);
            e(t, r, o, o, 1);
            let c = oi(e, t, r, o, i);
            return n.set(c, a), aZ(c), n;
          },
          decrypt(s, n) {
            n = aK(s.length - 16, n, !1);
            let a = s.subarray(0, -16),
              o = s.subarray(-16),
              c = oi(e, t, r, a, i);
            if (
              !(function (e, t) {
                if (e.length !== t.length) return !1;
                let r = 0;
                for (let i = 0; i < e.length; i++) r |= e[i] ^ t[i];
                return 0 === r;
              })(o, c)
            )
              throw Error("invalid tag");
            return n.set(s.subarray(0, -16)), e(t, r, n, n, 1), aZ(c), n;
          },
        }))(a7)
      );
      class on extends n6 {
        constructor(e, t) {
          super(), (this.finished = !1), (this.destroyed = !1), nz(e);
          let r = n8(t);
          if (
            ((this.iHash = e.create()), "function" != typeof this.iHash.update)
          )
            throw Error("Expected instance of class which extends utils.Hash");
          (this.blockLen = this.iHash.blockLen),
            (this.outputLen = this.iHash.outputLen);
          let i = this.blockLen,
            s = new Uint8Array(i);
          s.set(r.length > i ? e.create().update(r).digest() : r);
          for (let e = 0; e < s.length; e++) s[e] ^= 54;
          this.iHash.update(s), (this.oHash = e.create());
          for (let e = 0; e < s.length; e++) s[e] ^= 106;
          this.oHash.update(s), s.fill(0);
        }
        update(e) {
          return nV(this), this.iHash.update(e), this;
        }
        digestInto(e) {
          nV(this),
            nH(e, this.outputLen),
            (this.finished = !0),
            this.iHash.digestInto(e),
            this.oHash.update(e),
            this.oHash.digestInto(e),
            this.destroy();
        }
        digest() {
          let e = new Uint8Array(this.oHash.outputLen);
          return this.digestInto(e), e;
        }
        _cloneInto(e) {
          e || (e = Object.create(Object.getPrototypeOf(this), {}));
          let {
            oHash: t,
            iHash: r,
            finished: i,
            destroyed: s,
            blockLen: n,
            outputLen: a,
          } = this;
          return (
            (e.finished = i),
            (e.destroyed = s),
            (e.blockLen = n),
            (e.outputLen = a),
            (e.oHash = t._cloneInto(e.oHash)),
            (e.iHash = r._cloneInto(e.iHash)),
            e
          );
        }
        destroy() {
          (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
        }
      }
      let oa = (e, t, r) => new on(e, t).update(r).digest();
      oa.create = (e, t) => new on(e, t);
      let oo = new Uint8Array([0]),
        oc = new Uint8Array(),
        ol = (e, t, r, i, s) =>
          (function (e, t, r, i = 32) {
            if ((nz(e), nq(i), i > 255 * e.outputLen))
              throw Error("Length should be <= 255*HashLen");
            let s = Math.ceil(i / e.outputLen);
            void 0 === r && (r = oc);
            let n = new Uint8Array(s * e.outputLen),
              a = oa.create(e, t),
              o = a._cloneInto(),
              c = new Uint8Array(a.outputLen);
            for (let t = 0; t < s; t++)
              (oo[0] = t + 1),
                o
                  .update(0 === t ? oc : c)
                  .update(r)
                  .update(oo)
                  .digestInto(c),
                n.set(c, e.outputLen * t),
                a._cloneInto(o);
            return (
              a.destroy(), o.destroy(), c.fill(0), oo.fill(0), n.slice(0, i)
            );
          })(
            e,
            (function (e, t, r) {
              return (
                nz(e),
                void 0 === r && (r = new Uint8Array(e.outputLen)),
                oa(e, n8(r), n8(t))
              );
            })(e, t, r),
            i,
            s
          );
      class ou extends n6 {
        constructor(e, t, r, i) {
          super(),
            (this.blockLen = e),
            (this.outputLen = t),
            (this.padOffset = r),
            (this.isLE = i),
            (this.finished = !1),
            (this.length = 0),
            (this.pos = 0),
            (this.destroyed = !1),
            (this.buffer = new Uint8Array(e)),
            (this.view = n1(this.buffer));
        }
        update(e) {
          nV(this);
          let { view: t, buffer: r, blockLen: i } = this,
            s = (e = n8(e)).length;
          for (let n = 0; n < s; ) {
            let a = Math.min(i - this.pos, s - n);
            if (a === i) {
              let t = n1(e);
              for (; i <= s - n; n += i) this.process(t, n);
              continue;
            }
            r.set(e.subarray(n, n + a), this.pos),
              (this.pos += a),
              (n += a),
              this.pos === i && (this.process(t, 0), (this.pos = 0));
          }
          return (this.length += e.length), this.roundClean(), this;
        }
        digestInto(e) {
          nV(this), nK(e, this), (this.finished = !0);
          let { buffer: t, view: r, blockLen: i, isLE: s } = this,
            { pos: n } = this;
          (t[n++] = 128),
            this.buffer.subarray(n).fill(0),
            this.padOffset > i - n && (this.process(r, 0), (n = 0));
          for (let e = n; e < i; e++) t[e] = 0;
          (function (e, t, r, i) {
            if ("function" == typeof e.setBigUint64)
              return e.setBigUint64(t, r, i);
            let s = BigInt(32),
              n = BigInt(0xffffffff),
              a = Number((r >> s) & n),
              o = Number(r & n),
              c = 4 * !!i,
              l = 4 * !i;
            e.setUint32(t + c, a, i), e.setUint32(t + l, o, i);
          })(r, i - 8, BigInt(8 * this.length), s),
            this.process(r, 0);
          let a = n1(e),
            o = this.outputLen;
          if (o % 4) throw Error("_sha2: outputLen should be aligned to 32bit");
          let c = o / 4,
            l = this.get();
          if (c > l.length) throw Error("_sha2: outputLen bigger than state");
          for (let e = 0; e < c; e++) a.setUint32(4 * e, l[e], s);
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let r = e.slice(0, t);
          return this.destroy(), r;
        }
        _cloneInto(e) {
          e || (e = new this.constructor()), e.set(...this.get());
          let {
            blockLen: t,
            buffer: r,
            length: i,
            finished: s,
            destroyed: n,
            pos: a,
          } = this;
          return (
            (e.length = i),
            (e.pos = a),
            (e.finished = s),
            (e.destroyed = n),
            i % t && e.buffer.set(r),
            e
          );
        }
      }
      let od = new Uint32Array([
          0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
          0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
          0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
          0xc19bf174, 0xe49b69c1, 0xefbe4786, 0xfc19dc6, 0x240ca1cc, 0x2de92c6f,
          0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d,
          0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x6ca6351, 0x14292967,
          0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354,
          0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
          0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585,
          0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
          0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee,
          0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb,
          0xbef9a3f7, 0xc67178f2,
        ]),
        oh = new Uint32Array([
          0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f,
          0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
        ]),
        op = new Uint32Array(64);
      class of extends ou {
        constructor() {
          super(64, 32, 8, !1),
            (this.A = 0 | oh[0]),
            (this.B = 0 | oh[1]),
            (this.C = 0 | oh[2]),
            (this.D = 0 | oh[3]),
            (this.E = 0 | oh[4]),
            (this.F = 0 | oh[5]),
            (this.G = 0 | oh[6]),
            (this.H = 0 | oh[7]);
        }
        get() {
          let { A: e, B: t, C: r, D: i, E: s, F: n, G: a, H: o } = this;
          return [e, t, r, i, s, n, a, o];
        }
        set(e, t, r, i, s, n, a, o) {
          (this.A = 0 | e),
            (this.B = 0 | t),
            (this.C = 0 | r),
            (this.D = 0 | i),
            (this.E = 0 | s),
            (this.F = 0 | n),
            (this.G = 0 | a),
            (this.H = 0 | o);
        }
        process(e, t) {
          for (let r = 0; r < 16; r++, t += 4) op[r] = e.getUint32(t, !1);
          for (let e = 16; e < 64; e++) {
            let t = op[e - 15],
              r = op[e - 2],
              i = n2(t, 7) ^ n2(t, 18) ^ (t >>> 3),
              s = n2(r, 17) ^ n2(r, 19) ^ (r >>> 10);
            op[e] = (s + op[e - 7] + i + op[e - 16]) | 0;
          }
          let { A: r, B: i, C: s, D: n, E: a, F: o, G: c, H: l } = this;
          for (let e = 0; e < 64; e++) {
            var u, d, h, p;
            let t =
                (l +
                  (n2(a, 6) ^ n2(a, 11) ^ n2(a, 25)) +
                  (((u = a) & o) ^ (~u & c)) +
                  od[e] +
                  op[e]) |
                0,
              f =
                ((n2(r, 2) ^ n2(r, 13) ^ n2(r, 22)) +
                  (((d = r) & (h = i)) ^ (d & (p = s)) ^ (h & p))) |
                0;
            (l = c),
              (c = o),
              (o = a),
              (a = (n + t) | 0),
              (n = s),
              (s = i),
              (i = r),
              (r = (t + f) | 0);
          }
          (r = (r + this.A) | 0),
            (i = (i + this.B) | 0),
            (s = (s + this.C) | 0),
            (n = (n + this.D) | 0),
            (a = (a + this.E) | 0),
            (o = (o + this.F) | 0),
            (c = (c + this.G) | 0),
            (l = (l + this.H) | 0),
            this.set(r, i, s, n, a, o, c, l);
        }
        roundClean() {
          op.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
        }
      }
      let og = n4(() => new of()),
        om = BigInt(0),
        oy = BigInt(1),
        ob = BigInt(2);
      function ow(e) {
        return (
          e instanceof Uint8Array ||
          (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
        );
      }
      function ov(e) {
        if (!ow(e)) throw Error("Uint8Array expected");
      }
      function oE(e, t) {
        if ("boolean" != typeof t)
          throw Error(e + " boolean expected, got " + t);
      }
      let o_ = Array.from({ length: 256 }, (e, t) =>
        t.toString(16).padStart(2, "0")
      );
      function oC(e) {
        ov(e);
        let t = "";
        for (let r = 0; r < e.length; r++) t += o_[e[r]];
        return t;
      }
      function oA(e) {
        let t = e.toString(16);
        return 1 & t.length ? "0" + t : t;
      }
      function oI(e) {
        if ("string" != typeof e)
          throw Error("hex string expected, got " + typeof e);
        return "" === e ? om : BigInt("0x" + e);
      }
      let oS = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      function oN(e) {
        return e >= oS._0 && e <= oS._9
          ? e - oS._0
          : e >= oS.A && e <= oS.F
          ? e - (oS.A - 10)
          : e >= oS.a && e <= oS.f
          ? e - (oS.a - 10)
          : void 0;
      }
      function oT(e) {
        if ("string" != typeof e)
          throw Error("hex string expected, got " + typeof e);
        let t = e.length,
          r = t / 2;
        if (t % 2)
          throw Error("hex string expected, got unpadded hex of length " + t);
        let i = new Uint8Array(r);
        for (let t = 0, s = 0; t < r; t++, s += 2) {
          let r = oN(e.charCodeAt(s)),
            n = oN(e.charCodeAt(s + 1));
          if (void 0 === r || void 0 === n)
            throw Error(
              'hex string expected, got non-hex character "' +
                (e[s] + e[s + 1]) +
                '" at index ' +
                s
            );
          i[t] = 16 * r + n;
        }
        return i;
      }
      function oO(e) {
        return oI(oC(e));
      }
      function ox(e) {
        return ov(e), oI(oC(Uint8Array.from(e).reverse()));
      }
      function oP(e, t) {
        return oT(e.toString(16).padStart(2 * t, "0"));
      }
      function oR(e, t) {
        return oP(e, t).reverse();
      }
      function ok(e, t, r) {
        let i;
        if ("string" == typeof t)
          try {
            i = oT(t);
          } catch (t) {
            throw Error(e + " must be hex string or Uint8Array, cause: " + t);
          }
        else if (ow(t)) i = Uint8Array.from(t);
        else throw Error(e + " must be hex string or Uint8Array");
        let s = i.length;
        if ("number" == typeof r && s !== r)
          throw Error(e + " of length " + r + " expected, got " + s);
        return i;
      }
      function oD(...e) {
        let t = 0;
        for (let r = 0; r < e.length; r++) {
          let i = e[r];
          ov(i), (t += i.length);
        }
        let r = new Uint8Array(t);
        for (let t = 0, i = 0; t < e.length; t++) {
          let s = e[t];
          r.set(s, i), (i += s.length);
        }
        return r;
      }
      let oU = (e) => "bigint" == typeof e && om <= e;
      function oL(e, t, r) {
        return oU(e) && oU(t) && oU(r) && t <= e && e < r;
      }
      function oM(e, t, r, i) {
        if (!oL(t, r, i))
          throw Error(
            "expected valid " + e + ": " + r + " <= n < " + i + ", got " + t
          );
      }
      function oj(e) {
        let t;
        for (t = 0; e > om; e >>= oy, t += 1);
        return t;
      }
      let o$ = (e) => (ob << BigInt(e - 1)) - oy,
        oB = (e) => new Uint8Array(e),
        oF = (e) => Uint8Array.from(e);
      function oW(e, t, r) {
        if ("number" != typeof e || e < 2)
          throw Error("hashLen must be a number");
        if ("number" != typeof t || t < 2)
          throw Error("qByteLen must be a number");
        if ("function" != typeof r) throw Error("hmacFn must be a function");
        let i = oB(e),
          s = oB(e),
          n = 0,
          a = () => {
            i.fill(1), s.fill(0), (n = 0);
          },
          o = (...e) => r(s, i, ...e),
          c = (e = oB()) => {
            (s = o(oF([0]), e)),
              (i = o()),
              0 !== e.length && ((s = o(oF([1]), e)), (i = o()));
          },
          l = () => {
            if (n++ >= 1e3) throw Error("drbg: tried 1000 values");
            let e = 0,
              r = [];
            for (; e < t; ) {
              let t = (i = o()).slice();
              r.push(t), (e += i.length);
            }
            return oD(...r);
          };
        return (e, t) => {
          let r;
          for (a(), c(e); !(r = t(l())); ) c();
          return a(), r;
        };
      }
      let oq = {
        bigint: (e) => "bigint" == typeof e,
        function: (e) => "function" == typeof e,
        boolean: (e) => "boolean" == typeof e,
        string: (e) => "string" == typeof e,
        stringOrUint8Array: (e) => "string" == typeof e || ow(e),
        isSafeInteger: (e) => Number.isSafeInteger(e),
        array: (e) => Array.isArray(e),
        field: (e, t) => t.Fp.isValid(e),
        hash: (e) =>
          "function" == typeof e && Number.isSafeInteger(e.outputLen),
      };
      function oH(e, t, r = {}) {
        let i = (t, r, i) => {
          let s = oq[r];
          if ("function" != typeof s) throw Error("invalid validator function");
          let n = e[t];
          if (!(i && void 0 === n) && !s(n, e))
            throw Error(
              "param " + String(t) + " is invalid. Expected " + r + ", got " + n
            );
        };
        for (let [e, r] of Object.entries(t)) i(e, r, !1);
        for (let [e, t] of Object.entries(r)) i(e, t, !0);
        return e;
      }
      function oz(e) {
        let t = new WeakMap();
        return (r, ...i) => {
          let s = t.get(r);
          if (void 0 !== s) return s;
          let n = e(r, ...i);
          return t.set(r, n), n;
        };
      }
      var oV = Object.freeze({
        __proto__: null,
        isBytes: ow,
        abytes: ov,
        abool: oE,
        bytesToHex: oC,
        numberToHexUnpadded: oA,
        hexToNumber: oI,
        hexToBytes: oT,
        bytesToNumberBE: oO,
        bytesToNumberLE: ox,
        numberToBytesBE: oP,
        numberToBytesLE: oR,
        numberToVarBytesBE: function (e) {
          return oT(oA(e));
        },
        ensureBytes: ok,
        concatBytes: oD,
        equalBytes: function (e, t) {
          if (e.length !== t.length) return !1;
          let r = 0;
          for (let i = 0; i < e.length; i++) r |= e[i] ^ t[i];
          return 0 === r;
        },
        utf8ToBytes: function (e) {
          if ("string" != typeof e) throw Error("string expected");
          return new Uint8Array(new TextEncoder().encode(e));
        },
        inRange: oL,
        aInRange: oM,
        bitLen: oj,
        bitGet: function (e, t) {
          return (e >> BigInt(t)) & oy;
        },
        bitSet: function (e, t, r) {
          return e | ((r ? oy : om) << BigInt(t));
        },
        bitMask: o$,
        createHmacDrbg: oW,
        validateObject: oH,
        notImplemented: () => {
          throw Error("not implemented");
        },
        memoized: oz,
      });
      let oK = BigInt(0),
        oG = BigInt(1),
        oY = BigInt(2),
        oZ = BigInt(3),
        oJ = BigInt(4),
        oX = BigInt(5),
        oQ = BigInt(8);
      function o0(e, t) {
        let r = e % t;
        return r >= oK ? r : t + r;
      }
      function o1(e, t, r) {
        if (t < oK) throw Error("invalid exponent, negatives unsupported");
        if (r <= oK) throw Error("invalid modulus");
        if (r === oG) return oK;
        let i = oG;
        for (; t > oK; )
          t & oG && (i = (i * e) % r), (e = (e * e) % r), (t >>= oG);
        return i;
      }
      function o2(e, t, r) {
        let i = e;
        for (; t-- > oK; ) (i *= i), (i %= r);
        return i;
      }
      function o3(e, t) {
        if (e === oK) throw Error("invert: expected non-zero number");
        if (t <= oK) throw Error("invert: expected positive modulus, got " + t);
        let r = o0(e, t),
          i = t,
          s = oK,
          n = oG;
        for (; r !== oK; ) {
          let e = i / r,
            t = i % r,
            a = s - n * e;
          (i = r), (r = t), (s = n), (n = a);
        }
        if (i !== oG) throw Error("invert: does not exist");
        return o0(s, t);
      }
      let o5 = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN",
      ];
      function o8(e, t) {
        let r = void 0 !== t ? t : e.toString(2).length,
          i = Math.ceil(r / 8);
        return { nBitLength: r, nByteLength: i };
      }
      function o6(e, t, r = !1, i = {}) {
        let s;
        if (e <= oK) throw Error("invalid field: expected ORDER > 0, got " + e);
        let { nBitLength: n, nByteLength: a } = o8(e, t);
        if (a > 2048)
          throw Error("invalid field: expected ORDER of <= 2048 bytes");
        let o = Object.freeze({
          ORDER: e,
          isLE: r,
          BITS: n,
          BYTES: a,
          MASK: o$(n),
          ZERO: oK,
          ONE: oG,
          create: (t) => o0(t, e),
          isValid: (t) => {
            if ("bigint" != typeof t)
              throw Error(
                "invalid field element: expected bigint, got " + typeof t
              );
            return oK <= t && t < e;
          },
          is0: (e) => e === oK,
          isOdd: (e) => (e & oG) === oG,
          neg: (t) => o0(-t, e),
          eql: (e, t) => e === t,
          sqr: (t) => o0(t * t, e),
          add: (t, r) => o0(t + r, e),
          sub: (t, r) => o0(t - r, e),
          mul: (t, r) => o0(t * r, e),
          pow: (e, t) =>
            (function (e, t, r) {
              if (r < oK)
                throw Error("invalid exponent, negatives unsupported");
              if (r === oK) return e.ONE;
              if (r === oG) return t;
              let i = e.ONE,
                s = t;
              for (; r > oK; )
                r & oG && (i = e.mul(i, s)), (s = e.sqr(s)), (r >>= oG);
              return i;
            })(o, e, t),
          div: (t, r) => o0(t * o3(r, e), e),
          sqrN: (e) => e * e,
          addN: (e, t) => e + t,
          subN: (e, t) => e - t,
          mulN: (e, t) => e * t,
          inv: (t) => o3(t, e),
          sqrt:
            i.sqrt ||
            ((t) => (
              s ||
                (s = (function (e) {
                  if (e % oJ === oZ) {
                    let t = (e + oG) / oJ;
                    return function (e, r) {
                      let i = e.pow(r, t);
                      if (!e.eql(e.sqr(i), r))
                        throw Error("Cannot find square root");
                      return i;
                    };
                  }
                  if (e % oQ === oX) {
                    let t = (e - oX) / oQ;
                    return function (e, r) {
                      let i = e.mul(r, oY),
                        s = e.pow(i, t),
                        n = e.mul(r, s),
                        a = e.mul(e.mul(n, oY), s),
                        o = e.mul(n, e.sub(a, e.ONE));
                      if (!e.eql(e.sqr(o), r))
                        throw Error("Cannot find square root");
                      return o;
                    };
                  }
                  return (function (e) {
                    let t,
                      r,
                      i,
                      s = (e - oG) / oY;
                    for (t = e - oG, r = 0; t % oY === oK; t /= oY, r++);
                    for (i = oY; i < e && o1(i, s, e) !== e - oG; i++)
                      if (i > 1e3)
                        throw Error(
                          "Cannot find square root: likely non-prime P"
                        );
                    if (1 === r) {
                      let t = (e + oG) / oJ;
                      return function (e, r) {
                        let i = e.pow(r, t);
                        if (!e.eql(e.sqr(i), r))
                          throw Error("Cannot find square root");
                        return i;
                      };
                    }
                    let n = (t + oG) / oY;
                    return function (e, a) {
                      if (e.pow(a, s) === e.neg(e.ONE))
                        throw Error("Cannot find square root");
                      let o = r,
                        c = e.pow(e.mul(e.ONE, i), t),
                        l = e.pow(a, n),
                        u = e.pow(a, t);
                      for (; !e.eql(u, e.ONE); ) {
                        if (e.eql(u, e.ZERO)) return e.ZERO;
                        let t = 1;
                        for (let r = e.sqr(u); t < o && !e.eql(r, e.ONE); t++)
                          r = e.sqr(r);
                        let r = e.pow(c, oG << BigInt(o - t - 1));
                        (c = e.sqr(r)),
                          (l = e.mul(l, r)),
                          (u = e.mul(u, c)),
                          (o = t);
                      }
                      return l;
                    };
                  })(e);
                })(e)),
              s(o, t)
            )),
          invertBatch: (e) =>
            (function (e, t) {
              let r = Array(t.length),
                i = t.reduce(
                  (t, i, s) => (e.is0(i) ? t : ((r[s] = t), e.mul(t, i))),
                  e.ONE
                ),
                s = e.inv(i);
              return (
                t.reduceRight(
                  (t, i, s) =>
                    e.is0(i) ? t : ((r[s] = e.mul(t, r[s])), e.mul(t, i)),
                  s
                ),
                r
              );
            })(o, e),
          cmov: (e, t, r) => (r ? t : e),
          toBytes: (e) => (r ? oR(e, a) : oP(e, a)),
          fromBytes: (e) => {
            if (e.length !== a)
              throw Error(
                "Field.fromBytes: expected " + a + " bytes, got " + e.length
              );
            return r ? ox(e) : oO(e);
          },
        });
        return Object.freeze(o);
      }
      function o4(e) {
        if ("bigint" != typeof e) throw Error("field order must be bigint");
        return Math.ceil(e.toString(2).length / 8);
      }
      function o9(e) {
        let t = o4(e);
        return t + Math.ceil(t / 2);
      }
      let o7 = BigInt(0),
        ce = BigInt(1);
      function ct(e, t) {
        let r = t.negate();
        return e ? r : t;
      }
      function cr(e, t) {
        if (!Number.isSafeInteger(e) || e <= 0 || e > t)
          throw Error(
            "invalid window size, expected [1.." + t + "], got W=" + e
          );
      }
      function ci(e, t) {
        return (
          cr(e, t), { windows: Math.ceil(t / e) + 1, windowSize: 2 ** (e - 1) }
        );
      }
      let cs = new WeakMap(),
        cn = new WeakMap();
      function ca(e) {
        return cn.get(e) || 1;
      }
      function co(e) {
        return (
          oH(
            e.Fp,
            o5.reduce((e, t) => ((e[t] = "function"), e), {
              ORDER: "bigint",
              MASK: "bigint",
              BYTES: "isSafeInteger",
              BITS: "isSafeInteger",
            })
          ),
          oH(
            e,
            { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
            { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
          ),
          Object.freeze({ ...o8(e.n, e.nBitLength), ...e, p: e.Fp.ORDER })
        );
      }
      BigInt(0), BigInt(1), BigInt(2), BigInt(8);
      let cc = BigInt(0),
        cl = BigInt(1),
        cu = BigInt(
          "57896044618658097711785492504343953926634992332820282019728792003956564819949"
        );
      BigInt(0);
      let cd = BigInt(1),
        ch = BigInt(2),
        cp = BigInt(3),
        cf = BigInt(5);
      BigInt(8);
      let cg = (function (e) {
        let t =
            (oH(
              e,
              { a: "bigint" },
              {
                montgomeryBits: "isSafeInteger",
                nByteLength: "isSafeInteger",
                adjustScalarBytes: "function",
                domain: "function",
                powPminus2: "function",
                Gu: "bigint",
              }
            ),
            Object.freeze({ ...e })),
          { P: r } = t,
          i = (e) => o0(e, r),
          s = t.montgomeryBits,
          n = Math.ceil(s / 8),
          a = t.nByteLength,
          o = t.adjustScalarBytes || ((e) => e),
          c = t.powPminus2 || ((e) => o1(e, r - BigInt(2), r));
        function l(e, t, r) {
          let s = i(e * (t - r));
          return [(t = i(t - s)), (r = i(r + s))];
        }
        let u = (t.a - BigInt(2)) / BigInt(4);
        function d(e, t) {
          let d = (function (e, t) {
            oM("u", e, cc, r), oM("scalar", t, cc, r);
            let n = cl,
              a = cc,
              o = e,
              d = cl,
              h = cc,
              p;
            for (let r = BigInt(s - 1); r >= cc; r--) {
              let s = (t >> r) & cl;
              (h ^= s),
                (n = (p = l(h, n, o))[0]),
                (o = p[1]),
                (a = (p = l(h, a, d))[0]),
                (d = p[1]),
                (h = s);
              let c = n + a,
                f = i(c * c),
                g = n - a,
                m = i(g * g),
                y = f - m,
                b = o + d,
                w = i((o - d) * c),
                v = i(b * g),
                E = w + v,
                _ = w - v;
              (o = i(E * E)),
                (d = i(e * i(_ * _))),
                (n = i(f * m)),
                (a = i(y * (f + i(u * y))));
            }
            return (
              (n = (p = l(h, n, o))[0]),
              (o = p[1]),
              (a = (p = l(h, a, d))[0]),
              (d = p[1]),
              i(n * c(a))
            );
          })(
            (function (e) {
              let t = ok("u coordinate", e, n);
              return 32 === a && (t[31] &= 127), ox(t);
            })(t),
            (function (e) {
              let t = ok("scalar", e),
                r = t.length;
              if (r !== n && r !== a)
                throw Error(
                  "invalid scalar, expected " +
                    ("" + n + " or ") +
                    a +
                    " bytes, got " +
                    r
                );
              return ox(o(t));
            })(e)
          );
          if (d === cc) throw Error("invalid private or public key received");
          return oR(i(d), n);
        }
        let h = oR(i(t.Gu), n);
        function p(e) {
          return d(e, h);
        }
        return {
          scalarMult: d,
          scalarMultBase: p,
          getSharedSecret: (e, t) => d(e, t),
          getPublicKey: (e) => p(e),
          utils: { randomPrivateKey: () => t.randomBytes(t.nByteLength) },
          GuBytes: h,
        };
      })({
        P: cu,
        a: BigInt(486662),
        montgomeryBits: 255,
        nByteLength: 32,
        Gu: BigInt(9),
        powPminus2: (e) => {
          let { pow_p_5_8: t, b2: r } = (function (e) {
            let t = BigInt(10),
              r = BigInt(20),
              i = BigInt(40),
              s = BigInt(80),
              n = (((e * e) % cu) * e) % cu,
              a = (o2(n, ch, cu) * n) % cu,
              o = (o2(a, cd, cu) * e) % cu,
              c = (o2(o, cf, cu) * o) % cu,
              l = (o2(c, t, cu) * c) % cu,
              u = (o2(l, r, cu) * l) % cu,
              d = (o2(u, i, cu) * u) % cu,
              h = (o2(d, s, cu) * d) % cu,
              p = (o2(h, s, cu) * d) % cu,
              f = (o2(p, t, cu) * c) % cu;
            return { pow_p_5_8: (o2(f, ch, cu) * e) % cu, b2: n };
          })(e);
          return o0(o2(t, cp, cu) * r, cu);
        },
        adjustScalarBytes: function (e) {
          return (e[0] &= 248), (e[31] &= 127), (e[31] |= 64), e;
        },
        randomBytes: n9,
      });
      function cm(e) {
        void 0 !== e.lowS && oE("lowS", e.lowS),
          void 0 !== e.prehash && oE("prehash", e.prehash);
      }
      let { bytesToNumberBE: cy, hexToBytes: cb } = oV;
      class cw extends Error {
        constructor(e = "") {
          super(e);
        }
      }
      let cv = {
          Err: cw,
          _tlv: {
            encode: (e, t) => {
              let { Err: r } = cv;
              if (e < 0 || e > 256) throw new r("tlv.encode: wrong tag");
              if (1 & t.length) throw new r("tlv.encode: unpadded data");
              let i = t.length / 2,
                s = oA(i);
              if ((s.length / 2) & 128)
                throw new r("tlv.encode: long form length too big");
              let n = i > 127 ? oA((s.length / 2) | 128) : "";
              return oA(e) + n + s + t;
            },
            decode(e, t) {
              let { Err: r } = cv,
                i = 0;
              if (e < 0 || e > 256) throw new r("tlv.encode: wrong tag");
              if (t.length < 2 || t[i++] !== e)
                throw new r("tlv.decode: wrong tlv");
              let s = t[i++],
                n = 0;
              if (128 & s) {
                let e = 127 & s;
                if (!e)
                  throw new r(
                    "tlv.decode(long): indefinite length not supported"
                  );
                if (e > 4)
                  throw new r("tlv.decode(long): byte length is too big");
                let a = t.subarray(i, i + e);
                if (a.length !== e)
                  throw new r("tlv.decode: length bytes not complete");
                if (0 === a[0])
                  throw new r("tlv.decode(long): zero leftmost byte");
                for (let e of a) n = (n << 8) | e;
                if (((i += e), n < 128))
                  throw new r("tlv.decode(long): not minimal encoding");
              } else n = s;
              let a = t.subarray(i, i + n);
              if (a.length !== n) throw new r("tlv.decode: wrong value length");
              return { v: a, l: t.subarray(i + n) };
            },
          },
          _int: {
            encode(e) {
              let { Err: t } = cv;
              if (e < cE)
                throw new t("integer: negative integers are not allowed");
              let r = oA(e);
              if (
                (8 & Number.parseInt(r[0], 16) && (r = "00" + r), 1 & r.length)
              )
                throw new t("unexpected DER parsing assertion: unpadded hex");
              return r;
            },
            decode(e) {
              let { Err: t } = cv;
              if (128 & e[0])
                throw new t("invalid signature integer: negative");
              if (0 === e[0] && !(128 & e[1]))
                throw new t(
                  "invalid signature integer: unnecessary leading zero"
                );
              return cy(e);
            },
          },
          toSig(e) {
            let { Err: t, _int: r, _tlv: i } = cv,
              s = "string" == typeof e ? cb(e) : e;
            ov(s);
            let { v: n, l: a } = i.decode(48, s);
            if (a.length)
              throw new t("invalid signature: left bytes after parsing");
            let { v: o, l: c } = i.decode(2, n),
              { v: l, l: u } = i.decode(2, c);
            if (u.length)
              throw new t("invalid signature: left bytes after parsing");
            return { r: r.decode(o), s: r.decode(l) };
          },
          hexFromSig(e) {
            let { _tlv: t, _int: r } = cv,
              i = t.encode(2, r.encode(e.r)),
              s = t.encode(2, r.encode(e.s));
            return t.encode(48, i + s);
          },
        },
        cE = BigInt(0),
        c_ = BigInt(1);
      BigInt(2);
      let cC = BigInt(3);
      BigInt(4);
      let cA = o6(
          BigInt(
            "0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"
          )
        ),
        cI = (function (e, t) {
          let r = (t) =>
            (function (e) {
              let t = (function (e) {
                  let t = co(e);
                  return (
                    oH(
                      t,
                      {
                        hash: "hash",
                        hmac: "function",
                        randomBytes: "function",
                      },
                      {
                        bits2int: "function",
                        bits2int_modN: "function",
                        lowS: "boolean",
                      }
                    ),
                    Object.freeze({ lowS: !0, ...t })
                  );
                })(e),
                { Fp: r, n: i } = t,
                s = r.BYTES + 1,
                n = 2 * r.BYTES + 1;
              function a(e) {
                return o0(e, i);
              }
              let {
                  ProjectivePoint: o,
                  normPrivateKeyToScalar: c,
                  weierstrassEquation: l,
                  isWithinCurveOrder: u,
                } = (function (e) {
                  var t;
                  let r = (function (e) {
                      let t = co(e);
                      oH(
                        t,
                        { a: "field", b: "field" },
                        {
                          allowedPrivateKeyLengths: "array",
                          wrapPrivateKey: "boolean",
                          isTorsionFree: "function",
                          clearCofactor: "function",
                          allowInfinityPoint: "boolean",
                          fromBytes: "function",
                          toBytes: "function",
                        }
                      );
                      let { endo: r, Fp: i, a: s } = t;
                      if (r) {
                        if (!i.eql(s, i.ZERO))
                          throw Error(
                            "invalid endomorphism, can only be defined for Koblitz curves that have a=0"
                          );
                        if (
                          "object" != typeof r ||
                          "bigint" != typeof r.beta ||
                          "function" != typeof r.splitScalar
                        )
                          throw Error(
                            "invalid endomorphism, expected beta: bigint and splitScalar: function"
                          );
                      }
                      return Object.freeze({ ...t });
                    })(e),
                    { Fp: i } = r,
                    s = o6(r.n, r.nBitLength),
                    n =
                      r.toBytes ||
                      ((e, t, r) => {
                        let s = t.toAffine();
                        return oD(
                          Uint8Array.from([4]),
                          i.toBytes(s.x),
                          i.toBytes(s.y)
                        );
                      }),
                    a =
                      r.fromBytes ||
                      ((e) => {
                        let t = e.subarray(1);
                        return {
                          x: i.fromBytes(t.subarray(0, i.BYTES)),
                          y: i.fromBytes(t.subarray(i.BYTES, 2 * i.BYTES)),
                        };
                      });
                  function o(e) {
                    let { a: t, b: s } = r,
                      n = i.sqr(e),
                      a = i.mul(n, e);
                    return i.add(i.add(a, i.mul(e, t)), s);
                  }
                  if (!i.eql(i.sqr(r.Gy), o(r.Gx)))
                    throw Error("bad generator point: equation left != right");
                  function c(e) {
                    let t,
                      {
                        allowedPrivateKeyLengths: i,
                        nByteLength: s,
                        wrapPrivateKey: n,
                        n: a,
                      } = r;
                    if (i && "bigint" != typeof e) {
                      if (
                        (ow(e) && (e = oC(e)),
                        "string" != typeof e || !i.includes(e.length))
                      )
                        throw Error("invalid private key");
                      e = e.padStart(2 * s, "0");
                    }
                    try {
                      t =
                        "bigint" == typeof e ? e : oO(ok("private key", e, s));
                    } catch {
                      throw Error(
                        "invalid private key, expected hex or " +
                          s +
                          " bytes, got " +
                          typeof e
                      );
                    }
                    return n && (t = o0(t, a)), oM("private key", t, c_, a), t;
                  }
                  function l(e) {
                    if (!(e instanceof h))
                      throw Error("ProjectivePoint expected");
                  }
                  let u = oz((e, t) => {
                      let { px: r, py: s, pz: n } = e;
                      if (i.eql(n, i.ONE)) return { x: r, y: s };
                      let a = e.is0();
                      null == t && (t = a ? i.ONE : i.inv(n));
                      let o = i.mul(r, t),
                        c = i.mul(s, t),
                        l = i.mul(n, t);
                      if (a) return { x: i.ZERO, y: i.ZERO };
                      if (!i.eql(l, i.ONE)) throw Error("invZ was invalid");
                      return { x: o, y: c };
                    }),
                    d = oz((e) => {
                      if (e.is0()) {
                        if (r.allowInfinityPoint && !i.is0(e.py)) return;
                        throw Error("bad point: ZERO");
                      }
                      let { x: t, y: s } = e.toAffine();
                      if (!i.isValid(t) || !i.isValid(s))
                        throw Error("bad point: x or y not FE");
                      let n = i.sqr(s),
                        a = o(t);
                      if (!i.eql(n, a))
                        throw Error("bad point: equation left != right");
                      if (!e.isTorsionFree())
                        throw Error("bad point: not in prime-order subgroup");
                      return !0;
                    });
                  class h {
                    constructor(e, t, r) {
                      if (
                        ((this.px = e),
                        (this.py = t),
                        (this.pz = r),
                        null == e || !i.isValid(e))
                      )
                        throw Error("x required");
                      if (null == t || !i.isValid(t)) throw Error("y required");
                      if (null == r || !i.isValid(r)) throw Error("z required");
                      Object.freeze(this);
                    }
                    static fromAffine(e) {
                      let { x: t, y: r } = e || {};
                      if (!e || !i.isValid(t) || !i.isValid(r))
                        throw Error("invalid affine point");
                      if (e instanceof h)
                        throw Error("projective point not allowed");
                      let s = (e) => i.eql(e, i.ZERO);
                      return s(t) && s(r) ? h.ZERO : new h(t, r, i.ONE);
                    }
                    get x() {
                      return this.toAffine().x;
                    }
                    get y() {
                      return this.toAffine().y;
                    }
                    static normalizeZ(e) {
                      let t = i.invertBatch(e.map((e) => e.pz));
                      return e
                        .map((e, r) => e.toAffine(t[r]))
                        .map(h.fromAffine);
                    }
                    static fromHex(e) {
                      let t = h.fromAffine(a(ok("pointHex", e)));
                      return t.assertValidity(), t;
                    }
                    static fromPrivateKey(e) {
                      return h.BASE.multiply(c(e));
                    }
                    static msm(e, t) {
                      return (function (e, t, r, i) {
                        if (
                          ((function (e, t) {
                            if (!Array.isArray(e))
                              throw Error("array expected");
                            e.forEach((e, r) => {
                              if (!(e instanceof t))
                                throw Error("invalid point at index " + r);
                            });
                          })(r, e),
                          (function (e, t) {
                            if (!Array.isArray(e))
                              throw Error("array of scalars expected");
                            e.forEach((e, r) => {
                              if (!t.isValid(e))
                                throw Error("invalid scalar at index " + r);
                            });
                          })(i, t),
                          r.length !== i.length)
                        )
                          throw Error(
                            "arrays of points and scalars must have equal length"
                          );
                        let s = e.ZERO,
                          n = oj(BigInt(r.length)),
                          a = n > 12 ? n - 3 : n > 4 ? n - 2 : n ? 2 : 1,
                          o = (1 << a) - 1,
                          c = Array(o + 1).fill(s),
                          l = Math.floor((t.BITS - 1) / a) * a,
                          u = s;
                        for (let e = l; e >= 0; e -= a) {
                          c.fill(s);
                          for (let t = 0; t < i.length; t++) {
                            let s = Number((i[t] >> BigInt(e)) & BigInt(o));
                            c[s] = c[s].add(r[t]);
                          }
                          let t = s;
                          for (let e = c.length - 1, r = s; e > 0; e--)
                            (r = r.add(c[e])), (t = t.add(r));
                          if (((u = u.add(t)), 0 !== e))
                            for (let e = 0; e < a; e++) u = u.double();
                        }
                        return u;
                      })(h, s, e, t);
                    }
                    _setWindowSize(e) {
                      f.setWindowSize(this, e);
                    }
                    assertValidity() {
                      d(this);
                    }
                    hasEvenY() {
                      let { y: e } = this.toAffine();
                      if (i.isOdd) return !i.isOdd(e);
                      throw Error("Field doesn't support isOdd");
                    }
                    equals(e) {
                      l(e);
                      let { px: t, py: r, pz: s } = this,
                        { px: n, py: a, pz: o } = e,
                        c = i.eql(i.mul(t, o), i.mul(n, s)),
                        u = i.eql(i.mul(r, o), i.mul(a, s));
                      return c && u;
                    }
                    negate() {
                      return new h(this.px, i.neg(this.py), this.pz);
                    }
                    double() {
                      let { a: e, b: t } = r,
                        s = i.mul(t, cC),
                        { px: n, py: a, pz: o } = this,
                        c = i.ZERO,
                        l = i.ZERO,
                        u = i.ZERO,
                        d = i.mul(n, n),
                        p = i.mul(a, a),
                        f = i.mul(o, o),
                        g = i.mul(n, a);
                      return (
                        (g = i.add(g, g)),
                        (u = i.mul(n, o)),
                        (u = i.add(u, u)),
                        (c = i.mul(e, u)),
                        (l = i.mul(s, f)),
                        (l = i.add(c, l)),
                        (c = i.sub(p, l)),
                        (l = i.add(p, l)),
                        (l = i.mul(c, l)),
                        (c = i.mul(g, c)),
                        (u = i.mul(s, u)),
                        (f = i.mul(e, f)),
                        (g = i.sub(d, f)),
                        (g = i.mul(e, g)),
                        (g = i.add(g, u)),
                        (u = i.add(d, d)),
                        (d = i.add(u, d)),
                        (d = i.add(d, f)),
                        (d = i.mul(d, g)),
                        (l = i.add(l, d)),
                        (f = i.mul(a, o)),
                        (f = i.add(f, f)),
                        (d = i.mul(f, g)),
                        (c = i.sub(c, d)),
                        (u = i.mul(f, p)),
                        (u = i.add(u, u)),
                        new h(c, l, (u = i.add(u, u)))
                      );
                    }
                    add(e) {
                      l(e);
                      let { px: t, py: s, pz: n } = this,
                        { px: a, py: o, pz: c } = e,
                        u = i.ZERO,
                        d = i.ZERO,
                        p = i.ZERO,
                        f = r.a,
                        g = i.mul(r.b, cC),
                        m = i.mul(t, a),
                        y = i.mul(s, o),
                        b = i.mul(n, c),
                        w = i.add(t, s),
                        v = i.add(a, o);
                      (w = i.mul(w, v)),
                        (v = i.add(m, y)),
                        (w = i.sub(w, v)),
                        (v = i.add(t, n));
                      let E = i.add(a, c);
                      return (
                        (v = i.mul(v, E)),
                        (E = i.add(m, b)),
                        (v = i.sub(v, E)),
                        (E = i.add(s, n)),
                        (u = i.add(o, c)),
                        (E = i.mul(E, u)),
                        (u = i.add(y, b)),
                        (E = i.sub(E, u)),
                        (p = i.mul(f, v)),
                        (u = i.mul(g, b)),
                        (p = i.add(u, p)),
                        (u = i.sub(y, p)),
                        (p = i.add(y, p)),
                        (d = i.mul(u, p)),
                        (y = i.add(m, m)),
                        (y = i.add(y, m)),
                        (b = i.mul(f, b)),
                        (v = i.mul(g, v)),
                        (y = i.add(y, b)),
                        (b = i.sub(m, b)),
                        (b = i.mul(f, b)),
                        (v = i.add(v, b)),
                        (m = i.mul(y, v)),
                        (d = i.add(d, m)),
                        (m = i.mul(E, v)),
                        (u = i.mul(w, u)),
                        (u = i.sub(u, m)),
                        (m = i.mul(w, y)),
                        (p = i.mul(E, p)),
                        new h(u, d, (p = i.add(p, m)))
                      );
                    }
                    subtract(e) {
                      return this.add(e.negate());
                    }
                    is0() {
                      return this.equals(h.ZERO);
                    }
                    wNAF(e) {
                      return f.wNAFCached(this, e, h.normalizeZ);
                    }
                    multiplyUnsafe(e) {
                      let { endo: t, n: s } = r;
                      oM("scalar", e, cE, s);
                      let n = h.ZERO;
                      if (e === cE) return n;
                      if (this.is0() || e === c_) return this;
                      if (!t || f.hasPrecomputes(this))
                        return f.wNAFCachedUnsafe(this, e, h.normalizeZ);
                      let {
                          k1neg: a,
                          k1: o,
                          k2neg: c,
                          k2: l,
                        } = t.splitScalar(e),
                        u = n,
                        d = n,
                        p = this;
                      for (; o > cE || l > cE; )
                        o & c_ && (u = u.add(p)),
                          l & c_ && (d = d.add(p)),
                          (p = p.double()),
                          (o >>= c_),
                          (l >>= c_);
                      return (
                        a && (u = u.negate()),
                        c && (d = d.negate()),
                        (d = new h(i.mul(d.px, t.beta), d.py, d.pz)),
                        u.add(d)
                      );
                    }
                    multiply(e) {
                      let t,
                        s,
                        { endo: n, n: a } = r;
                      if ((oM("scalar", e, c_, a), n)) {
                        let {
                            k1neg: r,
                            k1: a,
                            k2neg: o,
                            k2: c,
                          } = n.splitScalar(e),
                          { p: l, f: u } = this.wNAF(a),
                          { p: d, f: p } = this.wNAF(c);
                        (l = f.constTimeNegate(r, l)),
                          (d = f.constTimeNegate(o, d)),
                          (d = new h(i.mul(d.px, n.beta), d.py, d.pz)),
                          (t = l.add(d)),
                          (s = u.add(p));
                      } else {
                        let { p: r, f: i } = this.wNAF(e);
                        (t = r), (s = i);
                      }
                      return h.normalizeZ([t, s])[0];
                    }
                    multiplyAndAddUnsafe(e, t, r) {
                      let i = h.BASE,
                        s = (e, t) =>
                          t !== cE && t !== c_ && e.equals(i)
                            ? e.multiply(t)
                            : e.multiplyUnsafe(t),
                        n = s(this, t).add(s(e, r));
                      return n.is0() ? void 0 : n;
                    }
                    toAffine(e) {
                      return u(this, e);
                    }
                    isTorsionFree() {
                      let { h: e, isTorsionFree: t } = r;
                      if (e === c_) return !0;
                      if (t) return t(h, this);
                      throw Error(
                        "isTorsionFree() has not been declared for the elliptic curve"
                      );
                    }
                    clearCofactor() {
                      let { h: e, clearCofactor: t } = r;
                      return e === c_
                        ? this
                        : t
                        ? t(h, this)
                        : this.multiplyUnsafe(r.h);
                    }
                    toRawBytes(e = !0) {
                      return (
                        oE("isCompressed", e),
                        this.assertValidity(),
                        n(h, this, e)
                      );
                    }
                    toHex(e = !0) {
                      return oE("isCompressed", e), oC(this.toRawBytes(e));
                    }
                  }
                  (h.BASE = new h(r.Gx, r.Gy, i.ONE)),
                    (h.ZERO = new h(i.ZERO, i.ONE, i.ZERO));
                  let p = r.nBitLength,
                    f =
                      ((t = r.endo ? Math.ceil(p / 2) : p),
                      {
                        constTimeNegate: ct,
                        hasPrecomputes: (e) => 1 !== ca(e),
                        unsafeLadder(e, t, r = h.ZERO) {
                          let i = e;
                          for (; t > o7; )
                            t & ce && (r = r.add(i)),
                              (i = i.double()),
                              (t >>= ce);
                          return r;
                        },
                        precomputeWindow(e, r) {
                          let { windows: i, windowSize: s } = ci(r, t),
                            n = [],
                            a = e,
                            o = a;
                          for (let e = 0; e < i; e++) {
                            (o = a), n.push(o);
                            for (let e = 1; e < s; e++)
                              (o = o.add(a)), n.push(o);
                            a = o.double();
                          }
                          return n;
                        },
                        wNAF(e, r, i) {
                          let { windows: s, windowSize: n } = ci(e, t),
                            a = h.ZERO,
                            o = h.BASE,
                            c = BigInt(2 ** e - 1),
                            l = 2 ** e,
                            u = BigInt(e);
                          for (let e = 0; e < s; e++) {
                            let t = e * n,
                              s = Number(i & c);
                            (i >>= u), s > n && ((s -= l), (i += ce));
                            let d = t + Math.abs(s) - 1,
                              h = e % 2 != 0,
                              p = s < 0;
                            0 === s
                              ? (o = o.add(ct(h, r[t])))
                              : (a = a.add(ct(p, r[d])));
                          }
                          return { p: a, f: o };
                        },
                        wNAFUnsafe(e, r, i, s = h.ZERO) {
                          let { windows: n, windowSize: a } = ci(e, t),
                            o = BigInt(2 ** e - 1),
                            c = 2 ** e,
                            l = BigInt(e);
                          for (let e = 0; e < n; e++) {
                            let t = e * a;
                            if (i === o7) break;
                            let n = Number(i & o);
                            if (
                              ((i >>= l),
                              n > a && ((n -= c), (i += ce)),
                              0 === n)
                            )
                              continue;
                            let u = r[t + Math.abs(n) - 1];
                            n < 0 && (u = u.negate()), (s = s.add(u));
                          }
                          return s;
                        },
                        getPrecomputes(e, t, r) {
                          let i = cs.get(t);
                          return (
                            i ||
                              ((i = this.precomputeWindow(t, e)),
                              1 !== e && cs.set(t, r(i))),
                            i
                          );
                        },
                        wNAFCached(e, t, r) {
                          let i = ca(e);
                          return this.wNAF(i, this.getPrecomputes(i, e, r), t);
                        },
                        wNAFCachedUnsafe(e, t, r, i) {
                          let s = ca(e);
                          return 1 === s
                            ? this.unsafeLadder(e, t, i)
                            : this.wNAFUnsafe(
                                s,
                                this.getPrecomputes(s, e, r),
                                t,
                                i
                              );
                        },
                        setWindowSize(e, r) {
                          cr(r, t), cn.set(e, r), cs.delete(e);
                        },
                      });
                  return {
                    CURVE: r,
                    ProjectivePoint: h,
                    normPrivateKeyToScalar: c,
                    weierstrassEquation: o,
                    isWithinCurveOrder: function (e) {
                      return oL(e, c_, r.n);
                    },
                  };
                })({
                  ...t,
                  toBytes(e, t, i) {
                    let s = t.toAffine(),
                      n = r.toBytes(s.x);
                    return (
                      oE("isCompressed", i),
                      i
                        ? oD(Uint8Array.from([t.hasEvenY() ? 2 : 3]), n)
                        : oD(Uint8Array.from([4]), n, r.toBytes(s.y))
                    );
                  },
                  fromBytes(e) {
                    let t = e.length,
                      i = e[0],
                      a = e.subarray(1);
                    if (t === s && (2 === i || 3 === i)) {
                      let e,
                        t = oO(a);
                      if (!oL(t, c_, r.ORDER))
                        throw Error("Point is not on curve");
                      let s = l(t);
                      try {
                        e = r.sqrt(s);
                      } catch (e) {
                        throw Error(
                          "Point is not on curve" +
                            (e instanceof Error ? ": " + e.message : "")
                        );
                      }
                      return (
                        ((1 & i) == 1) != ((e & c_) === c_) && (e = r.neg(e)),
                        { x: t, y: e }
                      );
                    }
                    if (t === n && 4 === i)
                      return {
                        x: r.fromBytes(a.subarray(0, r.BYTES)),
                        y: r.fromBytes(a.subarray(r.BYTES, 2 * r.BYTES)),
                      };
                    throw Error(
                      "invalid Point, expected length of " +
                        s +
                        ", or uncompressed " +
                        n +
                        ", got " +
                        t
                    );
                  },
                }),
                d = (e) => oC(oP(e, t.nByteLength)),
                h = (e, t, r) => oO(e.slice(t, r));
              class p {
                constructor(e, t, r) {
                  (this.r = e),
                    (this.s = t),
                    (this.recovery = r),
                    this.assertValidity();
                }
                static fromCompact(e) {
                  let r = t.nByteLength;
                  return new p(
                    h((e = ok("compactSignature", e, 2 * r)), 0, r),
                    h(e, r, 2 * r)
                  );
                }
                static fromDER(e) {
                  let { r: t, s: r } = cv.toSig(ok("DER", e));
                  return new p(t, r);
                }
                assertValidity() {
                  oM("r", this.r, c_, i), oM("s", this.s, c_, i);
                }
                addRecoveryBit(e) {
                  return new p(this.r, this.s, e);
                }
                recoverPublicKey(e) {
                  let { r: s, s: n, recovery: c } = this,
                    l = m(ok("msgHash", e));
                  if (null == c || ![0, 1, 2, 3].includes(c))
                    throw Error("recovery id invalid");
                  let u = 2 === c || 3 === c ? s + t.n : s;
                  if (u >= r.ORDER) throw Error("recovery id 2 or 3 invalid");
                  let h = (1 & c) == 0 ? "02" : "03",
                    p = o.fromHex(h + d(u)),
                    f = o3(u, i),
                    g = a(-l * f),
                    y = a(n * f),
                    b = o.BASE.multiplyAndAddUnsafe(p, g, y);
                  if (!b) throw Error("point at infinify");
                  return b.assertValidity(), b;
                }
                hasHighS() {
                  return this.s > i >> c_;
                }
                normalizeS() {
                  return this.hasHighS()
                    ? new p(this.r, a(-this.s), this.recovery)
                    : this;
                }
                toDERRawBytes() {
                  return oT(this.toDERHex());
                }
                toDERHex() {
                  return cv.hexFromSig({ r: this.r, s: this.s });
                }
                toCompactRawBytes() {
                  return oT(this.toCompactHex());
                }
                toCompactHex() {
                  return d(this.r) + d(this.s);
                }
              }
              function f(e) {
                let t = ow(e),
                  r = "string" == typeof e,
                  i = (t || r) && e.length;
                return t
                  ? i === s || i === n
                  : r
                  ? i === 2 * s || i === 2 * n
                  : e instanceof o;
              }
              let g =
                  t.bits2int ||
                  function (e) {
                    if (e.length > 8192) throw Error("input is too large");
                    let r = oO(e),
                      i = 8 * e.length - t.nBitLength;
                    return i > 0 ? r >> BigInt(i) : r;
                  },
                m =
                  t.bits2int_modN ||
                  function (e) {
                    return a(g(e));
                  },
                y = o$(t.nBitLength);
              function b(e) {
                return (
                  oM("num < 2^" + t.nBitLength, e, cE, y), oP(e, t.nByteLength)
                );
              }
              let w = { lowS: t.lowS, prehash: !1 },
                v = { lowS: t.lowS, prehash: !1 };
              return (
                o.BASE._setWindowSize(8),
                {
                  CURVE: t,
                  getPublicKey: function (e, t = !0) {
                    return o.fromPrivateKey(e).toRawBytes(t);
                  },
                  getSharedSecret: function (e, t, r = !0) {
                    if (f(e)) throw Error("first arg must be private key");
                    if (!f(t)) throw Error("second arg must be public key");
                    return o.fromHex(t).multiply(c(e)).toRawBytes(r);
                  },
                  sign: function (e, s, n = w) {
                    let { seed: l, k2sig: d } = (function (e, s, n = w) {
                      if (["recovered", "canonical"].some((e) => e in n))
                        throw Error("sign() legacy options not supported");
                      let { hash: l, randomBytes: d } = t,
                        { lowS: h, prehash: f, extraEntropy: y } = n;
                      null == h && (h = !0),
                        (e = ok("msgHash", e)),
                        cm(n),
                        f && (e = ok("prehashed msgHash", l(e)));
                      let v = m(e),
                        E = c(s),
                        _ = [b(E), b(v)];
                      if (null != y && !1 !== y) {
                        let e = !0 === y ? d(r.BYTES) : y;
                        _.push(ok("extraEntropy", e));
                      }
                      return {
                        seed: oD(..._),
                        k2sig: function (e) {
                          var t;
                          let r = g(e);
                          if (!u(r)) return;
                          let s = o3(r, i),
                            n = o.BASE.multiply(r).toAffine(),
                            c = a(n.x);
                          if (c === cE) return;
                          let l = a(s * a(v + c * E));
                          if (l === cE) return;
                          let d = (2 * (n.x !== c)) | Number(n.y & c_),
                            f = l;
                          return (
                            h &&
                              l > i >> c_ &&
                              ((f = (t = l) > i >> c_ ? a(-t) : t), (d ^= 1)),
                            new p(c, f, d)
                          );
                        },
                      };
                    })(e, s, n);
                    return oW(t.hash.outputLen, t.nByteLength, t.hmac)(l, d);
                  },
                  verify: function (e, r, s, n = v) {
                    let c, l;
                    (r = ok("msgHash", r)), (s = ok("publicKey", s));
                    let { lowS: u, prehash: d, format: h } = n;
                    if ((cm(n), "strict" in n))
                      throw Error("options.strict was renamed to lowS");
                    if (void 0 !== h && "compact" !== h && "der" !== h)
                      throw Error("format must be compact or der");
                    let f = "string" == typeof e || ow(e),
                      g =
                        !f &&
                        !h &&
                        "object" == typeof e &&
                        null !== e &&
                        "bigint" == typeof e.r &&
                        "bigint" == typeof e.s;
                    if (!f && !g)
                      throw Error(
                        "invalid signature, expected Uint8Array, hex string or Signature instance"
                      );
                    try {
                      if ((g && (c = new p(e.r, e.s)), f)) {
                        try {
                          "compact" !== h && (c = p.fromDER(e));
                        } catch (e) {
                          if (!(e instanceof cv.Err)) throw e;
                        }
                        c || "der" === h || (c = p.fromCompact(e));
                      }
                      l = o.fromHex(s);
                    } catch {
                      return !1;
                    }
                    if (!c || (u && c.hasHighS())) return !1;
                    d && (r = t.hash(r));
                    let { r: y, s: b } = c,
                      w = m(r),
                      E = o3(b, i),
                      _ = a(w * E),
                      C = a(y * E),
                      A = o.BASE.multiplyAndAddUnsafe(l, _, C)?.toAffine();
                    return !!A && a(A.x) === y;
                  },
                  ProjectivePoint: o,
                  Signature: p,
                  utils: {
                    isValidPrivateKey(e) {
                      try {
                        return c(e), !0;
                      } catch {
                        return !1;
                      }
                    },
                    normPrivateKeyToScalar: c,
                    randomPrivateKey: () => {
                      let e = o9(t.n);
                      return (function (e, t, r = !1) {
                        let i = e.length,
                          s = o4(t),
                          n = o9(t);
                        if (i < 16 || i < n || i > 1024)
                          throw Error(
                            "expected " + n + "-1024 bytes of input, got " + i
                          );
                        let a = o0(r ? ox(e) : oO(e), t - oG) + oG;
                        return r ? oR(a, s) : oP(a, s);
                      })(t.randomBytes(e), t.n);
                    },
                    precompute: (e = 8, t = o.BASE) => (
                      t._setWindowSize(e), t.multiply(BigInt(3)), t
                    ),
                  },
                }
              );
            })({
              ...e,
              hash: t,
              hmac: (e, ...r) =>
                oa(
                  t,
                  e,
                  (function (...e) {
                    let t = 0;
                    for (let r = 0; r < e.length; r++) {
                      let i = e[r];
                      nH(i), (t += i.length);
                    }
                    let r = new Uint8Array(t);
                    for (let t = 0, i = 0; t < e.length; t++) {
                      let s = e[t];
                      r.set(s, i), (i += s.length);
                    }
                    return r;
                  })(...r)
                ),
              randomBytes: n9,
            });
          return { ...r(t), create: r };
        })(
          {
            a: cA.create(BigInt("-3")),
            b: BigInt(
              "0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"
            ),
            Fp: cA,
            n: BigInt(
              "0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"
            ),
            Gx: BigInt(
              "0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"
            ),
            Gy: BigInt(
              "0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"
            ),
            h: BigInt(1),
            lowS: !1,
          },
          og
        ),
        cS = "base10",
        cN = "base16",
        cT = "base64pad",
        cO = "base64url",
        cx = "utf8";
      function cP() {
        return ne(n9(32), cN);
      }
      function cR(e) {
        return ne(og(s7(e, cN)), cN);
      }
      function ck(e) {
        return ne(og(s7(e, cx)), cN);
      }
      function cD(e) {
        return Number(ne(e, cS));
      }
      function cU(e) {
        return e.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
      }
      function cL(e) {
        let t = e.replace(/-/g, "+").replace(/_/g, "/"),
          r = (4 - (t.length % 4)) % 4;
        return t + "=".repeat(r);
      }
      function cM(e) {
        if (2 === cD(e.type)) return ne(iF([e.type, e.sealed]), cT);
        if (1 === cD(e.type)) {
          if (typeof e.senderPublicKey > "u")
            throw Error("Missing sender public key for type 1 envelope");
          return ne(iF([e.type, e.senderPublicKey, e.iv, e.sealed]), cT);
        }
        return ne(iF([e.type, e.iv, e.sealed]), cT);
      }
      function cj(e) {
        let t = s7((e.encoding || cT) === cO ? cL(e.encoded) : e.encoded, cT),
          r = t.slice(0, 1);
        if (1 === cD(r)) {
          let e = t.slice(1, 33),
            i = t.slice(33, 45);
          return { type: r, sealed: t.slice(45), iv: i, senderPublicKey: e };
        }
        if (2 === cD(r)) return { type: r, sealed: t.slice(1), iv: n9(12) };
        let i = t.slice(1, 13);
        return { type: r, sealed: t.slice(13), iv: i };
      }
      function c$(e) {
        let t = e?.type || 0;
        if (1 === t) {
          if (typeof e?.senderPublicKey > "u")
            throw Error("missing sender public key");
          if (typeof e?.receiverPublicKey > "u")
            throw Error("missing receiver public key");
        }
        return {
          type: t,
          senderPublicKey: e?.senderPublicKey,
          receiverPublicKey: e?.receiverPublicKey,
        };
      }
      function cB(e) {
        return (
          1 === e.type &&
          "string" == typeof e.senderPublicKey &&
          "string" == typeof e.receiverPublicKey
        );
      }
      function cF(e) {
        return e?.relay || { protocol: "irn" };
      }
      function cW(e) {
        let t = ni[e];
        if (typeof t > "u") throw Error(`Relay Protocol not supported: ${e}`);
        return t;
      }
      function cq(e) {
        var t;
        if (!e.includes("wc:")) {
          let t = nW(e);
          null != t && t.includes("wc:") && (e = t);
        }
        let r = (e = (e = e.includes("wc://")
            ? e.replace("wc://", "")
            : e).includes("wc:")
            ? e.replace("wc:", "")
            : e).indexOf(":"),
          i = -1 !== e.indexOf("?") ? e.indexOf("?") : void 0,
          s = e.substring(0, r),
          n = e.substring(r + 1, i).split("@"),
          a = new URLSearchParams("u" > typeof i ? e.substring(i) : ""),
          o = {};
        a.forEach((e, t) => {
          o[t] = e;
        });
        let c = "string" == typeof o.methods ? o.methods.split(",") : void 0;
        return {
          protocol: s,
          topic: (t = n[0]).startsWith("//") ? t.substring(2) : t,
          version: parseInt(n[1], 10),
          symKey: o.symKey,
          relay: (function (e, t = "-") {
            let r = {},
              i = "relay" + t;
            return (
              Object.keys(e).forEach((t) => {
                if (t.startsWith(i)) {
                  let s = t.replace(i, ""),
                    n = e[t];
                  r[s] = n;
                }
              }),
              r
            );
          })(o),
          methods: c,
          expiryTimestamp: o.expiryTimestamp
            ? parseInt(o.expiryTimestamp, 10)
            : void 0,
        };
      }
      function cH(e) {
        let t = new URLSearchParams(),
          r = (function (e, t = "-") {
            let r = {};
            return (
              Object.keys(e).forEach((i) => {
                e[i] && (r["relay" + t + i] = e[i]);
              }),
              r
            );
          })(e.relay);
        Object.keys(r)
          .sort()
          .forEach((e) => {
            t.set(e, r[e]);
          }),
          t.set("symKey", e.symKey),
          e.expiryTimestamp &&
            t.set("expiryTimestamp", e.expiryTimestamp.toString()),
          e.methods && t.set("methods", e.methods.join(","));
        let i = t.toString();
        return `${e.protocol}:${e.topic}@${e.version}?${i}`;
      }
      function cz(e, t, r) {
        return `${e}?wc_ev=${r}&topic=${t}`;
      }
      var cV = Object.defineProperty,
        cK = Object.defineProperties,
        cG = Object.getOwnPropertyDescriptors,
        cY = Object.getOwnPropertySymbols,
        cZ = Object.prototype.hasOwnProperty,
        cJ = Object.prototype.propertyIsEnumerable,
        cX = (e, t, r) =>
          t in e
            ? cV(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        cQ = (e, t) => {
          for (var r in t || (t = {})) cZ.call(t, r) && cX(e, r, t[r]);
          if (cY) for (var r of cY(t)) cJ.call(t, r) && cX(e, r, t[r]);
          return e;
        },
        c0 = (e, t) => cK(e, cG(t));
      function c1(e) {
        let t = [];
        return (
          e.forEach((e) => {
            let [r, i] = e.split(":");
            t.push(`${r}:${i}`);
          }),
          t
        );
      }
      function c2(e) {
        return e.includes(":");
      }
      function c3(e) {
        return c2(e) ? e.split(":")[0] : e;
      }
      function c5(e) {
        var t, r, i;
        let s = {};
        if (!lt(e)) return s;
        for (let [n, a] of Object.entries(e)) {
          let e = c2(n) ? [n] : a.chains,
            o = a.methods || [],
            c = a.events || [],
            l = c3(n);
          s[l] = c0(cQ({}, s[l]), {
            chains: nL(e, null == (t = s[l]) ? void 0 : t.chains),
            methods: nL(o, null == (r = s[l]) ? void 0 : r.methods),
            events: nL(c, null == (i = s[l]) ? void 0 : i.events),
          });
        }
        return s;
      }
      function c8(e, t) {
        let r = (function (e) {
          let t = {};
          return (
            e?.forEach((e) => {
              var r;
              let [i, s] = e.split(":");
              t[i] ||
                (t[i] = { accounts: [], chains: [], events: [], methods: [] }),
                t[i].accounts.push(e),
                null == (r = t[i].chains) || r.push(`${i}:${s}`);
            }),
            t
          );
        })((t = t.map((e) => e.replace("did:pkh:", ""))));
        for (let [t, i] of Object.entries(r))
          i.methods ? (i.methods = nL(i.methods, e)) : (i.methods = e),
            (i.events = ["chainChanged", "accountsChanged"]);
        return r;
      }
      let c6 = {
          INVALID_METHOD: { message: "Invalid method.", code: 1001 },
          INVALID_EVENT: { message: "Invalid event.", code: 1002 },
          INVALID_UPDATE_REQUEST: {
            message: "Invalid update request.",
            code: 1003,
          },
          INVALID_EXTEND_REQUEST: {
            message: "Invalid extend request.",
            code: 1004,
          },
          INVALID_SESSION_SETTLE_REQUEST: {
            message: "Invalid session settle request.",
            code: 1005,
          },
          UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 },
          UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 },
          UNAUTHORIZED_UPDATE_REQUEST: {
            message: "Unauthorized update request.",
            code: 3003,
          },
          UNAUTHORIZED_EXTEND_REQUEST: {
            message: "Unauthorized extend request.",
            code: 3004,
          },
          USER_REJECTED: { message: "User rejected.", code: 5e3 },
          USER_REJECTED_CHAINS: {
            message: "User rejected chains.",
            code: 5001,
          },
          USER_REJECTED_METHODS: {
            message: "User rejected methods.",
            code: 5002,
          },
          USER_REJECTED_EVENTS: {
            message: "User rejected events.",
            code: 5003,
          },
          UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 },
          UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 },
          UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 },
          UNSUPPORTED_ACCOUNTS: {
            message: "Unsupported accounts.",
            code: 5103,
          },
          UNSUPPORTED_NAMESPACE_KEY: {
            message: "Unsupported namespace key.",
            code: 5104,
          },
          USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 },
          SESSION_SETTLEMENT_FAILED: {
            message: "Session settlement failed.",
            code: 7e3,
          },
          WC_METHOD_UNSUPPORTED: {
            message: "Unsupported wc_ method.",
            code: 10001,
          },
        },
        c4 = {
          NOT_INITIALIZED: { message: "Not initialized.", code: 1 },
          NO_MATCHING_KEY: { message: "No matching key.", code: 2 },
          RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 },
          RESUBSCRIBED: { message: "Resubscribed.", code: 4 },
          MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 },
          EXPIRED: { message: "Expired.", code: 6 },
          UNKNOWN_TYPE: { message: "Unknown type.", code: 7 },
          MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 },
          NON_CONFORMING_NAMESPACES: {
            message: "Non conforming namespaces.",
            code: 9,
          },
        };
      function c9(e, t) {
        let { message: r, code: i } = c4[e];
        return { message: t ? `${r} ${t}` : r, code: i };
      }
      function c7(e, t) {
        let { message: r, code: i } = c6[e];
        return { message: t ? `${r} ${t}` : r, code: i };
      }
      function le(e, t) {
        return (
          !!Array.isArray(e) && (!("u" > typeof t) || !e.length || e.every(t))
        );
      }
      function lt(e) {
        return (
          Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length
        );
      }
      function lr(e) {
        return typeof e > "u";
      }
      function li(e, t) {
        return !!(t && lr(e)) || ("string" == typeof e && !!e.trim().length);
      }
      function ls(e, t) {
        return !!(t && lr(e)) || ("number" == typeof e && !isNaN(e));
      }
      function ln(e) {
        return !!(li(e, !1) && e.includes(":")) && 2 === e.split(":").length;
      }
      function la(e) {
        let t = !0;
        return (
          le(e) ? e.length && (t = e.every((e) => li(e, !1))) : (t = !1), t
        );
      }
      function lo(e, t) {
        let r = null;
        return (
          Object.values(e).forEach((e) => {
            var i;
            let s;
            if (r) return;
            let n =
              ((i = `${t}, namespace`),
              (s = null),
              la(e?.methods)
                ? la(e?.events) ||
                  (s = c7(
                    "UNSUPPORTED_EVENTS",
                    `${i}, events should be an array of strings or empty array for no events`
                  ))
                : (s = c7(
                    "UNSUPPORTED_METHODS",
                    `${i}, methods should be an array of strings or empty array for no methods`
                  )),
              s);
            n && (r = n);
          }),
          r
        );
      }
      function lc(e, t) {
        let r = null;
        if (e && lt(e)) {
          let i,
            s = lo(e, t);
          s && (r = s);
          let n =
            ((i = null),
            Object.values(e).forEach((e) => {
              var r, s;
              let n;
              if (i) return;
              let a =
                ((r = e?.accounts),
                (s = `${t} namespace`),
                (n = null),
                le(r)
                  ? r.forEach((e) => {
                      n ||
                        (function (e) {
                          if (li(e, !1) && e.includes(":")) {
                            let t = e.split(":");
                            if (3 === t.length) {
                              let e = t[0] + ":" + t[1];
                              return !!t[2] && ln(e);
                            }
                          }
                          return !1;
                        })(e) ||
                        (n = c7(
                          "UNSUPPORTED_ACCOUNTS",
                          `${s}, account ${e} should be a string and conform to "namespace:chainId:address" format`
                        ));
                    })
                  : (n = c7(
                      "UNSUPPORTED_ACCOUNTS",
                      `${s}, accounts should be an array of strings conforming to "namespace:chainId:address" format`
                    )),
                n);
              a && (i = a);
            }),
            i);
          n && (r = n);
        } else
          r = c9(
            "MISSING_OR_INVALID",
            `${t}, namespaces should be an object with data`
          );
        return r;
      }
      function ll(e) {
        return li(e.protocol, !0);
      }
      function lu(e) {
        return "u" > typeof e;
      }
      function ld(e, t) {
        return !(
          !ln(t) ||
          !(function (e) {
            let t = [];
            return (
              Object.values(e).forEach((e) => {
                t.push(...c1(e.accounts));
              }),
              t
            );
          })(e).includes(t)
        );
      }
      function lh(e, t, r) {
        let i = null,
          s = (function (e) {
            let t = {};
            return (
              Object.keys(e).forEach((r) => {
                var i;
                r.includes(":")
                  ? (t[r] = e[r])
                  : null == (i = e[r].chains) ||
                    i.forEach((i) => {
                      t[i] = { methods: e[r].methods, events: e[r].events };
                    });
              }),
              t
            );
          })(e),
          n = (function (e) {
            let t = {};
            return (
              Object.keys(e).forEach((r) => {
                if (r.includes(":")) t[r] = e[r];
                else {
                  let i = c1(e[r].accounts);
                  i?.forEach((i) => {
                    t[i] = {
                      accounts: e[r].accounts.filter((e) =>
                        e.includes(`${i}:`)
                      ),
                      methods: e[r].methods,
                      events: e[r].events,
                    };
                  });
                }
              }),
              t
            );
          })(t),
          a = Object.keys(s),
          o = Object.keys(n),
          c = lp(Object.keys(e)),
          l = lp(Object.keys(t)),
          u = c.filter((e) => !l.includes(e));
        return (
          u.length &&
            (i = c9(
              "NON_CONFORMING_NAMESPACES",
              `${r} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u.toString()}
      Received: ${Object.keys(t).toString()}`
            )),
          nS(a, o) ||
            (i = c9(
              "NON_CONFORMING_NAMESPACES",
              `${r} namespaces chains don't satisfy required namespaces.
      Required: ${a.toString()}
      Approved: ${o.toString()}`
            )),
          Object.keys(t).forEach((e) => {
            if (!e.includes(":") || i) return;
            let s = c1(t[e].accounts);
            s.includes(e) ||
              (i = c9(
                "NON_CONFORMING_NAMESPACES",
                `${r} namespaces accounts don't satisfy namespace accounts for ${e}
        Required: ${e}
        Approved: ${s.toString()}`
              ));
          }),
          a.forEach((e) => {
            i ||
              (nS(s[e].methods, n[e].methods)
                ? nS(s[e].events, n[e].events) ||
                  (i = c9(
                    "NON_CONFORMING_NAMESPACES",
                    `${r} namespaces events don't satisfy namespace events for ${e}`
                  ))
                : (i = c9(
                    "NON_CONFORMING_NAMESPACES",
                    `${r} namespaces methods don't satisfy namespace methods for ${e}`
                  )));
          }),
          i
        );
      }
      function lp(e) {
        return [
          ...new Set(e.map((e) => (e.includes(":") ? e.split(":")[0] : e))),
        ];
      }
      function lf() {
        let e = n_();
        return new Promise((t) => {
          switch (e) {
            case nb.browser:
              t(nE() && navigator?.onLine);
              break;
            case nb.reactNative:
              t(lg());
              break;
            case nb.node:
            default:
              t(!0);
          }
        });
      }
      async function lg() {
        if (nv() && "u" > typeof r.g && null != r.g && r.g.NetInfo) {
          let e = await (null == r.g ? void 0 : r.g.NetInfo.fetch());
          return e?.isConnected;
        }
        return !0;
      }
      let lm = {};
      class ly {
        static get(e) {
          return lm[e];
        }
        static set(e, t) {
          lm[e] = t;
        }
        static delete(e) {
          delete lm[e];
        }
      }
      let lb = "INTERNAL_ERROR",
        lw = "SERVER_ERROR",
        lv = [-32700, -32600, -32601, -32602, -32603],
        lE = {
          PARSE_ERROR: { code: -32700, message: "Parse error" },
          INVALID_REQUEST: { code: -32600, message: "Invalid Request" },
          METHOD_NOT_FOUND: { code: -32601, message: "Method not found" },
          INVALID_PARAMS: { code: -32602, message: "Invalid params" },
          [lb]: { code: -32603, message: "Internal error" },
          [lw]: { code: -32e3, message: "Server error" },
        };
      function l_(e) {
        return Object.keys(lE).includes(e) ? lE[e] : lE[lw];
      }
      function lC(e, t, r) {
        return e.message.includes("getaddrinfo ENOTFOUND") ||
          e.message.includes("connect ECONNREFUSED")
          ? Error(`Unavailable ${r} RPC url at ${t}`)
          : e;
      }
      var lA = r(91203);
      function lI(e = 3) {
        return (
          Date.now() * Math.pow(10, e) +
          Math.floor(Math.random() * Math.pow(10, e))
        );
      }
      function lS(e = 6) {
        return BigInt(lI(e));
      }
      function lN(e, t, r) {
        return { id: r || lI(), jsonrpc: "2.0", method: e, params: t };
      }
      function lT(e, t) {
        return { id: e, jsonrpc: "2.0", result: t };
      }
      function lO(e, t, r) {
        var i, s, n;
        return {
          id: e,
          jsonrpc: "2.0",
          error:
            ((i = t),
            (s = r),
            void 0 === i
              ? l_(lb)
              : ("string" == typeof i &&
                  (i = Object.assign(Object.assign({}, l_(lw)), {
                    message: i,
                  })),
                void 0 !== s && (i.data = s),
                (n = i.code),
                lv.includes(n) &&
                  (i = (function (e) {
                    let t = Object.values(lE).find((t) => t.code === e);
                    return t || lE[lw];
                  })(i.code)),
                i)),
        };
      }
      class lx {}
      class lP extends lx {
        constructor() {
          super();
        }
      }
      class lR extends lP {
        constructor(e) {
          super();
        }
      }
      function lk(e, t) {
        let r = (function (e) {
          let t = e.match(RegExp(/^\w+:/, "gi"));
          if (t && t.length) return t[0];
        })(e);
        return void 0 !== r && new RegExp(t).test(r);
      }
      function lD(e) {
        return lk(e, "^https?:");
      }
      function lU(e) {
        return lk(e, "^wss?:");
      }
      function lL(e) {
        return (
          "object" == typeof e &&
          "id" in e &&
          "jsonrpc" in e &&
          "2.0" === e.jsonrpc
        );
      }
      function lM(e) {
        return lL(e) && "method" in e;
      }
      function lj(e) {
        return lL(e) && (l$(e) || lB(e));
      }
      function l$(e) {
        return "result" in e;
      }
      function lB(e) {
        return "error" in e;
      }
      class lF extends lR {
        constructor(e) {
          super(e),
            (this.events = new b.EventEmitter()),
            (this.hasRegisteredEventListeners = !1),
            (this.connection = this.setConnection(e)),
            this.connection.connected && this.registerEventListeners();
        }
        async connect(e = this.connection) {
          await this.open(e);
        }
        async disconnect() {
          await this.close();
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async request(e, t) {
          return this.requestStrict(
            lN(e.method, e.params || [], e.id || lS().toString()),
            t
          );
        }
        async requestStrict(e, t) {
          return new Promise(async (r, i) => {
            if (!this.connection.connected)
              try {
                await this.open();
              } catch (e) {
                i(e);
              }
            this.events.on(`${e.id}`, (e) => {
              lB(e) ? i(e.error) : r(e.result);
            });
            try {
              await this.connection.send(e, t);
            } catch (e) {
              i(e);
            }
          });
        }
        setConnection(e = this.connection) {
          return e;
        }
        onPayload(e) {
          this.events.emit("payload", e),
            lj(e)
              ? this.events.emit(`${e.id}`, e)
              : this.events.emit("message", { type: e.method, data: e.params });
        }
        onClose(e) {
          e &&
            3e3 === e.code &&
            this.events.emit(
              "error",
              Error(
                `WebSocket connection closed abnormally with code: ${e.code} ${
                  e.reason ? `(${e.reason})` : ""
                }`
              )
            ),
            this.events.emit("disconnect");
        }
        async open(e = this.connection) {
          (this.connection === e && this.connection.connected) ||
            (this.connection.connected && this.close(),
            "string" == typeof e &&
              (await this.connection.open(e), (e = this.connection)),
            (this.connection = this.setConnection(e)),
            await this.connection.open(),
            this.registerEventListeners(),
            this.events.emit("connect"));
        }
        async close() {
          await this.connection.close();
        }
        registerEventListeners() {
          this.hasRegisteredEventListeners ||
            (this.connection.on("payload", (e) => this.onPayload(e)),
            this.connection.on("close", (e) => this.onClose(e)),
            this.connection.on("error", (e) => this.events.emit("error", e)),
            this.connection.on("register_error", (e) => this.onClose()),
            (this.hasRegisteredEventListeners = !0));
        }
      }
      let lW = () =>
          "u" > typeof WebSocket ||
          ("u" > typeof r.g && "u" > typeof r.g.WebSocket) ||
          ("u" > typeof window && "u" > typeof window.WebSocket) ||
          ("u" > typeof self && "u" > typeof self.WebSocket),
        lq = (e) => e.split("?")[0],
        lH =
          "u" > typeof WebSocket
            ? WebSocket
            : "u" > typeof r.g && "u" > typeof r.g.WebSocket
            ? r.g.WebSocket
            : "u" > typeof window && "u" > typeof window.WebSocket
            ? window.WebSocket
            : "u" > typeof self && "u" > typeof self.WebSocket
            ? self.WebSocket
            : r(20294);
      class lz {
        constructor(e) {
          if (
            ((this.url = e),
            (this.events = new b.EventEmitter()),
            (this.registering = !1),
            !lU(e))
          )
            throw Error(
              `Provided URL is not compatible with WebSocket connection: ${e}`
            );
          this.url = e;
        }
        get connected() {
          return "u" > typeof this.socket;
        }
        get connecting() {
          return this.registering;
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async open(e = this.url) {
          await this.register(e);
        }
        async close() {
          return new Promise((e, t) => {
            if (typeof this.socket > "u")
              return void t(Error("Connection already closed"));
            (this.socket.onclose = (t) => {
              this.onClose(t), e();
            }),
              this.socket.close();
          });
        }
        async send(e) {
          typeof this.socket > "u" && (this.socket = await this.register());
          try {
            this.socket.send((0, H.h)(e));
          } catch (t) {
            this.onError(e.id, t);
          }
        }
        register(e = this.url) {
          if (!lU(e))
            throw Error(
              `Provided URL is not compatible with WebSocket connection: ${e}`
            );
          if (this.registering) {
            let e = this.events.getMaxListeners();
            return (
              (this.events.listenerCount("register_error") >= e ||
                this.events.listenerCount("open") >= e) &&
                this.events.setMaxListeners(e + 1),
              new Promise((e, t) => {
                this.events.once("register_error", (e) => {
                  this.resetMaxListeners(), t(e);
                }),
                  this.events.once("open", () => {
                    if ((this.resetMaxListeners(), typeof this.socket > "u"))
                      return t(
                        Error("WebSocket connection is missing or invalid")
                      );
                    e(this.socket);
                  });
              })
            );
          }
          return (
            (this.url = e),
            (this.registering = !0),
            new Promise((t, r) => {
              let i = (0, lA.isReactNative)()
                  ? void 0
                  : {
                      rejectUnauthorized: !RegExp(
                        "wss?://localhost(:d{2,5})?"
                      ).test(e),
                    },
                s = new lH(e, [], i);
              lW()
                ? (s.onerror = (e) => {
                    r(this.emitError(e.error));
                  })
                : s.on("error", (e) => {
                    r(this.emitError(e));
                  }),
                (s.onopen = () => {
                  this.onOpen(s), t(s);
                });
            })
          );
        }
        onOpen(e) {
          (e.onmessage = (e) => this.onPayload(e)),
            (e.onclose = (e) => this.onClose(e)),
            (this.socket = e),
            (this.registering = !1),
            this.events.emit("open");
        }
        onClose(e) {
          (this.socket = void 0),
            (this.registering = !1),
            this.events.emit("close", e);
        }
        onPayload(e) {
          if (typeof e.data > "u") return;
          let t = "string" == typeof e.data ? (0, H.j)(e.data) : e.data;
          this.events.emit("payload", t);
        }
        onError(e, t) {
          let r = this.parseError(t),
            i = lO(e, r.message || r.toString());
          this.events.emit("payload", i);
        }
        parseError(e, t = this.url) {
          return lC(e, lq(t), "WS");
        }
        resetMaxListeners() {
          this.events.getMaxListeners() > 10 && this.events.setMaxListeners(10);
        }
        emitError(e) {
          let t = this.parseError(
            Error(
              e?.message ||
                `WebSocket connection failed for host: ${lq(this.url)}`
            )
          );
          return this.events.emit("register_error", t), t;
        }
      }
      var lV = r(44134).Buffer,
        lK = r(49509);
      let lG = "core",
        lY = `wc@2:${lG}:`,
        lZ = { logger: "error" },
        lJ = { database: ":memory:" },
        lX = "client_ed25519_seed",
        lQ = v.ONE_DAY,
        l0 = v.SIX_HOURS,
        l1 = "wss://relay.walletconnect.org",
        l2 = {
          message: "relayer_message",
          message_ack: "relayer_message_ack",
          connect: "relayer_connect",
          disconnect: "relayer_disconnect",
          error: "relayer_error",
          connection_stalled: "relayer_connection_stalled",
          publish: "relayer_publish",
        },
        l3 = {
          payload: "payload",
          connect: "connect",
          disconnect: "disconnect",
          error: "error",
        },
        l5 = "2.21.0",
        l8 = { link_mode: "link_mode", relay: "relay" },
        l6 = { inbound: "inbound", outbound: "outbound" },
        l4 = "WALLETCONNECT_LINK_MODE_APPS",
        l9 = {
          created: "subscription_created",
          deleted: "subscription_deleted",
          sync: "subscription_sync",
          resubscribed: "subscription_resubscribed",
        },
        l7 =
          (v.FIVE_SECONDS,
          {
            wc_pairingDelete: {
              req: { ttl: v.ONE_DAY, prompt: !1, tag: 1e3 },
              res: { ttl: v.ONE_DAY, prompt: !1, tag: 1001 },
            },
            wc_pairingPing: {
              req: { ttl: v.THIRTY_SECONDS, prompt: !1, tag: 1002 },
              res: { ttl: v.THIRTY_SECONDS, prompt: !1, tag: 1003 },
            },
            unregistered_method: {
              req: { ttl: v.ONE_DAY, prompt: !1, tag: 0 },
              res: { ttl: v.ONE_DAY, prompt: !1, tag: 0 },
            },
          }),
        ue = {
          create: "pairing_create",
          expire: "pairing_expire",
          delete: "pairing_delete",
          ping: "pairing_ping",
        },
        ut = {
          created: "history_created",
          updated: "history_updated",
          deleted: "history_deleted",
          sync: "history_sync",
        },
        ur = {
          created: "expirer_created",
          deleted: "expirer_deleted",
          expired: "expirer_expired",
          sync: "expirer_sync",
        },
        ui = "https://verify.walletconnect.org",
        us = `${ui}/v3`,
        un = ["https://verify.walletconnect.com", ui],
        ua = {
          pairing_started: "pairing_started",
          pairing_uri_validation_success: "pairing_uri_validation_success",
          pairing_uri_not_expired: "pairing_uri_not_expired",
          store_new_pairing: "store_new_pairing",
          subscribing_pairing_topic: "subscribing_pairing_topic",
          subscribe_pairing_topic_success: "subscribe_pairing_topic_success",
          existing_pairing: "existing_pairing",
          pairing_not_expired: "pairing_not_expired",
          emit_inactive_pairing: "emit_inactive_pairing",
          emit_session_proposal: "emit_session_proposal",
        },
        uo = {
          no_internet_connection: "no_internet_connection",
          malformed_pairing_uri: "malformed_pairing_uri",
          active_pairing_already_exists: "active_pairing_already_exists",
          subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure",
          pairing_expired: "pairing_expired",
          proposal_listener_not_found: "proposal_listener_not_found",
        },
        uc = {
          session_approve_started: "session_approve_started",
          session_namespaces_validation_success:
            "session_namespaces_validation_success",
          subscribing_session_topic: "subscribing_session_topic",
          subscribe_session_topic_success: "subscribe_session_topic_success",
          publishing_session_approve: "publishing_session_approve",
          session_approve_publish_success: "session_approve_publish_success",
          store_session: "store_session",
          publishing_session_settle: "publishing_session_settle",
          session_settle_publish_success: "session_settle_publish_success",
        },
        ul = {
          no_internet_connection: "no_internet_connection",
          proposal_expired: "proposal_expired",
          subscribe_session_topic_failure: "subscribe_session_topic_failure",
          session_approve_publish_failure: "session_approve_publish_failure",
          session_settle_publish_failure: "session_settle_publish_failure",
          session_approve_namespace_validation_failure:
            "session_approve_namespace_validation_failure",
          proposal_not_found: "proposal_not_found",
        },
        uu = {
          authenticated_session_approve_started:
            "authenticated_session_approve_started",
          create_authenticated_session_topic:
            "create_authenticated_session_topic",
          cacaos_verified: "cacaos_verified",
          store_authenticated_session: "store_authenticated_session",
          subscribing_authenticated_session_topic:
            "subscribing_authenticated_session_topic",
          subscribe_authenticated_session_topic_success:
            "subscribe_authenticated_session_topic_success",
          publishing_authenticated_session_approve:
            "publishing_authenticated_session_approve",
        },
        ud = {
          no_internet_connection: "no_internet_connection",
          invalid_cacao: "invalid_cacao",
          subscribe_authenticated_session_topic_failure:
            "subscribe_authenticated_session_topic_failure",
          authenticated_session_approve_publish_failure:
            "authenticated_session_approve_publish_failure",
          authenticated_session_pending_request_not_found:
            "authenticated_session_pending_request_not_found",
        };
      var uh = function (e, t) {
        if (e.length >= 255) throw TypeError("Alphabet too long");
        for (var r = new Uint8Array(256), i = 0; i < r.length; i++) r[i] = 255;
        for (var s = 0; s < e.length; s++) {
          var n = e.charAt(s),
            a = n.charCodeAt(0);
          if (255 !== r[a]) throw TypeError(n + " is ambiguous");
          r[a] = s;
        }
        var o = e.length,
          c = e.charAt(0),
          l = Math.log(o) / Math.log(256),
          u = Math.log(256) / Math.log(o);
        function d(e) {
          if ("string" != typeof e) throw TypeError("Expected String");
          if (0 === e.length) return new Uint8Array();
          var t = 0;
          if (" " !== e[0]) {
            for (var i = 0, s = 0; e[t] === c; ) i++, t++;
            for (
              var n = ((e.length - t) * l + 1) >>> 0, a = new Uint8Array(n);
              e[t];

            ) {
              var u = r[e.charCodeAt(t)];
              if (255 === u) return;
              for (
                var d = 0, h = n - 1;
                (0 !== u || d < s) && -1 !== h;
                h--, d++
              )
                (u += (o * a[h]) >>> 0),
                  (a[h] = u % 256 >>> 0),
                  (u = (u / 256) >>> 0);
              if (0 !== u) throw Error("Non-zero carry");
              (s = d), t++;
            }
            if (" " !== e[t]) {
              for (var p = n - s; p !== n && 0 === a[p]; ) p++;
              for (var f = new Uint8Array(i + (n - p)), g = i; p !== n; )
                f[g++] = a[p++];
              return f;
            }
          }
        }
        return {
          encode: function (t) {
            if (
              (t instanceof Uint8Array ||
                (ArrayBuffer.isView(t)
                  ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                  : Array.isArray(t) && (t = Uint8Array.from(t))),
              !(t instanceof Uint8Array))
            )
              throw TypeError("Expected Uint8Array");
            if (0 === t.length) return "";
            for (var r = 0, i = 0, s = 0, n = t.length; s !== n && 0 === t[s]; )
              s++, r++;
            for (
              var a = ((n - s) * u + 1) >>> 0, l = new Uint8Array(a);
              s !== n;

            ) {
              for (
                var d = t[s], h = 0, p = a - 1;
                (0 !== d || h < i) && -1 !== p;
                p--, h++
              )
                (d += (256 * l[p]) >>> 0),
                  (l[p] = d % o >>> 0),
                  (d = (d / o) >>> 0);
              if (0 !== d) throw Error("Non-zero carry");
              (i = h), s++;
            }
            for (var f = a - i; f !== a && 0 === l[f]; ) f++;
            for (var g = c.repeat(r); f < a; ++f) g += e.charAt(l[f]);
            return g;
          },
          decodeUnsafe: d,
          decode: function (e) {
            var r = d(e);
            if (r) return r;
            throw Error(`Non-${t} character`);
          },
        };
      };
      let up = (e) => {
          if (e instanceof Uint8Array && "Uint8Array" === e.constructor.name)
            return e;
          if (e instanceof ArrayBuffer) return new Uint8Array(e);
          if (ArrayBuffer.isView(e))
            return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
          throw Error("Unknown type, must be binary type");
        },
        uf = (e) => new TextEncoder().encode(e),
        ug = (e) => new TextDecoder().decode(e);
      class um {
        constructor(e, t, r) {
          (this.name = e), (this.prefix = t), (this.baseEncode = r);
        }
        encode(e) {
          if (e instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(e)}`;
          throw Error("Unknown type, must be binary type");
        }
      }
      class uy {
        constructor(e, t, r) {
          if (((this.name = e), (this.prefix = t), void 0 === t.codePointAt(0)))
            throw Error("Invalid prefix character");
          (this.prefixCodePoint = t.codePointAt(0)), (this.baseDecode = r);
        }
        decode(e) {
          if ("string" == typeof e) {
            if (e.codePointAt(0) !== this.prefixCodePoint)
              throw Error(
                `Unable to decode multibase string ${JSON.stringify(e)}, ${
                  this.name
                } decoder only supports inputs prefixed with ${this.prefix}`
              );
            return this.baseDecode(e.slice(this.prefix.length));
          }
          throw Error("Can only multibase decode strings");
        }
        or(e) {
          return uw(this, e);
        }
      }
      class ub {
        constructor(e) {
          this.decoders = e;
        }
        or(e) {
          return uw(this, e);
        }
        decode(e) {
          let t = e[0],
            r = this.decoders[t];
          if (r) return r.decode(e);
          throw RangeError(
            `Unable to decode multibase string ${JSON.stringify(
              e
            )}, only inputs prefixed with ${Object.keys(
              this.decoders
            )} are supported`
          );
        }
      }
      let uw = (e, t) =>
        new ub({
          ...(e.decoders || { [e.prefix]: e }),
          ...(t.decoders || { [t.prefix]: t }),
        });
      class uv {
        constructor(e, t, r, i) {
          (this.name = e),
            (this.prefix = t),
            (this.baseEncode = r),
            (this.baseDecode = i),
            (this.encoder = new um(e, t, r)),
            (this.decoder = new uy(e, t, i));
        }
        encode(e) {
          return this.encoder.encode(e);
        }
        decode(e) {
          return this.decoder.decode(e);
        }
      }
      let uE = ({ name: e, prefix: t, encode: r, decode: i }) =>
          new uv(e, t, r, i),
        u_ = ({ prefix: e, name: t, alphabet: r }) => {
          let { encode: i, decode: s } = uh(r, t);
          return uE({ prefix: e, name: t, encode: i, decode: (e) => up(s(e)) });
        },
        uC = (e, t, r, i) => {
          let s = {};
          for (let e = 0; e < t.length; ++e) s[t[e]] = e;
          let n = e.length;
          for (; "=" === e[n - 1]; ) --n;
          let a = new Uint8Array(((n * r) / 8) | 0),
            o = 0,
            c = 0,
            l = 0;
          for (let t = 0; t < n; ++t) {
            let n = s[e[t]];
            if (void 0 === n) throw SyntaxError(`Non-${i} character`);
            (c = (c << r) | n),
              (o += r) >= 8 && ((o -= 8), (a[l++] = 255 & (c >> o)));
          }
          if (o >= r || 255 & (c << (8 - o)))
            throw SyntaxError("Unexpected end of data");
          return a;
        },
        uA = (e, t, r) => {
          let i = "=" === t[t.length - 1],
            s = (1 << r) - 1,
            n = "",
            a = 0,
            o = 0;
          for (let i = 0; i < e.length; ++i)
            for (o = (o << 8) | e[i], a += 8; a > r; )
              (a -= r), (n += t[s & (o >> a)]);
          if ((a && (n += t[s & (o << (r - a))]), i))
            for (; (n.length * r) & 7; ) n += "=";
          return n;
        },
        uI = ({ name: e, prefix: t, bitsPerChar: r, alphabet: i }) =>
          uE({
            prefix: t,
            name: e,
            encode: (e) => uA(e, i, r),
            decode: (t) => uC(t, i, r, e),
          });
      var uS = Object.freeze({
          __proto__: null,
          identity: uE({
            prefix: "\0",
            name: "identity",
            encode: (e) => ug(e),
            decode: (e) => uf(e),
          }),
        }),
        uN = Object.freeze({
          __proto__: null,
          base2: uI({
            prefix: "0",
            name: "base2",
            alphabet: "01",
            bitsPerChar: 1,
          }),
        }),
        uT = Object.freeze({
          __proto__: null,
          base8: uI({
            prefix: "7",
            name: "base8",
            alphabet: "01234567",
            bitsPerChar: 3,
          }),
        }),
        uO = Object.freeze({
          __proto__: null,
          base10: u_({ prefix: "9", name: "base10", alphabet: "0123456789" }),
        }),
        ux = Object.freeze({
          __proto__: null,
          base16: uI({
            prefix: "f",
            name: "base16",
            alphabet: "0123456789abcdef",
            bitsPerChar: 4,
          }),
          base16upper: uI({
            prefix: "F",
            name: "base16upper",
            alphabet: "0123456789ABCDEF",
            bitsPerChar: 4,
          }),
        });
      let uP = uI({
          prefix: "b",
          name: "base32",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567",
          bitsPerChar: 5,
        }),
        uR = uI({
          prefix: "B",
          name: "base32upper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
          bitsPerChar: 5,
        }),
        uk = uI({
          prefix: "c",
          name: "base32pad",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
          bitsPerChar: 5,
        }),
        uD = uI({
          prefix: "C",
          name: "base32padupper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
          bitsPerChar: 5,
        }),
        uU = uI({
          prefix: "v",
          name: "base32hex",
          alphabet: "0123456789abcdefghijklmnopqrstuv",
          bitsPerChar: 5,
        }),
        uL = uI({
          prefix: "V",
          name: "base32hexupper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
          bitsPerChar: 5,
        }),
        uM = uI({
          prefix: "t",
          name: "base32hexpad",
          alphabet: "0123456789abcdefghijklmnopqrstuv=",
          bitsPerChar: 5,
        });
      var uj = Object.freeze({
          __proto__: null,
          base32: uP,
          base32upper: uR,
          base32pad: uk,
          base32padupper: uD,
          base32hex: uU,
          base32hexupper: uL,
          base32hexpad: uM,
          base32hexpadupper: uI({
            prefix: "T",
            name: "base32hexpadupper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
            bitsPerChar: 5,
          }),
          base32z: uI({
            prefix: "h",
            name: "base32z",
            alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
            bitsPerChar: 5,
          }),
        }),
        u$ = Object.freeze({
          __proto__: null,
          base36: u_({
            prefix: "k",
            name: "base36",
            alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
          }),
          base36upper: u_({
            prefix: "K",
            name: "base36upper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
          }),
        }),
        uB = Object.freeze({
          __proto__: null,
          base58btc: u_({
            name: "base58btc",
            prefix: "z",
            alphabet:
              "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
          }),
          base58flickr: u_({
            name: "base58flickr",
            prefix: "Z",
            alphabet:
              "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
          }),
        });
      let uF = uI({
          prefix: "m",
          name: "base64",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          bitsPerChar: 6,
        }),
        uW = uI({
          prefix: "M",
          name: "base64pad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          bitsPerChar: 6,
        });
      var uq = Object.freeze({
        __proto__: null,
        base64: uF,
        base64pad: uW,
        base64url: uI({
          prefix: "u",
          name: "base64url",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
          bitsPerChar: 6,
        }),
        base64urlpad: uI({
          prefix: "U",
          name: "base64urlpad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
          bitsPerChar: 6,
        }),
      });
      let uH = Array.from(
          "\uD83D\uDE80\uD83E\uDE90\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\uD83E\uDD19\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\uD83C\uDF1E\uD83C\uDF88\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\uD83D\uDC8E\uD83D\uDCB8\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"
        ),
        uz = uH.reduce((e, t, r) => ((e[r] = t), e), []),
        uV = uH.reduce((e, t, r) => ((e[t.codePointAt(0)] = r), e), []);
      var uK = Object.freeze({
        __proto__: null,
        base256emoji: uE({
          prefix: "\uD83D\uDE80",
          name: "base256emoji",
          encode: function (e) {
            return e.reduce((e, t) => (e += uz[t]), "");
          },
          decode: function (e) {
            let t = [];
            for (let r of e) {
              let e = uV[r.codePointAt(0)];
              if (void 0 === e) throw Error(`Non-base256emoji character: ${r}`);
              t.push(e);
            }
            return new Uint8Array(t);
          },
        }),
      });
      function uG(e, t, r) {
        (t = t || []), (r = r || 0);
        for (var i = r; e >= 0x80000000; )
          (t[r++] = (255 & e) | 128), (e /= 128);
        for (; -128 & e; ) (t[r++] = (255 & e) | 128), (e >>>= 7);
        return (t[r] = 0 | e), (uG.bytes = r - i + 1), t;
      }
      function uY(e, t) {
        var r,
          i = 0,
          t = t || 0,
          s = 0,
          n = t,
          a = e.length;
        do {
          if (n >= a)
            throw ((uY.bytes = 0), RangeError("Could not decode varint"));
          (r = e[n++]),
            (i += s < 28 ? (127 & r) << s : (127 & r) * Math.pow(2, s)),
            (s += 7);
        } while (r >= 128);
        return (uY.bytes = n - t), i;
      }
      var uZ = {
        encode: uG,
        encodingLength: function (e) {
          return e < 128
            ? 1
            : e < 16384
            ? 2
            : e < 2097152
            ? 3
            : e < 0x10000000
            ? 4
            : e < 0x800000000
            ? 5
            : e < 0x40000000000
            ? 6
            : e < 0x2000000000000
            ? 7
            : e < 0x100000000000000
            ? 8
            : e < 0x8000000000000000
            ? 9
            : 10;
        },
      };
      let uJ = (e, t, r = 0) => (uZ.encode(e, t, r), t),
        uX = (e) => uZ.encodingLength(e),
        uQ = (e, t) => {
          let r = t.byteLength,
            i = uX(e),
            s = i + uX(r),
            n = new Uint8Array(s + r);
          return uJ(e, n, 0), uJ(r, n, i), n.set(t, s), new u0(e, r, t, n);
        };
      class u0 {
        constructor(e, t, r, i) {
          (this.code = e), (this.size = t), (this.digest = r), (this.bytes = i);
        }
      }
      let u1 = ({ name: e, code: t, encode: r }) => new u2(e, t, r);
      class u2 {
        constructor(e, t, r) {
          (this.name = e), (this.code = t), (this.encode = r);
        }
        digest(e) {
          if (e instanceof Uint8Array) {
            let t = this.encode(e);
            return t instanceof Uint8Array
              ? uQ(this.code, t)
              : t.then((e) => uQ(this.code, e));
          }
          throw Error("Unknown type, must be binary type");
        }
      }
      let u3 = (e) => async (t) =>
        new Uint8Array(await crypto.subtle.digest(e, t));
      var u5 = Object.freeze({
          __proto__: null,
          sha256: u1({ name: "sha2-256", code: 18, encode: u3("SHA-256") }),
          sha512: u1({ name: "sha2-512", code: 19, encode: u3("SHA-512") }),
        }),
        u8 = Object.freeze({
          __proto__: null,
          identity: {
            code: 0,
            name: "identity",
            encode: up,
            digest: (e) => uQ(0, up(e)),
          },
        });
      new TextEncoder(), new TextDecoder();
      let u6 = {
        ...uS,
        ...uN,
        ...uT,
        ...uO,
        ...ux,
        ...uj,
        ...u$,
        ...uB,
        ...uq,
        ...uK,
      };
      function u4(e, t, r, i) {
        return {
          name: e,
          prefix: t,
          encoder: { name: e, prefix: t, encode: r },
          decoder: { decode: i },
        };
      }
      ({ ...u5, ...u8 });
      let u9 = u4(
          "utf8",
          "u",
          (e) => "u" + new TextDecoder("utf8").decode(e),
          (e) => new TextEncoder().encode(e.substring(1))
        ),
        u7 = u4(
          "ascii",
          "a",
          (e) => {
            let t = "a";
            for (let r = 0; r < e.length; r++) t += String.fromCharCode(e[r]);
            return t;
          },
          (e) => {
            let t = (function (e = 0) {
              return null != globalThis.Buffer &&
                null != globalThis.Buffer.allocUnsafe
                ? globalThis.Buffer.allocUnsafe(e)
                : new Uint8Array(e);
            })((e = e.substring(1)).length);
            for (let r = 0; r < e.length; r++) t[r] = e.charCodeAt(r);
            return t;
          }
        ),
        de = {
          utf8: u9,
          "utf-8": u9,
          hex: u6.base16,
          latin1: u7,
          ascii: u7,
          binary: u7,
          ...u6,
        };
      var dt = Object.defineProperty,
        dr = (e, t, r) =>
          t in e
            ? dt(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        di = (e, t, r) => dr(e, "symbol" != typeof t ? t + "" : t, r);
      class ds {
        constructor(e, t) {
          (this.core = e),
            (this.logger = t),
            di(this, "keychain", new Map()),
            di(this, "name", "keychain"),
            di(this, "version", "0.3"),
            di(this, "initialized", !1),
            di(this, "storagePrefix", lY),
            di(this, "init", async () => {
              if (!this.initialized) {
                let e = await this.getKeyChain();
                "u" > typeof e && (this.keychain = e), (this.initialized = !0);
              }
            }),
            di(
              this,
              "has",
              (e) => (this.isInitialized(), this.keychain.has(e))
            ),
            di(this, "set", async (e, t) => {
              this.isInitialized(),
                this.keychain.set(e, t),
                await this.persist();
            }),
            di(this, "get", (e) => {
              this.isInitialized();
              let t = this.keychain.get(e);
              if (typeof t > "u") {
                let { message: t } = c9(
                  "NO_MATCHING_KEY",
                  `${this.name}: ${e}`
                );
                throw Error(t);
              }
              return t;
            }),
            di(this, "del", async (e) => {
              this.isInitialized(),
                this.keychain.delete(e),
                await this.persist();
            }),
            (this.core = e),
            (this.logger = (0, ee.U5)(t, this.name));
        }
        get context() {
          return (0, ee.oI)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        async setKeyChain(e) {
          await this.core.storage.setItem(this.storageKey, nN(e));
        }
        async getKeyChain() {
          let e = await this.core.storage.getItem(this.storageKey);
          return "u" > typeof e ? nT(e) : void 0;
        }
        async persist() {
          await this.setKeyChain(this.keychain);
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = c9("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var dn = Object.defineProperty,
        da = (e, t, r) =>
          t in e
            ? dn(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        dc = (e, t, r) => da(e, "symbol" != typeof t ? t + "" : t, r);
      class dl {
        constructor(e, t, r) {
          (this.core = e),
            (this.logger = t),
            dc(this, "name", "crypto"),
            dc(this, "keychain"),
            dc(this, "randomSessionIdentifier", cP()),
            dc(this, "initialized", !1),
            dc(this, "init", async () => {
              this.initialized ||
                (await this.keychain.init(), (this.initialized = !0));
            }),
            dc(
              this,
              "hasKeys",
              (e) => (this.isInitialized(), this.keychain.has(e))
            ),
            dc(
              this,
              "getClientId",
              async () => (
                this.isInitialized(),
                rU(rM(await this.getClientSeed()).publicKey)
              )
            ),
            dc(this, "generateKeyPair", () => {
              this.isInitialized();
              let e = (function () {
                let e = cg.utils.randomPrivateKey(),
                  t = cg.getPublicKey(e);
                return { privateKey: ne(e, cN), publicKey: ne(t, cN) };
              })();
              return this.setPrivateKey(e.publicKey, e.privateKey);
            }),
            dc(this, "signJWT", async (e) => {
              this.isInitialized();
              let t = rM(await this.getClientSeed()),
                r = this.randomSessionIdentifier;
              return await rj(r, e, lQ, t);
            }),
            dc(this, "generateSharedKey", (e, t, r) => {
              var i;
              this.isInitialized();
              let s =
                ((i = this.getPrivateKey(e)),
                ne(
                  ol(
                    og,
                    cg.getSharedSecret(s7(i, cN), s7(t, cN)),
                    void 0,
                    void 0,
                    32
                  ),
                  cN
                ));
              return this.setSymKey(s, r);
            }),
            dc(this, "setSymKey", async (e, t) => {
              this.isInitialized();
              let r = t || cR(e);
              return await this.keychain.set(r, e), r;
            }),
            dc(this, "deleteKeyPair", async (e) => {
              this.isInitialized(), await this.keychain.del(e);
            }),
            dc(this, "deleteSymKey", async (e) => {
              this.isInitialized(), await this.keychain.del(e);
            }),
            dc(this, "encode", async (e, t, r) => {
              this.isInitialized();
              let i = c$(r),
                s = (0, H.h)(t);
              if (2 === i.type)
                return (function (e, t) {
                  let r = s7("2", cS),
                    i = n9(12),
                    s = cM({ type: r, sealed: s7(e, cx), iv: i });
                  return t === cO ? cU(s) : s;
                })(s, r?.encoding);
              if (cB(i)) {
                let t = i.senderPublicKey,
                  r = i.receiverPublicKey;
                e = await this.generateSharedKey(t, r);
              }
              let n = this.getSymKey(e),
                { type: a, senderPublicKey: o } = i;
              return (function (e) {
                var t;
                let r =
                  ((t = "u" > typeof e.type ? e.type : 0), s7(`${t}`, cS));
                if (1 === cD(r) && typeof e.senderPublicKey > "u")
                  throw Error("Missing sender public key for type 1 envelope");
                let i =
                    "u" > typeof e.senderPublicKey
                      ? s7(e.senderPublicKey, cN)
                      : void 0,
                  s = "u" > typeof e.iv ? s7(e.iv, cN) : n9(12),
                  n = cM({
                    type: r,
                    sealed: os(s7(e.symKey, cN), s).encrypt(s7(e.message, cx)),
                    iv: s,
                    senderPublicKey: i,
                  });
                return e.encoding === cO ? cU(n) : n;
              })({
                type: a,
                symKey: n,
                message: s,
                senderPublicKey: o,
                encoding: r?.encoding,
              });
            }),
            dc(this, "decode", async (e, t, r) => {
              this.isInitialized();
              let i = (function (e, t) {
                let r = cj({ encoded: e, encoding: t?.encoding });
                return c$({
                  type: cD(r.type),
                  senderPublicKey:
                    "u" > typeof r.senderPublicKey
                      ? ne(r.senderPublicKey, cN)
                      : void 0,
                  receiverPublicKey: t?.receiverPublicKey,
                });
              })(t, r);
              if (2 === i.type) {
                let e = (function (e, t) {
                  let { sealed: r } = cj({ encoded: e, encoding: t });
                  return ne(r, cx);
                })(t, r?.encoding);
                return (0, H.j)(e);
              }
              if (cB(i)) {
                let t = i.receiverPublicKey,
                  r = i.senderPublicKey;
                e = await this.generateSharedKey(t, r);
              }
              try {
                let i = this.getSymKey(e),
                  s = (function (e) {
                    let t = s7(e.symKey, cN),
                      { sealed: r, iv: i } = cj({
                        encoded: e.encoded,
                        encoding: e.encoding,
                      }),
                      s = os(t, i).decrypt(r);
                    if (null === s) throw Error("Failed to decrypt");
                    return ne(s, cx);
                  })({ symKey: i, encoded: t, encoding: r?.encoding });
                return (0, H.j)(s);
              } catch (t) {
                this.logger.error(
                  `Failed to decode message from topic: '${e}', clientId: '${await this.getClientId()}'`
                ),
                  this.logger.error(t);
              }
            }),
            dc(this, "getPayloadType", (e, t = cT) =>
              cD(cj({ encoded: e, encoding: t }).type)
            ),
            dc(this, "getPayloadSenderPublicKey", (e, t = cT) => {
              let r = cj({ encoded: e, encoding: t });
              return r.senderPublicKey ? ne(r.senderPublicKey, cN) : void 0;
            }),
            (this.core = e),
            (this.logger = (0, ee.U5)(t, this.name)),
            (this.keychain = r || new ds(this.core, this.logger));
        }
        get context() {
          return (0, ee.oI)(this.logger);
        }
        async setPrivateKey(e, t) {
          return await this.keychain.set(e, t), e;
        }
        getPrivateKey(e) {
          return this.keychain.get(e);
        }
        async getClientSeed() {
          let e = "";
          try {
            e = this.keychain.get(lX);
          } catch {
            (e = cP()), await this.keychain.set(lX, e);
          }
          return (function (e, t = "utf8") {
            let r = de[t];
            if (!r) throw Error(`Unsupported encoding "${t}"`);
            return ("utf8" === t || "utf-8" === t) &&
              null != globalThis.Buffer &&
              null != globalThis.Buffer.from
              ? globalThis.Buffer.from(e, "utf8")
              : r.decoder.decode(`${r.prefix}${e}`);
          })(e, "base16");
        }
        getSymKey(e) {
          return this.keychain.get(e);
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = c9("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var du = Object.defineProperty,
        dd = Object.defineProperties,
        dh = Object.getOwnPropertyDescriptors,
        dp = Object.getOwnPropertySymbols,
        df = Object.prototype.hasOwnProperty,
        dg = Object.prototype.propertyIsEnumerable,
        dm = (e, t, r) =>
          t in e
            ? du(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        dy = (e, t) => {
          for (var r in t || (t = {})) df.call(t, r) && dm(e, r, t[r]);
          if (dp) for (var r of dp(t)) dg.call(t, r) && dm(e, r, t[r]);
          return e;
        },
        db = (e, t) => dd(e, dh(t)),
        dw = (e, t, r) => dm(e, "symbol" != typeof t ? t + "" : t, r);
      class dv extends el {
        constructor(e, t) {
          super(e, t),
            (this.logger = e),
            (this.core = t),
            dw(this, "messages", new Map()),
            dw(this, "messagesWithoutClientAck", new Map()),
            dw(this, "name", "messages"),
            dw(this, "version", "0.3"),
            dw(this, "initialized", !1),
            dw(this, "storagePrefix", lY),
            dw(this, "init", async () => {
              if (!this.initialized) {
                this.logger.trace("Initialized");
                try {
                  let e = await this.getRelayerMessages();
                  "u" > typeof e && (this.messages = e);
                  let t = await this.getRelayerMessagesWithoutClientAck();
                  "u" > typeof t && (this.messagesWithoutClientAck = t),
                    this.logger.debug(
                      `Successfully Restored records for ${this.name}`
                    ),
                    this.logger.trace({
                      type: "method",
                      method: "restore",
                      size: this.messages.size,
                    });
                } catch (e) {
                  this.logger.debug(
                    `Failed to Restore records for ${this.name}`
                  ),
                    this.logger.error(e);
                } finally {
                  this.initialized = !0;
                }
              }
            }),
            dw(this, "set", async (e, t, r) => {
              this.isInitialized();
              let i = ck(t),
                s = this.messages.get(e);
              if ((typeof s > "u" && (s = {}), "u" > typeof s[i])) return i;
              if (((s[i] = t), this.messages.set(e, s), r === l6.inbound)) {
                let r = this.messagesWithoutClientAck.get(e) || {};
                this.messagesWithoutClientAck.set(e, db(dy({}, r), { [i]: t }));
              }
              return await this.persist(), i;
            }),
            dw(this, "get", (e) => {
              this.isInitialized();
              let t = this.messages.get(e);
              return typeof t > "u" && (t = {}), t;
            }),
            dw(this, "getWithoutAck", (e) => {
              this.isInitialized();
              let t = {};
              for (let r of e) {
                let e = this.messagesWithoutClientAck.get(r) || {};
                t[r] = Object.values(e);
              }
              return t;
            }),
            dw(
              this,
              "has",
              (e, t) => (this.isInitialized(), "u" > typeof this.get(e)[ck(t)])
            ),
            dw(this, "ack", async (e, t) => {
              this.isInitialized();
              let r = this.messagesWithoutClientAck.get(e);
              if (typeof r > "u") return;
              let i = ck(t);
              delete r[i],
                0 === Object.keys(r).length
                  ? this.messagesWithoutClientAck.delete(e)
                  : this.messagesWithoutClientAck.set(e, r),
                await this.persist();
            }),
            dw(this, "del", async (e) => {
              this.isInitialized(),
                this.messages.delete(e),
                this.messagesWithoutClientAck.delete(e),
                await this.persist();
            }),
            (this.logger = (0, ee.U5)(e, this.name)),
            (this.core = t);
        }
        get context() {
          return (0, ee.oI)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        get storageKeyWithoutClientAck() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name +
            "_withoutClientAck"
          );
        }
        async setRelayerMessages(e) {
          await this.core.storage.setItem(this.storageKey, nN(e));
        }
        async setRelayerMessagesWithoutClientAck(e) {
          await this.core.storage.setItem(
            this.storageKeyWithoutClientAck,
            nN(e)
          );
        }
        async getRelayerMessages() {
          let e = await this.core.storage.getItem(this.storageKey);
          return "u" > typeof e ? nT(e) : void 0;
        }
        async getRelayerMessagesWithoutClientAck() {
          let e = await this.core.storage.getItem(
            this.storageKeyWithoutClientAck
          );
          return "u" > typeof e ? nT(e) : void 0;
        }
        async persist() {
          await this.setRelayerMessages(this.messages),
            await this.setRelayerMessagesWithoutClientAck(
              this.messagesWithoutClientAck
            );
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = c9("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var dE = Object.defineProperty,
        d_ = Object.defineProperties,
        dC = Object.getOwnPropertyDescriptors,
        dA = Object.getOwnPropertySymbols,
        dI = Object.prototype.hasOwnProperty,
        dS = Object.prototype.propertyIsEnumerable,
        dN = (e, t, r) =>
          t in e
            ? dE(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        dT = (e, t) => {
          for (var r in t || (t = {})) dI.call(t, r) && dN(e, r, t[r]);
          if (dA) for (var r of dA(t)) dS.call(t, r) && dN(e, r, t[r]);
          return e;
        },
        dO = (e, t) => d_(e, dC(t)),
        dx = (e, t, r) => dN(e, "symbol" != typeof t ? t + "" : t, r);
      class dP extends eu {
        constructor(e, t) {
          super(e, t),
            (this.relayer = e),
            (this.logger = t),
            dx(this, "events", new b.EventEmitter()),
            dx(this, "name", "publisher"),
            dx(this, "queue", new Map()),
            dx(this, "publishTimeout", (0, v.toMiliseconds)(v.ONE_MINUTE)),
            dx(
              this,
              "initialPublishTimeout",
              (0, v.toMiliseconds)(15 * v.ONE_SECOND)
            ),
            dx(this, "needsTransportRestart", !1),
            dx(this, "publish", async (e, t, r) => {
              var i;
              this.logger.debug("Publishing Payload"),
                this.logger.trace({
                  type: "method",
                  method: "publish",
                  params: { topic: e, message: t, opts: r },
                });
              let s = r?.ttl || l0,
                n = cF(r),
                a = r?.prompt || !1,
                o = r?.tag || 0,
                c = r?.id || lS().toString(),
                l = {
                  topic: e,
                  message: t,
                  opts: {
                    ttl: s,
                    relay: n,
                    prompt: a,
                    tag: o,
                    id: c,
                    attestation: r?.attestation,
                    tvf: r?.tvf,
                  },
                },
                u = `Failed to publish payload, please try again. id:${c} tag:${o}`;
              try {
                let i = new Promise(async (i) => {
                  let n = ({ id: e }) => {
                    l.opts.id === e &&
                      (this.removeRequestFromQueue(e),
                      this.relayer.events.removeListener(l2.publish, n),
                      i(l));
                  };
                  this.relayer.events.on(l2.publish, n);
                  let u = nx(
                    new Promise((i, n) => {
                      this.rpcPublish({
                        topic: e,
                        message: t,
                        ttl: s,
                        prompt: a,
                        tag: o,
                        id: c,
                        attestation: r?.attestation,
                        tvf: r?.tvf,
                      })
                        .then(i)
                        .catch((e) => {
                          this.logger.warn(e, e?.message), n(e);
                        });
                    }),
                    this.initialPublishTimeout,
                    `Failed initial publish, retrying.... id:${c} tag:${o}`
                  );
                  try {
                    await u, this.events.removeListener(l2.publish, n);
                  } catch (e) {
                    this.queue.set(c, dO(dT({}, l), { attempt: 1 })),
                      this.logger.warn(e, e?.message);
                  }
                });
                this.logger.trace({
                  type: "method",
                  method: "publish",
                  params: { id: c, topic: e, message: t, opts: r },
                }),
                  await nx(i, this.publishTimeout, u);
              } catch (e) {
                if (
                  (this.logger.debug("Failed to Publish Payload"),
                  this.logger.error(e),
                  null != (i = r?.internal) && i.throwOnFailedPublish)
                )
                  throw e;
              } finally {
                this.queue.delete(c);
              }
            }),
            dx(this, "on", (e, t) => {
              this.events.on(e, t);
            }),
            dx(this, "once", (e, t) => {
              this.events.once(e, t);
            }),
            dx(this, "off", (e, t) => {
              this.events.off(e, t);
            }),
            dx(this, "removeListener", (e, t) => {
              this.events.removeListener(e, t);
            }),
            (this.relayer = e),
            (this.logger = (0, ee.U5)(t, this.name)),
            this.registerEventListeners();
        }
        get context() {
          return (0, ee.oI)(this.logger);
        }
        async rpcPublish(e) {
          var t, r, i, s;
          let {
              topic: n,
              message: a,
              ttl: o = l0,
              prompt: c,
              tag: l,
              id: u,
              attestation: d,
              tvf: h,
            } = e,
            p = {
              method: cW(cF().protocol).publish,
              params: dT(
                {
                  topic: n,
                  message: a,
                  ttl: o,
                  prompt: c,
                  tag: l,
                  attestation: d,
                },
                h
              ),
              id: u,
            };
          lr(null == (t = p.params) ? void 0 : t.prompt) &&
            (null == (r = p.params) || delete r.prompt),
            lr(null == (i = p.params) ? void 0 : i.tag) &&
              (null == (s = p.params) || delete s.tag),
            this.logger.debug("Outgoing Relay Payload"),
            this.logger.trace({
              type: "message",
              direction: "outgoing",
              request: p,
            });
          let f = await this.relayer.request(p);
          return (
            this.relayer.events.emit(l2.publish, e),
            this.logger.debug("Successfully Published Payload"),
            f
          );
        }
        removeRequestFromQueue(e) {
          this.queue.delete(e);
        }
        checkQueue() {
          this.queue.forEach(async (e, t) => {
            let r = e.attempt + 1;
            this.queue.set(t, dO(dT({}, e), { attempt: r }));
            let { topic: i, message: s, opts: n, attestation: a } = e;
            this.logger.warn(
              {},
              `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${r}`
            ),
              await this.rpcPublish(
                dO(dT({}, e), {
                  topic: i,
                  message: s,
                  ttl: n.ttl,
                  prompt: n.prompt,
                  tag: n.tag,
                  id: n.id,
                  attestation: a,
                  tvf: n.tvf,
                })
              ),
              this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
          });
        }
        registerEventListeners() {
          this.relayer.core.heartbeat.on(A.pulse, () => {
            if (this.needsTransportRestart) {
              (this.needsTransportRestart = !1),
                this.relayer.events.emit(l2.connection_stalled);
              return;
            }
            this.checkQueue();
          }),
            this.relayer.on(l2.message_ack, (e) => {
              this.removeRequestFromQueue(e.id.toString());
            });
        }
      }
      var dR = Object.defineProperty,
        dk = (e, t, r) =>
          t in e
            ? dR(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        dD = (e, t, r) => dk(e, "symbol" != typeof t ? t + "" : t, r);
      class dU {
        constructor() {
          dD(this, "map", new Map()),
            dD(this, "set", (e, t) => {
              let r = this.get(e);
              this.exists(e, t) || this.map.set(e, [...r, t]);
            }),
            dD(this, "get", (e) => this.map.get(e) || []),
            dD(this, "exists", (e, t) => this.get(e).includes(t)),
            dD(this, "delete", (e, t) => {
              if (typeof t > "u") return void this.map.delete(e);
              if (!this.map.has(e)) return;
              let r = this.get(e);
              if (!this.exists(e, t)) return;
              let i = r.filter((e) => e !== t);
              if (!i.length) return void this.map.delete(e);
              this.map.set(e, i);
            }),
            dD(this, "clear", () => {
              this.map.clear();
            });
        }
        get topics() {
          return Array.from(this.map.keys());
        }
      }
      var dL = Object.defineProperty,
        dM = Object.defineProperties,
        dj = Object.getOwnPropertyDescriptors,
        d$ = Object.getOwnPropertySymbols,
        dB = Object.prototype.hasOwnProperty,
        dF = Object.prototype.propertyIsEnumerable,
        dW = (e, t, r) =>
          t in e
            ? dL(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        dq = (e, t) => {
          for (var r in t || (t = {})) dB.call(t, r) && dW(e, r, t[r]);
          if (d$) for (var r of d$(t)) dF.call(t, r) && dW(e, r, t[r]);
          return e;
        },
        dH = (e, t) => dM(e, dj(t)),
        dz = (e, t, r) => dW(e, "symbol" != typeof t ? t + "" : t, r);
      class dV extends ef {
        constructor(e, t) {
          super(e, t),
            (this.relayer = e),
            (this.logger = t),
            dz(this, "subscriptions", new Map()),
            dz(this, "topicMap", new dU()),
            dz(this, "events", new b.EventEmitter()),
            dz(this, "name", "subscription"),
            dz(this, "version", "0.3"),
            dz(this, "pending", new Map()),
            dz(this, "cached", []),
            dz(this, "initialized", !1),
            dz(this, "storagePrefix", lY),
            dz(this, "subscribeTimeout", (0, v.toMiliseconds)(v.ONE_MINUTE)),
            dz(
              this,
              "initialSubscribeTimeout",
              (0, v.toMiliseconds)(15 * v.ONE_SECOND)
            ),
            dz(this, "clientId"),
            dz(this, "batchSubscribeTopicsLimit", 500),
            dz(this, "init", async () => {
              this.initialized ||
                (this.logger.trace("Initialized"),
                this.registerEventListeners(),
                await this.restore()),
                (this.initialized = !0);
            }),
            dz(this, "subscribe", async (e, t) => {
              this.isInitialized(),
                this.logger.debug("Subscribing Topic"),
                this.logger.trace({
                  type: "method",
                  method: "subscribe",
                  params: { topic: e, opts: t },
                });
              try {
                let r = cF(t),
                  i = { topic: e, relay: r, transportType: t?.transportType };
                this.pending.set(e, i);
                let s = await this.rpcSubscribe(e, r, t);
                return (
                  "string" == typeof s &&
                    (this.onSubscribe(s, i),
                    this.logger.debug("Successfully Subscribed Topic"),
                    this.logger.trace({
                      type: "method",
                      method: "subscribe",
                      params: { topic: e, opts: t },
                    })),
                  s
                );
              } catch (e) {
                throw (
                  (this.logger.debug("Failed to Subscribe Topic"),
                  this.logger.error(e),
                  e)
                );
              }
            }),
            dz(this, "unsubscribe", async (e, t) => {
              this.isInitialized(),
                "u" > typeof t?.id
                  ? await this.unsubscribeById(e, t.id, t)
                  : await this.unsubscribeByTopic(e, t);
            }),
            dz(
              this,
              "isSubscribed",
              (e) =>
                new Promise((t) => {
                  t(this.topicMap.topics.includes(e));
                })
            ),
            dz(
              this,
              "isKnownTopic",
              (e) =>
                new Promise((t) => {
                  t(
                    this.topicMap.topics.includes(e) ||
                      this.pending.has(e) ||
                      this.cached.some((t) => t.topic === e)
                  );
                })
            ),
            dz(this, "on", (e, t) => {
              this.events.on(e, t);
            }),
            dz(this, "once", (e, t) => {
              this.events.once(e, t);
            }),
            dz(this, "off", (e, t) => {
              this.events.off(e, t);
            }),
            dz(this, "removeListener", (e, t) => {
              this.events.removeListener(e, t);
            }),
            dz(this, "start", async () => {
              await this.onConnect();
            }),
            dz(this, "stop", async () => {
              await this.onDisconnect();
            }),
            dz(this, "restart", async () => {
              await this.restore(), await this.onRestart();
            }),
            dz(this, "checkPending", async () => {
              if (
                0 === this.pending.size &&
                (!this.initialized || !this.relayer.connected)
              )
                return;
              let e = [];
              this.pending.forEach((t) => {
                e.push(t);
              }),
                await this.batchSubscribe(e);
            }),
            dz(this, "registerEventListeners", () => {
              this.relayer.core.heartbeat.on(A.pulse, async () => {
                await this.checkPending();
              }),
                this.events.on(l9.created, async (e) => {
                  let t = l9.created;
                  this.logger.info(`Emitting ${t}`),
                    this.logger.debug({ type: "event", event: t, data: e }),
                    await this.persist();
                }),
                this.events.on(l9.deleted, async (e) => {
                  let t = l9.deleted;
                  this.logger.info(`Emitting ${t}`),
                    this.logger.debug({ type: "event", event: t, data: e }),
                    await this.persist();
                });
            }),
            (this.relayer = e),
            (this.logger = (0, ee.U5)(t, this.name)),
            (this.clientId = "");
        }
        get context() {
          return (0, ee.oI)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.relayer.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        get length() {
          return this.subscriptions.size;
        }
        get ids() {
          return Array.from(this.subscriptions.keys());
        }
        get values() {
          return Array.from(this.subscriptions.values());
        }
        get topics() {
          return this.topicMap.topics;
        }
        get hasAnyTopics() {
          return (
            this.topicMap.topics.length > 0 ||
            this.pending.size > 0 ||
            this.cached.length > 0 ||
            this.subscriptions.size > 0
          );
        }
        hasSubscription(e, t) {
          let r = !1;
          try {
            r = this.getSubscription(e).topic === t;
          } catch {}
          return r;
        }
        reset() {
          (this.cached = []), (this.initialized = !0);
        }
        onDisable() {
          this.values.length > 0 && (this.cached = this.values),
            this.subscriptions.clear(),
            this.topicMap.clear();
        }
        async unsubscribeByTopic(e, t) {
          let r = this.topicMap.get(e);
          await Promise.all(
            r.map(async (r) => await this.unsubscribeById(e, r, t))
          );
        }
        async unsubscribeById(e, t, r) {
          this.logger.debug("Unsubscribing Topic"),
            this.logger.trace({
              type: "method",
              method: "unsubscribe",
              params: { topic: e, id: t, opts: r },
            });
          try {
            let i = cF(r);
            await this.restartToComplete({ topic: e, id: t, relay: i }),
              await this.rpcUnsubscribe(e, t, i);
            let s = c7("USER_DISCONNECTED", `${this.name}, ${e}`);
            await this.onUnsubscribe(e, t, s),
              this.logger.debug("Successfully Unsubscribed Topic"),
              this.logger.trace({
                type: "method",
                method: "unsubscribe",
                params: { topic: e, id: t, opts: r },
              });
          } catch (e) {
            throw (
              (this.logger.debug("Failed to Unsubscribe Topic"),
              this.logger.error(e),
              e)
            );
          }
        }
        async rpcSubscribe(e, t, r) {
          var i;
          (r && r?.transportType !== l8.relay) ||
            (await this.restartToComplete({ topic: e, id: e, relay: t }));
          let s = { method: cW(t.protocol).subscribe, params: { topic: e } };
          this.logger.debug("Outgoing Relay Payload"),
            this.logger.trace({
              type: "payload",
              direction: "outgoing",
              request: s,
            });
          let n = null == (i = r?.internal) ? void 0 : i.throwOnFailedPublish;
          try {
            let t = await this.getSubscriptionId(e);
            if (r?.transportType === l8.link_mode)
              return (
                setTimeout(() => {
                  (this.relayer.connected || this.relayer.connecting) &&
                    this.relayer.request(s).catch((e) => this.logger.warn(e));
                }, (0, v.toMiliseconds)(v.ONE_SECOND)),
                t
              );
            let i = new Promise(async (t) => {
                let r = (i) => {
                  i.topic === e &&
                    (this.events.removeListener(l9.created, r), t(i.id));
                };
                this.events.on(l9.created, r);
                try {
                  let i = await nx(
                    new Promise((e, t) => {
                      this.relayer
                        .request(s)
                        .catch((e) => {
                          this.logger.warn(e, e?.message), t(e);
                        })
                        .then(e);
                    }),
                    this.initialSubscribeTimeout,
                    `Subscribing to ${e} failed, please try again`
                  );
                  this.events.removeListener(l9.created, r), t(i);
                } catch {}
              }),
              a = await nx(
                i,
                this.subscribeTimeout,
                `Subscribing to ${e} failed, please try again`
              );
            if (!a && n)
              throw Error(`Subscribing to ${e} failed, please try again`);
            return a ? t : null;
          } catch (e) {
            if (
              (this.logger.debug("Outgoing Relay Subscribe Payload stalled"),
              this.relayer.events.emit(l2.connection_stalled),
              n)
            )
              throw e;
          }
          return null;
        }
        async rpcBatchSubscribe(e) {
          if (!e.length) return;
          let t = {
            method: cW(e[0].relay.protocol).batchSubscribe,
            params: { topics: e.map((e) => e.topic) },
          };
          this.logger.debug("Outgoing Relay Payload"),
            this.logger.trace({
              type: "payload",
              direction: "outgoing",
              request: t,
            });
          try {
            await await nx(
              new Promise((e) => {
                this.relayer
                  .request(t)
                  .catch((e) => this.logger.warn(e))
                  .then(e);
              }),
              this.subscribeTimeout,
              "rpcBatchSubscribe failed, please try again"
            );
          } catch {
            this.relayer.events.emit(l2.connection_stalled);
          }
        }
        async rpcBatchFetchMessages(e) {
          let t;
          if (!e.length) return;
          let r = {
            method: cW(e[0].relay.protocol).batchFetchMessages,
            params: { topics: e.map((e) => e.topic) },
          };
          this.logger.debug("Outgoing Relay Payload"),
            this.logger.trace({
              type: "payload",
              direction: "outgoing",
              request: r,
            });
          try {
            t = await await nx(
              new Promise((e, t) => {
                this.relayer
                  .request(r)
                  .catch((e) => {
                    this.logger.warn(e), t(e);
                  })
                  .then(e);
              }),
              this.subscribeTimeout,
              "rpcBatchFetchMessages failed, please try again"
            );
          } catch {
            this.relayer.events.emit(l2.connection_stalled);
          }
          return t;
        }
        rpcUnsubscribe(e, t, r) {
          let i = {
            method: cW(r.protocol).unsubscribe,
            params: { topic: e, id: t },
          };
          return (
            this.logger.debug("Outgoing Relay Payload"),
            this.logger.trace({
              type: "payload",
              direction: "outgoing",
              request: i,
            }),
            this.relayer.request(i)
          );
        }
        onSubscribe(e, t) {
          this.setSubscription(e, dH(dq({}, t), { id: e })),
            this.pending.delete(t.topic);
        }
        onBatchSubscribe(e) {
          e.length &&
            e.forEach((e) => {
              this.setSubscription(e.id, dq({}, e)),
                this.pending.delete(e.topic);
            });
        }
        async onUnsubscribe(e, t, r) {
          this.events.removeAllListeners(t),
            this.hasSubscription(t, e) && this.deleteSubscription(t, r),
            await this.relayer.messages.del(e);
        }
        async setRelayerSubscriptions(e) {
          await this.relayer.core.storage.setItem(this.storageKey, e);
        }
        async getRelayerSubscriptions() {
          return await this.relayer.core.storage.getItem(this.storageKey);
        }
        setSubscription(e, t) {
          this.logger.debug("Setting subscription"),
            this.logger.trace({
              type: "method",
              method: "setSubscription",
              id: e,
              subscription: t,
            }),
            this.addSubscription(e, t);
        }
        addSubscription(e, t) {
          this.subscriptions.set(e, dq({}, t)),
            this.topicMap.set(t.topic, e),
            this.events.emit(l9.created, t);
        }
        getSubscription(e) {
          this.logger.debug("Getting subscription"),
            this.logger.trace({
              type: "method",
              method: "getSubscription",
              id: e,
            });
          let t = this.subscriptions.get(e);
          if (!t) {
            let { message: t } = c9("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw Error(t);
          }
          return t;
        }
        deleteSubscription(e, t) {
          this.logger.debug("Deleting subscription"),
            this.logger.trace({
              type: "method",
              method: "deleteSubscription",
              id: e,
              reason: t,
            });
          let r = this.getSubscription(e);
          this.subscriptions.delete(e),
            this.topicMap.delete(r.topic, e),
            this.events.emit(l9.deleted, dH(dq({}, r), { reason: t }));
        }
        async persist() {
          await this.setRelayerSubscriptions(this.values),
            this.events.emit(l9.sync);
        }
        async onRestart() {
          if (this.cached.length) {
            let e = [...this.cached],
              t = Math.ceil(
                this.cached.length / this.batchSubscribeTopicsLimit
              );
            for (let r = 0; r < t; r++) {
              let t = e.splice(0, this.batchSubscribeTopicsLimit);
              await this.batchSubscribe(t);
            }
          }
          this.events.emit(l9.resubscribed);
        }
        async restore() {
          try {
            let e = await this.getRelayerSubscriptions();
            if (typeof e > "u" || !e.length) return;
            if (this.subscriptions.size) {
              let { message: e } = c9("RESTORE_WILL_OVERRIDE", this.name);
              throw (
                (this.logger.error(e),
                this.logger.error(
                  `${this.name}: ${JSON.stringify(this.values)}`
                ),
                Error(e))
              );
            }
            (this.cached = e),
              this.logger.debug(
                `Successfully Restored subscriptions for ${this.name}`
              ),
              this.logger.trace({
                type: "method",
                method: "restore",
                subscriptions: this.values,
              });
          } catch (e) {
            this.logger.debug(
              `Failed to Restore subscriptions for ${this.name}`
            ),
              this.logger.error(e);
          }
        }
        async batchSubscribe(e) {
          e.length &&
            (await this.rpcBatchSubscribe(e),
            this.onBatchSubscribe(
              await Promise.all(
                e.map(async (e) =>
                  dH(dq({}, e), { id: await this.getSubscriptionId(e.topic) })
                )
              )
            ));
        }
        async batchFetchMessages(e) {
          var t;
          if (!e.length) return;
          this.logger.trace(
            `Fetching batch messages for ${e.length} subscriptions`
          );
          let r = await this.rpcBatchFetchMessages(e);
          r &&
            r.messages &&
            (await ((t = (0, v.toMiliseconds)(v.ONE_SECOND)),
            new Promise((e) => setTimeout(e, t))),
            await this.relayer.handleBatchMessageEvents(r.messages));
        }
        async onConnect() {
          await this.restart(), this.reset();
        }
        onDisconnect() {
          this.onDisable();
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = c9("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
        async restartToComplete(e) {
          this.relayer.connected ||
            this.relayer.connecting ||
            (this.cached.push(e), await this.relayer.transportOpen());
        }
        async getClientId() {
          return (
            this.clientId ||
              (this.clientId = await this.relayer.core.crypto.getClientId()),
            this.clientId
          );
        }
        async getSubscriptionId(e) {
          return ck(e + (await this.getClientId()));
        }
      }
      var dK = Object.defineProperty,
        dG = Object.getOwnPropertySymbols,
        dY = Object.prototype.hasOwnProperty,
        dZ = Object.prototype.propertyIsEnumerable,
        dJ = (e, t, r) =>
          t in e
            ? dK(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        dX = (e, t) => {
          for (var r in t || (t = {})) dY.call(t, r) && dJ(e, r, t[r]);
          if (dG) for (var r of dG(t)) dZ.call(t, r) && dJ(e, r, t[r]);
          return e;
        },
        dQ = (e, t, r) => dJ(e, "symbol" != typeof t ? t + "" : t, r);
      class d0 extends ed {
        constructor(e) {
          super(e),
            dQ(this, "protocol", "wc"),
            dQ(this, "version", 2),
            dQ(this, "core"),
            dQ(this, "logger"),
            dQ(this, "events", new b.EventEmitter()),
            dQ(this, "provider"),
            dQ(this, "messages"),
            dQ(this, "subscriber"),
            dQ(this, "publisher"),
            dQ(this, "name", "relayer"),
            dQ(this, "transportExplicitlyClosed", !1),
            dQ(this, "initialized", !1),
            dQ(this, "connectionAttemptInProgress", !1),
            dQ(this, "relayUrl"),
            dQ(this, "projectId"),
            dQ(this, "packageName"),
            dQ(this, "bundleId"),
            dQ(this, "hasExperiencedNetworkDisruption", !1),
            dQ(this, "pingTimeout"),
            dQ(
              this,
              "heartBeatTimeout",
              (0, v.toMiliseconds)(v.THIRTY_SECONDS + v.FIVE_SECONDS)
            ),
            dQ(this, "reconnectTimeout"),
            dQ(this, "connectPromise"),
            dQ(this, "reconnectInProgress", !1),
            dQ(this, "requestsInFlight", []),
            dQ(this, "connectTimeout", (0, v.toMiliseconds)(15 * v.ONE_SECOND)),
            dQ(this, "request", async (e) => {
              var t, r;
              this.logger.debug("Publishing Request Payload");
              let i = e.id || lS().toString();
              await this.toEstablishConnection();
              try {
                this.logger.trace(
                  {
                    id: i,
                    method: e.method,
                    topic: null == (t = e.params) ? void 0 : t.topic,
                  },
                  "relayer.request - publishing..."
                );
                let s = `${i}:${
                  (null == (r = e.params) ? void 0 : r.tag) || ""
                }`;
                this.requestsInFlight.push(s);
                let n = await this.provider.request(e);
                return (
                  (this.requestsInFlight = this.requestsInFlight.filter(
                    (e) => e !== s
                  )),
                  n
                );
              } catch (e) {
                throw (this.logger.debug(`Failed to Publish Request: ${i}`), e);
              }
            }),
            dQ(this, "resetPingTimeout", () => {
              nw() &&
                (clearTimeout(this.pingTimeout),
                (this.pingTimeout = setTimeout(() => {
                  var e, t, r, i;
                  try {
                    this.logger.debug(
                      {},
                      "pingTimeout: Connection stalled, terminating..."
                    ),
                      null ==
                        (i =
                          null ==
                          (r =
                            null ==
                            (t =
                              null == (e = this.provider)
                                ? void 0
                                : e.connection)
                              ? void 0
                              : t.socket)
                            ? void 0
                            : r.terminate) || i.call(r);
                  } catch (e) {
                    this.logger.warn(e, e?.message);
                  }
                }, this.heartBeatTimeout)));
            }),
            dQ(this, "onPayloadHandler", (e) => {
              this.onProviderPayload(e), this.resetPingTimeout();
            }),
            dQ(this, "onConnectHandler", () => {
              this.logger.warn({}, "Relayer connected \uD83D\uDEDC"),
                this.startPingTimeout(),
                this.events.emit(l2.connect);
            }),
            dQ(this, "onDisconnectHandler", () => {
              this.logger.warn({}, "Relayer disconnected \uD83D\uDED1"),
                (this.requestsInFlight = []),
                this.onProviderDisconnect();
            }),
            dQ(this, "onProviderErrorHandler", (e) => {
              this.logger.fatal(`Fatal socket error: ${e.message}`),
                this.events.emit(l2.error, e),
                this.logger.fatal(
                  "Fatal socket error received, closing transport"
                ),
                this.transportClose();
            }),
            dQ(this, "registerProviderListeners", () => {
              this.provider.on(l3.payload, this.onPayloadHandler),
                this.provider.on(l3.connect, this.onConnectHandler),
                this.provider.on(l3.disconnect, this.onDisconnectHandler),
                this.provider.on(l3.error, this.onProviderErrorHandler);
            }),
            (this.core = e.core),
            (this.logger =
              "u" > typeof e.logger && "string" != typeof e.logger
                ? (0, ee.U5)(e.logger, this.name)
                : (0, ee.h6)((0, ee.iP)({ level: e.logger || "error" }))),
            (this.messages = new dv(this.logger, e.core)),
            (this.subscriber = new dV(this, this.logger)),
            (this.publisher = new dP(this, this.logger)),
            (this.relayUrl = e?.relayUrl || l1),
            (this.projectId = e.projectId),
            nv() &&
            "u" > typeof r.g &&
            "u" > typeof (null == r.g ? void 0 : r.g.Platform) &&
            (null == r.g ? void 0 : r.g.Platform.OS) === "android"
              ? (this.packageName = nC())
              : nv() &&
                "u" > typeof r.g &&
                "u" > typeof (null == r.g ? void 0 : r.g.Platform) &&
                (null == r.g ? void 0 : r.g.Platform.OS) === "ios" &&
                (this.bundleId = nC()),
            (this.provider = {});
        }
        async init() {
          if (
            (this.logger.trace("Initialized"),
            this.registerEventListeners(),
            await Promise.all([this.messages.init(), this.subscriber.init()]),
            (this.initialized = !0),
            this.subscriber.hasAnyTopics)
          )
            try {
              await this.transportOpen();
            } catch (e) {
              this.logger.warn(e, e?.message);
            }
        }
        get context() {
          return (0, ee.oI)(this.logger);
        }
        get connected() {
          var e, t, r;
          return (
            (null ==
            (r =
              null == (t = null == (e = this.provider) ? void 0 : e.connection)
                ? void 0
                : t.socket)
              ? void 0
              : r.readyState) === 1
          );
        }
        get connecting() {
          var e, t, r;
          return (
            (null ==
            (r =
              null == (t = null == (e = this.provider) ? void 0 : e.connection)
                ? void 0
                : t.socket)
              ? void 0
              : r.readyState) === 0 || void 0 !== this.connectPromise
          );
        }
        async publish(e, t, r) {
          this.isInitialized(),
            await this.publisher.publish(e, t, r),
            await this.recordMessageEvent(
              {
                topic: e,
                message: t,
                publishedAt: Date.now(),
                transportType: l8.relay,
              },
              l6.outbound
            );
        }
        async subscribe(e, t) {
          var r, i, s;
          this.isInitialized(),
            (null != t && t.transportType && t?.transportType !== "relay") ||
              (await this.toEstablishConnection());
          let n =
              typeof (null == (r = t?.internal)
                ? void 0
                : r.throwOnFailedPublish) > "u" ||
              (null == (i = t?.internal) ? void 0 : i.throwOnFailedPublish),
            a =
              (null == (s = this.subscriber.topicMap.get(e)) ? void 0 : s[0]) ||
              "",
            o,
            c = (t) => {
              t.topic === e && (this.subscriber.off(l9.created, c), o());
            };
          return (
            await Promise.all([
              new Promise((e) => {
                (o = e), this.subscriber.on(l9.created, c);
              }),
              new Promise(async (r, i) => {
                (a =
                  (await this.subscriber
                    .subscribe(
                      e,
                      dX({ internal: { throwOnFailedPublish: n } }, t)
                    )
                    .catch((e) => {
                      n && i(e);
                    })) || a),
                  r();
              }),
            ]),
            a
          );
        }
        async unsubscribe(e, t) {
          this.isInitialized(), await this.subscriber.unsubscribe(e, t);
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async transportDisconnect() {
          this.provider.disconnect &&
          (this.hasExperiencedNetworkDisruption || this.connected)
            ? await nx(
                this.provider.disconnect(),
                2e3,
                "provider.disconnect()"
              ).catch(() => this.onProviderDisconnect())
            : this.onProviderDisconnect();
        }
        async transportClose() {
          (this.transportExplicitlyClosed = !0),
            await this.transportDisconnect();
        }
        async transportOpen(e) {
          if (!this.subscriber.hasAnyTopics)
            return void this.logger.warn(
              "Starting WS connection skipped because the client has no topics to work with."
            );
          if (
            (this.connectPromise
              ? (this.logger.debug(
                  {},
                  "Waiting for existing connection attempt to resolve..."
                ),
                await this.connectPromise,
                this.logger.debug({}, "Existing connection attempt resolved"))
              : ((this.connectPromise = new Promise(async (t, r) => {
                  await this.connect(e)
                    .then(t)
                    .catch(r)
                    .finally(() => {
                      this.connectPromise = void 0;
                    });
                })),
                await this.connectPromise),
            !this.connected)
          )
            throw Error(
              `Couldn't establish socket connection to the relay server: ${this.relayUrl}`
            );
        }
        async restartTransport(e) {
          this.logger.debug({}, "Restarting transport..."),
            this.connectionAttemptInProgress ||
              ((this.relayUrl = e || this.relayUrl),
              await this.confirmOnlineStateOrThrow(),
              await this.transportClose(),
              await this.transportOpen());
        }
        async confirmOnlineStateOrThrow() {
          if (!(await lf()))
            throw Error(
              "No internet connection detected. Please restart your network and try again."
            );
        }
        async handleBatchMessageEvents(e) {
          if (e?.length === 0)
            return void this.logger.trace(
              "Batch message events is empty. Ignoring..."
            );
          let t = e.sort((e, t) => e.publishedAt - t.publishedAt);
          for (let e of (this.logger.debug(
            `Batch of ${t.length} message events sorted`
          ),
          t))
            try {
              await this.onMessageEvent(e);
            } catch (e) {
              this.logger.warn(
                e,
                "Error while processing batch message event: " + e?.message
              );
            }
          this.logger.trace(`Batch of ${t.length} message events processed`);
        }
        async onLinkMessageEvent(e, t) {
          let { topic: r } = e;
          if (!t.sessionExists) {
            let e = nk(v.FIVE_MINUTES);
            await this.core.pairing.pairings.set(r, {
              topic: r,
              expiry: e,
              relay: { protocol: "irn" },
              active: !1,
            });
          }
          this.events.emit(l2.message, e),
            await this.recordMessageEvent(e, l6.inbound);
        }
        async connect(e) {
          await this.confirmOnlineStateOrThrow(),
            e &&
              e !== this.relayUrl &&
              ((this.relayUrl = e), await this.transportDisconnect()),
            (this.connectionAttemptInProgress = !0),
            (this.transportExplicitlyClosed = !1);
          let t = 1;
          for (; t < 6; ) {
            try {
              if (this.transportExplicitlyClosed) break;
              this.logger.debug(
                {},
                `Connecting to ${this.relayUrl}, attempt: ${t}...`
              ),
                await this.createProvider(),
                await new Promise(async (e, t) => {
                  let r = () => {
                    t(
                      Error("Connection interrupted while trying to subscribe")
                    );
                  };
                  this.provider.once(l3.disconnect, r),
                    await nx(
                      new Promise((e, t) => {
                        this.provider.connect().then(e).catch(t);
                      }),
                      this.connectTimeout,
                      `Socket stalled when trying to connect to ${this.relayUrl}`
                    )
                      .catch((e) => {
                        t(e);
                      })
                      .finally(() => {
                        this.provider.off(l3.disconnect, r),
                          clearTimeout(this.reconnectTimeout);
                      }),
                    await new Promise(async (e, t) => {
                      let r = () => {
                        t(
                          Error(
                            "Connection interrupted while trying to subscribe"
                          )
                        );
                      };
                      this.provider.once(l3.disconnect, r),
                        await this.subscriber
                          .start()
                          .then(e)
                          .catch(t)
                          .finally(() => {
                            this.provider.off(l3.disconnect, r);
                          });
                    }),
                    (this.hasExperiencedNetworkDisruption = !1),
                    e();
                });
            } catch (e) {
              await this.subscriber.stop(),
                this.logger.warn({}, e.message),
                (this.hasExperiencedNetworkDisruption = !0);
            } finally {
              this.connectionAttemptInProgress = !1;
            }
            if (this.connected) {
              this.logger.debug(
                {},
                `Connected to ${this.relayUrl} successfully on attempt: ${t}`
              );
              break;
            }
            await new Promise((e) => setTimeout(e, (0, v.toMiliseconds)(+t))),
              t++;
          }
        }
        startPingTimeout() {
          var e, t, r, i, s;
          if (nw())
            try {
              null !=
                (t = null == (e = this.provider) ? void 0 : e.connection) &&
                t.socket &&
                (null ==
                  (s =
                    null ==
                    (i = null == (r = this.provider) ? void 0 : r.connection)
                      ? void 0
                      : i.socket) ||
                  s.on("ping", () => {
                    this.resetPingTimeout();
                  })),
                this.resetPingTimeout();
            } catch (e) {
              this.logger.warn(e, e?.message);
            }
        }
        async createProvider() {
          this.provider.connection && this.unregisterProviderListeners();
          let e = await this.core.crypto.signJWT(this.relayUrl);
          (this.provider = new lF(
            new lz(
              (function ({
                protocol: e,
                version: t,
                relayUrl: r,
                sdkVersion: i,
                auth: s,
                projectId: n,
                useOnCloseEvent: a,
                bundleId: o,
                packageName: c,
              }) {
                let l = r.split("?"),
                  u = nI(e, t, i),
                  d = (function (e, t) {
                    let r = new URLSearchParams(e);
                    for (let e of Object.keys(t).sort())
                      if (t.hasOwnProperty(e)) {
                        let i = t[e];
                        void 0 !== i && r.set(e, i);
                      }
                    return r.toString();
                  })(l[1] || "", {
                    auth: s,
                    ua: u,
                    projectId: n,
                    useOnCloseEvent: a || void 0,
                    packageName: c || void 0,
                    bundleId: o || void 0,
                  });
                return l[0] + "?" + d;
              })({
                sdkVersion: l5,
                protocol: this.protocol,
                version: this.version,
                relayUrl: this.relayUrl,
                projectId: this.projectId,
                auth: e,
                useOnCloseEvent: !0,
                bundleId: this.bundleId,
                packageName: this.packageName,
              })
            )
          )),
            this.registerProviderListeners();
        }
        async recordMessageEvent(e, t) {
          let { topic: r, message: i } = e;
          await this.messages.set(r, i, t);
        }
        async shouldIgnoreMessageEvent(e) {
          let { topic: t, message: r } = e;
          if (!r || 0 === r.length)
            return this.logger.warn(`Ignoring invalid/empty message: ${r}`), !0;
          if (!(await this.subscriber.isKnownTopic(t)))
            return (
              this.logger.warn(`Ignoring message for unknown topic ${t}`), !0
            );
          let i = this.messages.has(t, r);
          return i && this.logger.warn(`Ignoring duplicate message: ${r}`), i;
        }
        async onProviderPayload(e) {
          if (
            (this.logger.debug("Incoming Relay Payload"),
            this.logger.trace({
              type: "payload",
              direction: "incoming",
              payload: e,
            }),
            lM(e))
          ) {
            if (!e.method.endsWith("_subscription")) return;
            let t = e.params,
              { topic: r, message: i, publishedAt: s, attestation: n } = t.data,
              a = {
                topic: r,
                message: i,
                publishedAt: s,
                transportType: l8.relay,
                attestation: n,
              };
            this.logger.debug("Emitting Relayer Payload"),
              this.logger.trace(dX({ type: "event", event: t.id }, a)),
              this.events.emit(t.id, a),
              await this.acknowledgePayload(e),
              await this.onMessageEvent(a);
          } else lj(e) && this.events.emit(l2.message_ack, e);
        }
        async onMessageEvent(e) {
          (await this.shouldIgnoreMessageEvent(e)) ||
            (await this.recordMessageEvent(e, l6.inbound),
            this.events.emit(l2.message, e));
        }
        async acknowledgePayload(e) {
          let t = lT(e.id, !0);
          await this.provider.connection.send(t);
        }
        unregisterProviderListeners() {
          this.provider.off(l3.payload, this.onPayloadHandler),
            this.provider.off(l3.connect, this.onConnectHandler),
            this.provider.off(l3.disconnect, this.onDisconnectHandler),
            this.provider.off(l3.error, this.onProviderErrorHandler),
            clearTimeout(this.pingTimeout);
        }
        async registerEventListeners() {
          let e = await lf();
          (function (e) {
            var t, i;
            switch (n_()) {
              case nb.browser:
                (t = e),
                  !nv() &&
                    nE() &&
                    (window.addEventListener("online", () => t(!0)),
                    window.addEventListener("offline", () => t(!1)));
                break;
              case nb.reactNative:
                (i = e),
                  nv() &&
                    "u" > typeof r.g &&
                    null != r.g &&
                    r.g.NetInfo &&
                    r.g?.NetInfo.addEventListener((e) => i(e?.isConnected));
              case nb.node:
            }
          })(async (t) => {
            e !== t &&
              ((e = t),
              t
                ? await this.transportOpen().catch((e) =>
                    this.logger.error(e, e?.message)
                  )
                : ((this.hasExperiencedNetworkDisruption = !0),
                  await this.transportDisconnect(),
                  (this.transportExplicitlyClosed = !1)));
          }),
            this.core.heartbeat.on(A.pulse, async () => {
              var e;
              if (
                !this.transportExplicitlyClosed &&
                !this.connected &&
                (!(nE() && (0, rY.getDocument)()) ||
                  (null == (e = (0, rY.getDocument)())
                    ? void 0
                    : e.visibilityState) === "visible")
              )
                try {
                  await this.confirmOnlineStateOrThrow(),
                    await this.transportOpen();
                } catch (e) {
                  this.logger.warn(e, e?.message);
                }
            });
        }
        async onProviderDisconnect() {
          clearTimeout(this.pingTimeout),
            this.events.emit(l2.disconnect),
            (this.connectionAttemptInProgress = !1),
            !this.reconnectInProgress &&
              ((this.reconnectInProgress = !0),
              await this.subscriber.stop(),
              this.subscriber.hasAnyTopics &&
                (this.transportExplicitlyClosed ||
                  (this.reconnectTimeout = setTimeout(async () => {
                    await this.transportOpen().catch((e) =>
                      this.logger.error(e, e?.message)
                    ),
                      (this.reconnectTimeout = void 0),
                      (this.reconnectInProgress = !1);
                  }, (0, v.toMiliseconds)(0.1)))));
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = c9("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
        async toEstablishConnection() {
          if ((await this.confirmOnlineStateOrThrow(), !this.connected)) {
            if (this.connectPromise) return void (await this.connectPromise);
            await this.connect();
          }
        }
      }
      function d1() {}
      function d2(e) {
        if (!e || "object" != typeof e) return !1;
        let t = Object.getPrototypeOf(e);
        return (
          (null === t ||
            t === Object.prototype ||
            null === Object.getPrototypeOf(t)) &&
          "[object Object]" === Object.prototype.toString.call(e)
        );
      }
      function d3(e) {
        return Object.getOwnPropertySymbols(e).filter((t) =>
          Object.prototype.propertyIsEnumerable.call(e, t)
        );
      }
      function d5(e) {
        return null == e
          ? void 0 === e
            ? "[object Undefined]"
            : "[object Null]"
          : Object.prototype.toString.call(e);
      }
      let d8 = "[object Arguments]",
        d6 = "[object Object]";
      var d4 = Object.defineProperty,
        d9 = Object.getOwnPropertySymbols,
        d7 = Object.prototype.hasOwnProperty,
        he = Object.prototype.propertyIsEnumerable,
        ht = (e, t, r) =>
          t in e
            ? d4(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        hr = (e, t) => {
          for (var r in t || (t = {})) d7.call(t, r) && ht(e, r, t[r]);
          if (d9) for (var r of d9(t)) he.call(t, r) && ht(e, r, t[r]);
          return e;
        },
        hi = (e, t, r) => ht(e, "symbol" != typeof t ? t + "" : t, r);
      class hs extends eh {
        constructor(e, t, r, i = lY, s) {
          super(e, t, r, i),
            (this.core = e),
            (this.logger = t),
            (this.name = r),
            hi(this, "map", new Map()),
            hi(this, "version", "0.3"),
            hi(this, "cached", []),
            hi(this, "initialized", !1),
            hi(this, "getKey"),
            hi(this, "storagePrefix", lY),
            hi(this, "recentlyDeleted", []),
            hi(this, "recentlyDeletedLimit", 200),
            hi(this, "init", async () => {
              this.initialized ||
                (this.logger.trace("Initialized"),
                await this.restore(),
                this.cached.forEach((e) => {
                  this.getKey && null !== e && !lr(e)
                    ? this.map.set(this.getKey(e), e)
                    : (function (e) {
                        var t;
                        return null == (t = e?.proposer) ? void 0 : t.publicKey;
                      })(e)
                    ? this.map.set(e.id, e)
                    : e?.topic && this.map.set(e.topic, e);
                }),
                (this.cached = []),
                (this.initialized = !0));
            }),
            hi(this, "set", async (e, t) => {
              this.isInitialized(),
                this.map.has(e)
                  ? await this.update(e, t)
                  : (this.logger.debug("Setting value"),
                    this.logger.trace({
                      type: "method",
                      method: "set",
                      key: e,
                      value: t,
                    }),
                    this.map.set(e, t),
                    await this.persist());
            }),
            hi(
              this,
              "get",
              (e) => (
                this.isInitialized(),
                this.logger.debug("Getting value"),
                this.logger.trace({ type: "method", method: "get", key: e }),
                this.getData(e)
              )
            ),
            hi(
              this,
              "getAll",
              (e) => (
                this.isInitialized(),
                e
                  ? this.values.filter((t) =>
                      Object.keys(e).every((r) => {
                        var i;
                        return (
                          (i = t[r]),
                          (function e(t, r, i, s, n, a, o) {
                            let c = o(t, r, i, s, n, a);
                            if (void 0 !== c) return c;
                            if (typeof t == typeof r)
                              switch (typeof t) {
                                case "bigint":
                                case "string":
                                case "boolean":
                                case "symbol":
                                case "undefined":
                                case "function":
                                  return t === r;
                                case "number":
                                  return t === r || Object.is(t, r);
                              }
                            return (function t(r, i, s, n) {
                              if (Object.is(r, i)) return !0;
                              let a = d5(r),
                                o = d5(i);
                              if (
                                (a === d8 && (a = d6),
                                o === d8 && (o = d6),
                                a !== o)
                              )
                                return !1;
                              switch (a) {
                                case "[object String]":
                                  return r.toString() === i.toString();
                                case "[object Number]": {
                                  let e = r.valueOf(),
                                    t = i.valueOf();
                                  return (
                                    e === t ||
                                    (Number.isNaN(e) && Number.isNaN(t))
                                  );
                                }
                                case "[object Boolean]":
                                case "[object Date]":
                                case "[object Symbol]":
                                  return Object.is(r.valueOf(), i.valueOf());
                                case "[object RegExp]":
                                  return (
                                    r.source === i.source && r.flags === i.flags
                                  );
                                case "[object Function]":
                                  return r === i;
                              }
                              let c = (s = s ?? new Map()).get(r),
                                l = s.get(i);
                              if (null != c && null != l) return c === i;
                              s.set(r, i), s.set(i, r);
                              try {
                                switch (a) {
                                  case "[object Map]":
                                    if (r.size !== i.size) return !1;
                                    for (let [t, a] of r.entries())
                                      if (
                                        !i.has(t) ||
                                        !e(a, i.get(t), t, r, i, s, n)
                                      )
                                        return !1;
                                    return !0;
                                  case "[object Set]": {
                                    if (r.size !== i.size) return !1;
                                    let t = Array.from(r.values()),
                                      a = Array.from(i.values());
                                    for (let o = 0; o < t.length; o++) {
                                      let c = t[o],
                                        l = a.findIndex((t) =>
                                          e(c, t, void 0, r, i, s, n)
                                        );
                                      if (-1 === l) return !1;
                                      a.splice(l, 1);
                                    }
                                    return !0;
                                  }
                                  case "[object Array]":
                                  case "[object Uint8Array]":
                                  case "[object Uint8ClampedArray]":
                                  case "[object Uint16Array]":
                                  case "[object Uint32Array]":
                                  case "[object BigUint64Array]":
                                  case "[object Int8Array]":
                                  case "[object Int16Array]":
                                  case "[object Int32Array]":
                                  case "[object BigInt64Array]":
                                  case "[object Float32Array]":
                                  case "[object Float64Array]":
                                    if (
                                      ("u" > typeof lV &&
                                        lV.isBuffer(r) !== lV.isBuffer(i)) ||
                                      r.length !== i.length
                                    )
                                      return !1;
                                    for (let t = 0; t < r.length; t++)
                                      if (!e(r[t], i[t], t, r, i, s, n))
                                        return !1;
                                    return !0;
                                  case "[object ArrayBuffer]":
                                    return (
                                      r.byteLength === i.byteLength &&
                                      t(
                                        new Uint8Array(r),
                                        new Uint8Array(i),
                                        s,
                                        n
                                      )
                                    );
                                  case "[object DataView]":
                                    return (
                                      r.byteLength === i.byteLength &&
                                      r.byteOffset === i.byteOffset &&
                                      t(
                                        new Uint8Array(r),
                                        new Uint8Array(i),
                                        s,
                                        n
                                      )
                                    );
                                  case "[object Error]":
                                    return (
                                      r.name === i.name &&
                                      r.message === i.message
                                    );
                                  case d6: {
                                    if (
                                      !(
                                        t(r.constructor, i.constructor, s, n) ||
                                        (d2(r) && d2(i))
                                      )
                                    )
                                      return !1;
                                    let a = [...Object.keys(r), ...d3(r)],
                                      o = [...Object.keys(i), ...d3(i)];
                                    if (a.length !== o.length) return !1;
                                    for (let t = 0; t < a.length; t++) {
                                      let o = a[t],
                                        c = r[o];
                                      if (!Object.hasOwn(i, o)) return !1;
                                      let l = i[o];
                                      if (!e(c, l, o, r, i, s, n)) return !1;
                                    }
                                    return !0;
                                  }
                                  default:
                                    return !1;
                                }
                              } finally {
                                s.delete(r), s.delete(i);
                              }
                            })(t, r, a, o);
                          })(i, e[r], void 0, void 0, void 0, void 0, d1)
                        );
                      })
                    )
                  : this.values
              )
            ),
            hi(this, "update", async (e, t) => {
              this.isInitialized(),
                this.logger.debug("Updating value"),
                this.logger.trace({
                  type: "method",
                  method: "update",
                  key: e,
                  update: t,
                });
              let r = hr(hr({}, this.getData(e)), t);
              this.map.set(e, r), await this.persist();
            }),
            hi(this, "delete", async (e, t) => {
              this.isInitialized(),
                this.map.has(e) &&
                  (this.logger.debug("Deleting value"),
                  this.logger.trace({
                    type: "method",
                    method: "delete",
                    key: e,
                    reason: t,
                  }),
                  this.map.delete(e),
                  this.addToRecentlyDeleted(e),
                  await this.persist());
            }),
            (this.logger = (0, ee.U5)(t, this.name)),
            (this.storagePrefix = i),
            (this.getKey = s);
        }
        get context() {
          return (0, ee.oI)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        get length() {
          return this.map.size;
        }
        get keys() {
          return Array.from(this.map.keys());
        }
        get values() {
          return Array.from(this.map.values());
        }
        addToRecentlyDeleted(e) {
          this.recentlyDeleted.push(e),
            this.recentlyDeleted.length >= this.recentlyDeletedLimit &&
              this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
        }
        async setDataStore(e) {
          await this.core.storage.setItem(this.storageKey, e);
        }
        async getDataStore() {
          return await this.core.storage.getItem(this.storageKey);
        }
        getData(e) {
          let t = this.map.get(e);
          if (!t) {
            if (this.recentlyDeleted.includes(e)) {
              let { message: t } = c9(
                "MISSING_OR_INVALID",
                `Record was recently deleted - ${this.name}: ${e}`
              );
              throw (this.logger.error(t), Error(t));
            }
            let { message: t } = c9("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw (this.logger.error(t), Error(t));
          }
          return t;
        }
        async persist() {
          await this.setDataStore(this.values);
        }
        async restore() {
          try {
            let e = await this.getDataStore();
            if (typeof e > "u" || !e.length) return;
            if (this.map.size) {
              let { message: e } = c9("RESTORE_WILL_OVERRIDE", this.name);
              throw (this.logger.error(e), Error(e));
            }
            (this.cached = e),
              this.logger.debug(`Successfully Restored value for ${this.name}`),
              this.logger.trace({
                type: "method",
                method: "restore",
                value: this.values,
              });
          } catch (e) {
            this.logger.debug(`Failed to Restore value for ${this.name}`),
              this.logger.error(e);
          }
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = c9("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var hn = Object.defineProperty,
        ha = (e, t, r) =>
          t in e
            ? hn(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        ho = (e, t, r) => ha(e, "symbol" != typeof t ? t + "" : t, r);
      class hc {
        constructor(e, t) {
          (this.core = e),
            (this.logger = t),
            ho(this, "name", "pairing"),
            ho(this, "version", "0.3"),
            ho(this, "events", new (w())()),
            ho(this, "pairings"),
            ho(this, "initialized", !1),
            ho(this, "storagePrefix", lY),
            ho(this, "ignoredPayloadTypes", [1]),
            ho(this, "registeredMethods", []),
            ho(this, "init", async () => {
              this.initialized ||
                (await this.pairings.init(),
                await this.cleanup(),
                this.registerRelayerEvents(),
                this.registerExpirerEvents(),
                (this.initialized = !0),
                this.logger.trace("Initialized"));
            }),
            ho(this, "register", ({ methods: e }) => {
              this.isInitialized(),
                (this.registeredMethods = [
                  ...new Set([...this.registeredMethods, ...e]),
                ]);
            }),
            ho(this, "create", async (e) => {
              this.isInitialized();
              let t = cP(),
                r = await this.core.crypto.setSymKey(t),
                i = nk(v.FIVE_MINUTES),
                s = { protocol: "irn" },
                n = {
                  topic: r,
                  expiry: i,
                  relay: s,
                  active: !1,
                  methods: e?.methods,
                },
                a = cH({
                  protocol: this.core.protocol,
                  version: this.core.version,
                  topic: r,
                  symKey: t,
                  relay: s,
                  expiryTimestamp: i,
                  methods: e?.methods,
                });
              return (
                this.events.emit(ue.create, n),
                this.core.expirer.set(r, i),
                await this.pairings.set(r, n),
                await this.core.relayer.subscribe(r, {
                  transportType: e?.transportType,
                }),
                { topic: r, uri: a }
              );
            }),
            ho(this, "pair", async (e) => {
              let t;
              this.isInitialized();
              let r = this.core.eventClient.createEvent({
                properties: { topic: e?.uri, trace: [ua.pairing_started] },
              });
              this.isValidPair(e, r);
              let {
                topic: i,
                symKey: s,
                relay: n,
                expiryTimestamp: a,
                methods: o,
              } = cq(e.uri);
              if (
                ((r.props.properties.topic = i),
                r.addTrace(ua.pairing_uri_validation_success),
                r.addTrace(ua.pairing_uri_not_expired),
                this.pairings.keys.includes(i))
              ) {
                if (
                  ((t = this.pairings.get(i)),
                  r.addTrace(ua.existing_pairing),
                  t.active)
                )
                  throw (
                    (r.setError(uo.active_pairing_already_exists),
                    Error(
                      `Pairing already exists: ${i}. Please try again with a new connection URI.`
                    ))
                  );
                r.addTrace(ua.pairing_not_expired);
              }
              let c = a || nk(v.FIVE_MINUTES),
                l = { topic: i, relay: n, expiry: c, active: !1, methods: o };
              this.core.expirer.set(i, c),
                await this.pairings.set(i, l),
                r.addTrace(ua.store_new_pairing),
                e.activatePairing && (await this.activate({ topic: i })),
                this.events.emit(ue.create, l),
                r.addTrace(ua.emit_inactive_pairing),
                this.core.crypto.keychain.has(i) ||
                  (await this.core.crypto.setSymKey(s, i)),
                r.addTrace(ua.subscribing_pairing_topic);
              try {
                await this.core.relayer.confirmOnlineStateOrThrow();
              } catch {
                r.setError(uo.no_internet_connection);
              }
              try {
                await this.core.relayer.subscribe(i, { relay: n });
              } catch (e) {
                throw (r.setError(uo.subscribe_pairing_topic_failure), e);
              }
              return r.addTrace(ua.subscribe_pairing_topic_success), l;
            }),
            ho(this, "activate", async ({ topic: e }) => {
              this.isInitialized();
              let t = nk(v.FIVE_MINUTES);
              this.core.expirer.set(e, t),
                await this.pairings.update(e, { active: !0, expiry: t });
            }),
            ho(this, "ping", async (e) => {
              this.isInitialized(),
                await this.isValidPing(e),
                this.logger.warn(
                  "ping() is deprecated and will be removed in the next major release."
                );
              let { topic: t } = e;
              if (this.pairings.keys.includes(t)) {
                let e = await this.sendRequest(t, "wc_pairingPing", {}),
                  { done: r, resolve: i, reject: s } = nO();
                this.events.once(nU("pairing_ping", e), ({ error: e }) => {
                  e ? s(e) : i();
                }),
                  await r();
              }
            }),
            ho(this, "updateExpiry", async ({ topic: e, expiry: t }) => {
              this.isInitialized(),
                await this.pairings.update(e, { expiry: t });
            }),
            ho(this, "updateMetadata", async ({ topic: e, metadata: t }) => {
              this.isInitialized(),
                await this.pairings.update(e, { peerMetadata: t });
            }),
            ho(
              this,
              "getPairings",
              () => (this.isInitialized(), this.pairings.values)
            ),
            ho(this, "disconnect", async (e) => {
              this.isInitialized(), await this.isValidDisconnect(e);
              let { topic: t } = e;
              this.pairings.keys.includes(t) &&
                (await this.sendRequest(
                  t,
                  "wc_pairingDelete",
                  c7("USER_DISCONNECTED")
                ),
                await this.deletePairing(t));
            }),
            ho(this, "formatUriFromPairing", (e) => {
              this.isInitialized();
              let { topic: t, relay: r, expiry: i, methods: s } = e,
                n = this.core.crypto.keychain.get(t);
              return cH({
                protocol: this.core.protocol,
                version: this.core.version,
                topic: t,
                symKey: n,
                relay: r,
                expiryTimestamp: i,
                methods: s,
              });
            }),
            ho(this, "sendRequest", async (e, t, r) => {
              let i = lN(t, r),
                s = await this.core.crypto.encode(e, i),
                n = l7[t].req;
              return (
                this.core.history.set(e, i),
                this.core.relayer.publish(e, s, n),
                i.id
              );
            }),
            ho(this, "sendResult", async (e, t, r) => {
              let i = lT(e, r),
                s = await this.core.crypto.encode(t, i),
                n = l7[(await this.core.history.get(t, e)).request.method].res;
              await this.core.relayer.publish(t, s, n),
                await this.core.history.resolve(i);
            }),
            ho(this, "sendError", async (e, t, r) => {
              let i = lO(e, r),
                s = await this.core.crypto.encode(t, i),
                n = (await this.core.history.get(t, e)).request.method,
                a = l7[n] ? l7[n].res : l7.unregistered_method.res;
              await this.core.relayer.publish(t, s, a),
                await this.core.history.resolve(i);
            }),
            ho(this, "deletePairing", async (e, t) => {
              await this.core.relayer.unsubscribe(e),
                await Promise.all([
                  this.pairings.delete(e, c7("USER_DISCONNECTED")),
                  this.core.crypto.deleteSymKey(e),
                  t ? Promise.resolve() : this.core.expirer.del(e),
                ]);
            }),
            ho(this, "cleanup", async () => {
              let e = this.pairings.getAll().filter((e) => nD(e.expiry));
              await Promise.all(e.map((e) => this.deletePairing(e.topic)));
            }),
            ho(this, "onRelayEventRequest", async (e) => {
              let { topic: t, payload: r } = e;
              switch (r.method) {
                case "wc_pairingPing":
                  return await this.onPairingPingRequest(t, r);
                case "wc_pairingDelete":
                  return await this.onPairingDeleteRequest(t, r);
                default:
                  return await this.onUnknownRpcMethodRequest(t, r);
              }
            }),
            ho(this, "onRelayEventResponse", async (e) => {
              let { topic: t, payload: r } = e,
                i = (await this.core.history.get(t, r.id)).request.method;
              return "wc_pairingPing" === i
                ? this.onPairingPingResponse(t, r)
                : this.onUnknownRpcMethodResponse(i);
            }),
            ho(this, "onPairingPingRequest", async (e, t) => {
              let { id: r } = t;
              try {
                this.isValidPing({ topic: e }),
                  await this.sendResult(r, e, !0),
                  this.events.emit(ue.ping, { id: r, topic: e });
              } catch (t) {
                await this.sendError(r, e, t), this.logger.error(t);
              }
            }),
            ho(this, "onPairingPingResponse", (e, t) => {
              let { id: r } = t;
              setTimeout(() => {
                l$(t)
                  ? this.events.emit(nU("pairing_ping", r), {})
                  : lB(t) &&
                    this.events.emit(nU("pairing_ping", r), { error: t.error });
              }, 500);
            }),
            ho(this, "onPairingDeleteRequest", async (e, t) => {
              let { id: r } = t;
              try {
                this.isValidDisconnect({ topic: e }),
                  await this.deletePairing(e),
                  this.events.emit(ue.delete, { id: r, topic: e });
              } catch (t) {
                await this.sendError(r, e, t), this.logger.error(t);
              }
            }),
            ho(this, "onUnknownRpcMethodRequest", async (e, t) => {
              let { id: r, method: i } = t;
              try {
                if (this.registeredMethods.includes(i)) return;
                let t = c7("WC_METHOD_UNSUPPORTED", i);
                await this.sendError(r, e, t), this.logger.error(t);
              } catch (t) {
                await this.sendError(r, e, t), this.logger.error(t);
              }
            }),
            ho(this, "onUnknownRpcMethodResponse", (e) => {
              this.registeredMethods.includes(e) ||
                this.logger.error(c7("WC_METHOD_UNSUPPORTED", e));
            }),
            ho(this, "isValidPair", (e, t) => {
              var r;
              if (!lu(e)) {
                let { message: r } = c9(
                  "MISSING_OR_INVALID",
                  `pair() params: ${e}`
                );
                throw (t.setError(uo.malformed_pairing_uri), Error(r));
              }
              if (
                !(function (e) {
                  function t(e) {
                    try {
                      return "u" > typeof new URL(e);
                    } catch {
                      return !1;
                    }
                  }
                  try {
                    if (li(e, !1)) {
                      if (t(e)) return !0;
                      let r = nW(e);
                      return t(r);
                    }
                  } catch {}
                  return !1;
                })(e.uri)
              ) {
                let { message: r } = c9(
                  "MISSING_OR_INVALID",
                  `pair() uri: ${e.uri}`
                );
                throw (t.setError(uo.malformed_pairing_uri), Error(r));
              }
              let i = cq(e?.uri);
              if (!(null != (r = i?.relay) && r.protocol)) {
                let { message: e } = c9(
                  "MISSING_OR_INVALID",
                  "pair() uri#relay-protocol"
                );
                throw (t.setError(uo.malformed_pairing_uri), Error(e));
              }
              if (!(null != i && i.symKey)) {
                let { message: e } = c9(
                  "MISSING_OR_INVALID",
                  "pair() uri#symKey"
                );
                throw (t.setError(uo.malformed_pairing_uri), Error(e));
              }
              if (
                null != i &&
                i.expiryTimestamp &&
                (0, v.toMiliseconds)(i?.expiryTimestamp) < Date.now()
              ) {
                t.setError(uo.pairing_expired);
                let { message: e } = c9(
                  "EXPIRED",
                  "pair() URI has expired. Please try again with a new connection URI."
                );
                throw Error(e);
              }
            }),
            ho(this, "isValidPing", async (e) => {
              if (!lu(e)) {
                let { message: t } = c9(
                  "MISSING_OR_INVALID",
                  `ping() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t } = e;
              await this.isValidPairingTopic(t);
            }),
            ho(this, "isValidDisconnect", async (e) => {
              if (!lu(e)) {
                let { message: t } = c9(
                  "MISSING_OR_INVALID",
                  `disconnect() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t } = e;
              await this.isValidPairingTopic(t);
            }),
            ho(this, "isValidPairingTopic", async (e) => {
              if (!li(e, !1)) {
                let { message: t } = c9(
                  "MISSING_OR_INVALID",
                  `pairing topic should be a string: ${e}`
                );
                throw Error(t);
              }
              if (!this.pairings.keys.includes(e)) {
                let { message: t } = c9(
                  "NO_MATCHING_KEY",
                  `pairing topic doesn't exist: ${e}`
                );
                throw Error(t);
              }
              if (nD(this.pairings.get(e).expiry)) {
                await this.deletePairing(e);
                let { message: t } = c9("EXPIRED", `pairing topic: ${e}`);
                throw Error(t);
              }
            }),
            (this.core = e),
            (this.logger = (0, ee.U5)(t, this.name)),
            (this.pairings = new hs(
              this.core,
              this.logger,
              this.name,
              this.storagePrefix
            ));
        }
        get context() {
          return (0, ee.oI)(this.logger);
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = c9("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
        registerRelayerEvents() {
          this.core.relayer.on(l2.message, async (e) => {
            let { topic: t, message: r, transportType: i } = e;
            if (
              this.pairings.keys.includes(t) &&
              i !== l8.link_mode &&
              !this.ignoredPayloadTypes.includes(
                this.core.crypto.getPayloadType(r)
              )
            )
              try {
                let e = await this.core.crypto.decode(t, r);
                lM(e)
                  ? (this.core.history.set(t, e),
                    await this.onRelayEventRequest({ topic: t, payload: e }))
                  : lj(e) &&
                    (await this.core.history.resolve(e),
                    await this.onRelayEventResponse({ topic: t, payload: e }),
                    this.core.history.delete(t, e.id)),
                  await this.core.relayer.messages.ack(t, r);
              } catch (e) {
                this.logger.error(e);
              }
          });
        }
        registerExpirerEvents() {
          this.core.expirer.on(ur.expired, async (e) => {
            let { topic: t } = nR(e.target);
            t &&
              this.pairings.keys.includes(t) &&
              (await this.deletePairing(t, !0),
              this.events.emit(ue.expire, { topic: t }));
          });
        }
      }
      var hl = Object.defineProperty,
        hu = (e, t, r) =>
          t in e
            ? hl(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        hd = (e, t, r) => hu(e, "symbol" != typeof t ? t + "" : t, r);
      class hh extends ec {
        constructor(e, t) {
          super(e, t),
            (this.core = e),
            (this.logger = t),
            hd(this, "records", new Map()),
            hd(this, "events", new b.EventEmitter()),
            hd(this, "name", "history"),
            hd(this, "version", "0.3"),
            hd(this, "cached", []),
            hd(this, "initialized", !1),
            hd(this, "storagePrefix", lY),
            hd(this, "init", async () => {
              this.initialized ||
                (this.logger.trace("Initialized"),
                await this.restore(),
                this.cached.forEach((e) => this.records.set(e.id, e)),
                (this.cached = []),
                this.registerEventListeners(),
                (this.initialized = !0));
            }),
            hd(this, "set", (e, t, r) => {
              if (
                (this.isInitialized(),
                this.logger.debug("Setting JSON-RPC request history record"),
                this.logger.trace({
                  type: "method",
                  method: "set",
                  topic: e,
                  request: t,
                  chainId: r,
                }),
                this.records.has(t.id))
              )
                return;
              let i = {
                id: t.id,
                topic: e,
                request: { method: t.method, params: t.params || null },
                chainId: r,
                expiry: nk(v.THIRTY_DAYS),
              };
              this.records.set(i.id, i),
                this.persist(),
                this.events.emit(ut.created, i);
            }),
            hd(this, "resolve", async (e) => {
              if (
                (this.isInitialized(),
                this.logger.debug("Updating JSON-RPC response history record"),
                this.logger.trace({
                  type: "method",
                  method: "update",
                  response: e,
                }),
                !this.records.has(e.id))
              )
                return;
              let t = await this.getRecord(e.id);
              typeof t.response > "u" &&
                ((t.response = lB(e)
                  ? { error: e.error }
                  : { result: e.result }),
                this.records.set(t.id, t),
                this.persist(),
                this.events.emit(ut.updated, t));
            }),
            hd(
              this,
              "get",
              async (e, t) => (
                this.isInitialized(),
                this.logger.debug("Getting record"),
                this.logger.trace({
                  type: "method",
                  method: "get",
                  topic: e,
                  id: t,
                }),
                await this.getRecord(t)
              )
            ),
            hd(this, "delete", (e, t) => {
              this.isInitialized(),
                this.logger.debug("Deleting record"),
                this.logger.trace({ type: "method", method: "delete", id: t }),
                this.values.forEach((r) => {
                  r.topic === e &&
                    (("u" > typeof t && r.id !== t) ||
                      (this.records.delete(r.id),
                      this.events.emit(ut.deleted, r)));
                }),
                this.persist();
            }),
            hd(
              this,
              "exists",
              async (e, t) => (
                this.isInitialized(),
                !!this.records.has(t) && (await this.getRecord(t)).topic === e
              )
            ),
            hd(this, "on", (e, t) => {
              this.events.on(e, t);
            }),
            hd(this, "once", (e, t) => {
              this.events.once(e, t);
            }),
            hd(this, "off", (e, t) => {
              this.events.off(e, t);
            }),
            hd(this, "removeListener", (e, t) => {
              this.events.removeListener(e, t);
            }),
            (this.logger = (0, ee.U5)(t, this.name));
        }
        get context() {
          return (0, ee.oI)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        get size() {
          return this.records.size;
        }
        get keys() {
          return Array.from(this.records.keys());
        }
        get values() {
          return Array.from(this.records.values());
        }
        get pending() {
          let e = [];
          return (
            this.values.forEach((t) => {
              if ("u" > typeof t.response) return;
              let r = {
                topic: t.topic,
                request: lN(t.request.method, t.request.params, t.id),
                chainId: t.chainId,
              };
              return e.push(r);
            }),
            e
          );
        }
        async setJsonRpcRecords(e) {
          await this.core.storage.setItem(this.storageKey, e);
        }
        async getJsonRpcRecords() {
          return await this.core.storage.getItem(this.storageKey);
        }
        getRecord(e) {
          this.isInitialized();
          let t = this.records.get(e);
          if (!t) {
            let { message: t } = c9("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw Error(t);
          }
          return t;
        }
        async persist() {
          await this.setJsonRpcRecords(this.values), this.events.emit(ut.sync);
        }
        async restore() {
          try {
            let e = await this.getJsonRpcRecords();
            if (typeof e > "u" || !e.length) return;
            if (this.records.size) {
              let { message: e } = c9("RESTORE_WILL_OVERRIDE", this.name);
              throw (this.logger.error(e), Error(e));
            }
            (this.cached = e),
              this.logger.debug(
                `Successfully Restored records for ${this.name}`
              ),
              this.logger.trace({
                type: "method",
                method: "restore",
                records: this.values,
              });
          } catch (e) {
            this.logger.debug(`Failed to Restore records for ${this.name}`),
              this.logger.error(e);
          }
        }
        registerEventListeners() {
          this.events.on(ut.created, (e) => {
            let t = ut.created;
            this.logger.info(`Emitting ${t}`),
              this.logger.debug({ type: "event", event: t, record: e });
          }),
            this.events.on(ut.updated, (e) => {
              let t = ut.updated;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: "event", event: t, record: e });
            }),
            this.events.on(ut.deleted, (e) => {
              let t = ut.deleted;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: "event", event: t, record: e });
            }),
            this.core.heartbeat.on(A.pulse, () => {
              this.cleanup();
            });
        }
        cleanup() {
          try {
            this.isInitialized();
            let e = !1;
            this.records.forEach((t) => {
              (0, v.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 &&
                (this.logger.info(`Deleting expired history log: ${t.id}`),
                this.records.delete(t.id),
                this.events.emit(ut.deleted, t, !1),
                (e = !0));
            }),
              e && this.persist();
          } catch (e) {
            this.logger.warn(e);
          }
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = c9("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var hp = Object.defineProperty,
        hf = (e, t, r) =>
          t in e
            ? hp(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        hg = (e, t, r) => hf(e, "symbol" != typeof t ? t + "" : t, r);
      class hm extends eg {
        constructor(e, t) {
          super(e, t),
            (this.core = e),
            (this.logger = t),
            hg(this, "expirations", new Map()),
            hg(this, "events", new b.EventEmitter()),
            hg(this, "name", "expirer"),
            hg(this, "version", "0.3"),
            hg(this, "cached", []),
            hg(this, "initialized", !1),
            hg(this, "storagePrefix", lY),
            hg(this, "init", async () => {
              this.initialized ||
                (this.logger.trace("Initialized"),
                await this.restore(),
                this.cached.forEach((e) => this.expirations.set(e.target, e)),
                (this.cached = []),
                this.registerEventListeners(),
                (this.initialized = !0));
            }),
            hg(this, "has", (e) => {
              try {
                let t = this.formatTarget(e);
                return "u" > typeof this.getExpiration(t);
              } catch {
                return !1;
              }
            }),
            hg(this, "set", (e, t) => {
              this.isInitialized();
              let r = this.formatTarget(e),
                i = { target: r, expiry: t };
              this.expirations.set(r, i),
                this.checkExpiry(r, i),
                this.events.emit(ur.created, { target: r, expiration: i });
            }),
            hg(this, "get", (e) => {
              this.isInitialized();
              let t = this.formatTarget(e);
              return this.getExpiration(t);
            }),
            hg(this, "del", (e) => {
              if ((this.isInitialized(), this.has(e))) {
                let t = this.formatTarget(e),
                  r = this.getExpiration(t);
                this.expirations.delete(t),
                  this.events.emit(ur.deleted, { target: t, expiration: r });
              }
            }),
            hg(this, "on", (e, t) => {
              this.events.on(e, t);
            }),
            hg(this, "once", (e, t) => {
              this.events.once(e, t);
            }),
            hg(this, "off", (e, t) => {
              this.events.off(e, t);
            }),
            hg(this, "removeListener", (e, t) => {
              this.events.removeListener(e, t);
            }),
            (this.logger = (0, ee.U5)(t, this.name));
        }
        get context() {
          return (0, ee.oI)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        get length() {
          return this.expirations.size;
        }
        get keys() {
          return Array.from(this.expirations.keys());
        }
        get values() {
          return Array.from(this.expirations.values());
        }
        formatTarget(e) {
          if ("string" == typeof e) return nP("topic", e);
          if ("number" == typeof e) return nP("id", e);
          let { message: t } = c9("UNKNOWN_TYPE", `Target type: ${typeof e}`);
          throw Error(t);
        }
        async setExpirations(e) {
          await this.core.storage.setItem(this.storageKey, e);
        }
        async getExpirations() {
          return await this.core.storage.getItem(this.storageKey);
        }
        async persist() {
          await this.setExpirations(this.values), this.events.emit(ur.sync);
        }
        async restore() {
          try {
            let e = await this.getExpirations();
            if (typeof e > "u" || !e.length) return;
            if (this.expirations.size) {
              let { message: e } = c9("RESTORE_WILL_OVERRIDE", this.name);
              throw (this.logger.error(e), Error(e));
            }
            (this.cached = e),
              this.logger.debug(
                `Successfully Restored expirations for ${this.name}`
              ),
              this.logger.trace({
                type: "method",
                method: "restore",
                expirations: this.values,
              });
          } catch (e) {
            this.logger.debug(`Failed to Restore expirations for ${this.name}`),
              this.logger.error(e);
          }
        }
        getExpiration(e) {
          let t = this.expirations.get(e);
          if (!t) {
            let { message: t } = c9("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw (this.logger.warn(t), Error(t));
          }
          return t;
        }
        checkExpiry(e, t) {
          let { expiry: r } = t;
          (0, v.toMiliseconds)(r) - Date.now() <= 0 && this.expire(e, t);
        }
        expire(e, t) {
          this.expirations.delete(e),
            this.events.emit(ur.expired, { target: e, expiration: t });
        }
        checkExpirations() {
          this.core.relayer.connected &&
            this.expirations.forEach((e, t) => this.checkExpiry(t, e));
        }
        registerEventListeners() {
          this.core.heartbeat.on(A.pulse, () => this.checkExpirations()),
            this.events.on(ur.created, (e) => {
              let t = ur.created;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: "event", event: t, data: e }),
                this.persist();
            }),
            this.events.on(ur.expired, (e) => {
              let t = ur.expired;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: "event", event: t, data: e }),
                this.persist();
            }),
            this.events.on(ur.deleted, (e) => {
              let t = ur.deleted;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: "event", event: t, data: e }),
                this.persist();
            });
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = c9("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var hy = Object.defineProperty,
        hb = (e, t, r) =>
          t in e
            ? hy(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        hw = (e, t, r) => hb(e, "symbol" != typeof t ? t + "" : t, r);
      class hv extends em {
        constructor(e, t, r) {
          super(e, t, r),
            (this.core = e),
            (this.logger = t),
            (this.store = r),
            hw(this, "name", "verify-api"),
            hw(this, "abortController"),
            hw(this, "isDevEnv"),
            hw(this, "verifyUrlV3", us),
            hw(this, "storagePrefix", lY),
            hw(this, "version", 2),
            hw(this, "publicKey"),
            hw(this, "fetchPromise"),
            hw(this, "init", async () => {
              var e;
              this.isDevEnv ||
                ((this.publicKey = await this.store.getItem(this.storeKey)),
                this.publicKey &&
                  (0, v.toMiliseconds)(
                    null == (e = this.publicKey) ? void 0 : e.expiresAt
                  ) < Date.now() &&
                  (this.logger.debug("verify v2 public key expired"),
                  await this.removePublicKey()));
            }),
            hw(this, "register", async (e) => {
              if (!nE() || this.isDevEnv) return;
              let t = window.location.origin,
                { id: r, decryptedId: i } = e,
                s = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${t}&id=${r}&decryptedId=${i}`;
              try {
                let e = (0, rY.getDocument)(),
                  t = this.startAbortTimer(5 * v.ONE_SECOND),
                  i = await new Promise((i, n) => {
                    let a = () => {
                      window.removeEventListener("message", c),
                        e.body.removeChild(o),
                        n("attestation aborted");
                    };
                    this.abortController.signal.addEventListener("abort", a);
                    let o = e.createElement("iframe");
                    (o.src = s),
                      (o.style.display = "none"),
                      o.addEventListener("error", a, {
                        signal: this.abortController.signal,
                      });
                    let c = (s) => {
                      if (s.data && "string" == typeof s.data)
                        try {
                          let n = JSON.parse(s.data);
                          if ("verify_attestation" === n.type) {
                            if (rL(n.attestation).payload.id !== r) return;
                            clearInterval(t),
                              e.body.removeChild(o),
                              this.abortController.signal.removeEventListener(
                                "abort",
                                a
                              ),
                              window.removeEventListener("message", c),
                              i(null === n.attestation ? "" : n.attestation);
                          }
                        } catch (e) {
                          this.logger.warn(e);
                        }
                    };
                    e.body.appendChild(o),
                      window.addEventListener("message", c, {
                        signal: this.abortController.signal,
                      });
                  });
                return this.logger.debug("jwt attestation", i), i;
              } catch (e) {
                this.logger.warn(e);
              }
              return "";
            }),
            hw(this, "resolve", async (e) => {
              if (this.isDevEnv) return "";
              let { attestationId: t, hash: r, encryptedId: i } = e;
              if ("" === t)
                return void this.logger.debug(
                  "resolve: attestationId is empty, skipping"
                );
              if (t) {
                if (rL(t).payload.id !== i) return;
                let e = await this.isValidJwtAttestation(t);
                if (e)
                  return e.isVerified
                    ? e
                    : void this.logger.warn(
                        "resolve: jwt attestation: origin url not verified"
                      );
              }
              if (!r) return;
              let s = this.getVerifyUrl(e?.verifyUrl);
              return this.fetchAttestation(r, s);
            }),
            hw(this, "fetchAttestation", async (e, t) => {
              this.logger.debug(`resolving attestation: ${e} from url: ${t}`);
              let r = this.startAbortTimer(5 * v.ONE_SECOND),
                i = await fetch(`${t}/attestation/${e}?v2Supported=true`, {
                  signal: this.abortController.signal,
                });
              return (
                clearTimeout(r), 200 === i.status ? await i.json() : void 0
              );
            }),
            hw(this, "getVerifyUrl", (e) => {
              let t = e || ui;
              return (
                un.includes(t) ||
                  (this.logger.info(
                    `verify url: ${t}, not included in trusted list, assigning default: ${ui}`
                  ),
                  (t = ui)),
                t
              );
            }),
            hw(this, "fetchPublicKey", async () => {
              try {
                this.logger.debug(
                  `fetching public key from: ${this.verifyUrlV3}`
                );
                let e = this.startAbortTimer(v.FIVE_SECONDS),
                  t = await fetch(`${this.verifyUrlV3}/public-key`, {
                    signal: this.abortController.signal,
                  });
                return clearTimeout(e), await t.json();
              } catch (e) {
                this.logger.warn(e);
              }
            }),
            hw(this, "persistPublicKey", async (e) => {
              this.logger.debug("persisting public key to local storage", e),
                await this.store.setItem(this.storeKey, e),
                (this.publicKey = e);
            }),
            hw(this, "removePublicKey", async () => {
              this.logger.debug("removing verify v2 public key from storage"),
                await this.store.removeItem(this.storeKey),
                (this.publicKey = void 0);
            }),
            hw(this, "isValidJwtAttestation", async (e) => {
              let t = await this.getPublicKey();
              try {
                if (t) return this.validateAttestation(e, t);
              } catch (e) {
                this.logger.error(e),
                  this.logger.warn("error validating attestation");
              }
              let r = await this.fetchAndPersistPublicKey();
              try {
                if (r) return this.validateAttestation(e, r);
              } catch (e) {
                this.logger.error(e),
                  this.logger.warn("error validating attestation");
              }
            }),
            hw(this, "getPublicKey", async () =>
              this.publicKey
                ? this.publicKey
                : await this.fetchAndPersistPublicKey()
            ),
            hw(this, "fetchAndPersistPublicKey", async () => {
              if (this.fetchPromise)
                return await this.fetchPromise, this.publicKey;
              this.fetchPromise = new Promise(async (e) => {
                let t = await this.fetchPublicKey();
                t && (await this.persistPublicKey(t), e(t));
              });
              let e = await this.fetchPromise;
              return (this.fetchPromise = void 0), e;
            }),
            hw(this, "validateAttestation", (e, t) => {
              let r = (function (e, t) {
                  let [r, i, s] = e.split("."),
                    n = nn.from(cL(s), "base64");
                  if (64 !== n.length) throw Error("Invalid signature length");
                  let a = n.slice(0, 32),
                    o = n.slice(32, 64),
                    c = og(`${r}.${i}`),
                    l = (function (e) {
                      let t = nn.from(e.x, "base64"),
                        r = nn.from(e.y, "base64");
                      return iF([new Uint8Array([4]), t, r]);
                    })(t);
                  if (!cI.verify(iF([a, o]), c, l))
                    throw Error("Invalid signature");
                  return rL(e).payload;
                })(e, t.publicKey),
                i = {
                  hasExpired: (0, v.toMiliseconds)(r.exp) < Date.now(),
                  payload: r,
                };
              if (i.hasExpired)
                throw (
                  (this.logger.warn("resolve: jwt attestation expired"),
                  Error("JWT attestation expired"))
                );
              return {
                origin: i.payload.origin,
                isScam: i.payload.isScam,
                isVerified: i.payload.isVerified,
              };
            }),
            (this.logger = (0, ee.U5)(t, this.name)),
            (this.abortController = new AbortController()),
            (this.isDevEnv = nF()),
            this.init();
        }
        get storeKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//verify:public:key"
          );
        }
        get context() {
          return (0, ee.oI)(this.logger);
        }
        startAbortTimer(e) {
          return (
            (this.abortController = new AbortController()),
            setTimeout(
              () => this.abortController.abort(),
              (0, v.toMiliseconds)(e)
            )
          );
        }
      }
      var hE = Object.defineProperty,
        h_ = (e, t, r) =>
          t in e
            ? hE(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        hC = (e, t, r) => h_(e, "symbol" != typeof t ? t + "" : t, r);
      class hA extends ey {
        constructor(e, t) {
          super(e, t),
            (this.projectId = e),
            (this.logger = t),
            hC(this, "context", "echo"),
            hC(this, "registerDeviceToken", async (e) => {
              let {
                  clientId: t,
                  token: r,
                  notificationType: i,
                  enableEncrypted: s = !1,
                } = e,
                n = `https://echo.walletconnect.com/${this.projectId}/clients`;
              await fetch(n, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  client_id: t,
                  type: i,
                  token: r,
                  always_raw: s,
                }),
              });
            }),
            (this.logger = (0, ee.U5)(t, this.context));
        }
      }
      var hI = Object.defineProperty,
        hS = Object.getOwnPropertySymbols,
        hN = Object.prototype.hasOwnProperty,
        hT = Object.prototype.propertyIsEnumerable,
        hO = (e, t, r) =>
          t in e
            ? hI(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        hx = (e, t) => {
          for (var r in t || (t = {})) hN.call(t, r) && hO(e, r, t[r]);
          if (hS) for (var r of hS(t)) hT.call(t, r) && hO(e, r, t[r]);
          return e;
        },
        hP = (e, t, r) => hO(e, "symbol" != typeof t ? t + "" : t, r);
      class hR extends eb {
        constructor(e, t, r = !0) {
          super(e, t, r),
            (this.core = e),
            (this.logger = t),
            hP(this, "context", "event-client"),
            hP(this, "storagePrefix", lY),
            hP(this, "storageVersion", 0.1),
            hP(this, "events", new Map()),
            hP(this, "shouldPersist", !1),
            hP(this, "init", async () => {
              if (!nF())
                try {
                  let e = {
                    eventId: nB(),
                    timestamp: Date.now(),
                    domain: this.getAppDomain(),
                    props: {
                      event: "INIT",
                      type: "",
                      properties: {
                        client_id: await this.core.crypto.getClientId(),
                        user_agent: nI(
                          this.core.relayer.protocol,
                          this.core.relayer.version,
                          l5
                        ),
                      },
                    },
                  };
                  await this.sendEvent([e]);
                } catch (e) {
                  this.logger.warn(e);
                }
            }),
            hP(this, "createEvent", (e) => {
              let {
                  event: t = "ERROR",
                  type: r = "",
                  properties: { topic: i, trace: s },
                } = e,
                n = nB(),
                a = this.core.projectId || "",
                o = hx(
                  {
                    eventId: n,
                    timestamp: Date.now(),
                    props: {
                      event: t,
                      type: r,
                      properties: { topic: i, trace: s },
                    },
                    bundleId: a,
                    domain: this.getAppDomain(),
                  },
                  this.setMethods(n)
                );
              return (
                this.telemetryEnabled &&
                  (this.events.set(n, o), (this.shouldPersist = !0)),
                o
              );
            }),
            hP(this, "getEvent", (e) => {
              let { eventId: t, topic: r } = e;
              if (t) return this.events.get(t);
              let i = Array.from(this.events.values()).find(
                (e) => e.props.properties.topic === r
              );
              if (i) return hx(hx({}, i), this.setMethods(i.eventId));
            }),
            hP(this, "deleteEvent", (e) => {
              let { eventId: t } = e;
              this.events.delete(t), (this.shouldPersist = !0);
            }),
            hP(this, "setEventListeners", () => {
              this.core.heartbeat.on(A.pulse, async () => {
                this.shouldPersist && (await this.persist()),
                  this.events.forEach((e) => {
                    (0, v.fromMiliseconds)(Date.now()) -
                      (0, v.fromMiliseconds)(e.timestamp) >
                      86400 &&
                      (this.events.delete(e.eventId),
                      (this.shouldPersist = !0));
                  });
              });
            }),
            hP(this, "setMethods", (e) => ({
              addTrace: (t) => this.addTrace(e, t),
              setError: (t) => this.setError(e, t),
            })),
            hP(this, "addTrace", (e, t) => {
              let r = this.events.get(e);
              r &&
                (r.props.properties.trace.push(t),
                this.events.set(e, r),
                (this.shouldPersist = !0));
            }),
            hP(this, "setError", (e, t) => {
              let r = this.events.get(e);
              r &&
                ((r.props.type = t),
                (r.timestamp = Date.now()),
                this.events.set(e, r),
                (this.shouldPersist = !0));
            }),
            hP(this, "persist", async () => {
              await this.core.storage.setItem(
                this.storageKey,
                Array.from(this.events.values())
              ),
                (this.shouldPersist = !1);
            }),
            hP(this, "restore", async () => {
              try {
                let e =
                  (await this.core.storage.getItem(this.storageKey)) || [];
                if (!e.length) return;
                e.forEach((e) => {
                  this.events.set(
                    e.eventId,
                    hx(hx({}, e), this.setMethods(e.eventId))
                  );
                });
              } catch (e) {
                this.logger.warn(e);
              }
            }),
            hP(this, "submit", async () => {
              if (!this.telemetryEnabled || 0 === this.events.size) return;
              let e = [];
              for (let [t, r] of this.events) r.props.type && e.push(r);
              if (0 !== e.length)
                try {
                  if ((await this.sendEvent(e)).ok)
                    for (let t of e)
                      this.events.delete(t.eventId), (this.shouldPersist = !0);
                } catch (e) {
                  this.logger.warn(e);
                }
            }),
            hP(this, "sendEvent", async (e) => {
              let t = this.getAppDomain() ? "" : "&sp=desktop";
              return await fetch(
                `https://pulse.walletconnect.org/batch?projectId=${this.core.projectId}&st=events_sdk&sv=js-${l5}${t}`,
                { method: "POST", body: JSON.stringify(e) }
              );
            }),
            hP(this, "getAppDomain", () => nA().url),
            (this.logger = (0, ee.U5)(t, this.context)),
            (this.telemetryEnabled = r),
            r
              ? this.restore().then(async () => {
                  await this.submit(), this.setEventListeners();
                })
              : this.persist();
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.storageVersion +
            this.core.customStoragePrefix +
            "//" +
            this.context
          );
        }
      }
      var hk = Object.defineProperty,
        hD = Object.getOwnPropertySymbols,
        hU = Object.prototype.hasOwnProperty,
        hL = Object.prototype.propertyIsEnumerable,
        hM = (e, t, r) =>
          t in e
            ? hk(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        hj = (e, t) => {
          for (var r in t || (t = {})) hU.call(t, r) && hM(e, r, t[r]);
          if (hD) for (var r of hD(t)) hL.call(t, r) && hM(e, r, t[r]);
          return e;
        },
        h$ = (e, t, r) => hM(e, "symbol" != typeof t ? t + "" : t, r);
      class hB extends es {
        constructor(e) {
          var t;
          super(e),
            h$(this, "protocol", "wc"),
            h$(this, "version", 2),
            h$(this, "name", lG),
            h$(this, "relayUrl"),
            h$(this, "projectId"),
            h$(this, "customStoragePrefix"),
            h$(this, "events", new b.EventEmitter()),
            h$(this, "logger"),
            h$(this, "heartbeat"),
            h$(this, "relayer"),
            h$(this, "crypto"),
            h$(this, "storage"),
            h$(this, "history"),
            h$(this, "expirer"),
            h$(this, "pairing"),
            h$(this, "verify"),
            h$(this, "echoClient"),
            h$(this, "linkModeSupportedApps"),
            h$(this, "eventClient"),
            h$(this, "initialized", !1),
            h$(this, "logChunkController"),
            h$(this, "on", (e, t) => this.events.on(e, t)),
            h$(this, "once", (e, t) => this.events.once(e, t)),
            h$(this, "off", (e, t) => this.events.off(e, t)),
            h$(this, "removeListener", (e, t) =>
              this.events.removeListener(e, t)
            ),
            h$(
              this,
              "dispatchEnvelope",
              ({ topic: e, message: t, sessionExists: r }) => {
                if (!e || !t) return;
                let i = {
                  topic: e,
                  message: t,
                  publishedAt: Date.now(),
                  transportType: l8.link_mode,
                };
                this.relayer.onLinkMessageEvent(i, { sessionExists: r });
              }
            );
          let r = this.getGlobalCore(e?.customStoragePrefix);
          if (r)
            try {
              return (
                (this.customStoragePrefix = r.customStoragePrefix),
                (this.logger = r.logger),
                (this.heartbeat = r.heartbeat),
                (this.crypto = r.crypto),
                (this.history = r.history),
                (this.expirer = r.expirer),
                (this.storage = r.storage),
                (this.relayer = r.relayer),
                (this.pairing = r.pairing),
                (this.verify = r.verify),
                (this.echoClient = r.echoClient),
                (this.linkModeSupportedApps = r.linkModeSupportedApps),
                (this.eventClient = r.eventClient),
                (this.initialized = r.initialized),
                (this.logChunkController = r.logChunkController),
                r
              );
            } catch (e) {
              console.warn("Failed to copy global core", e);
            }
          (this.projectId = e?.projectId),
            (this.relayUrl = e?.relayUrl || l1),
            (this.customStoragePrefix =
              null != e && e.customStoragePrefix
                ? `:${e.customStoragePrefix}`
                : "");
          let i = (0, ee.iP)({
              level:
                "string" == typeof e?.logger && e.logger ? e.logger : lZ.logger,
              name: lG,
            }),
            { logger: s, chunkLoggerController: n } = (0, ee.D5)({
              opts: i,
              maxSizeInBytes: e?.maxLogBlobSizeInBytes,
              loggerOverride: e?.logger,
            });
          (this.logChunkController = n),
            null != (t = this.logChunkController) &&
              t.downloadLogsBlobInBrowser &&
              (window.downloadLogsBlobInBrowser = async () => {
                var e, t;
                null != (e = this.logChunkController) &&
                  e.downloadLogsBlobInBrowser &&
                  (null == (t = this.logChunkController) ||
                    t.downloadLogsBlobInBrowser({
                      clientId: await this.crypto.getClientId(),
                    }));
              }),
            (this.logger = (0, ee.U5)(s, this.name)),
            (this.heartbeat = new I()),
            (this.crypto = new dl(this, this.logger, e?.keychain)),
            (this.history = new hh(this, this.logger)),
            (this.expirer = new hm(this, this.logger)),
            (this.storage =
              null != e && e.storage
                ? e.storage
                : new Q(hj(hj({}, lJ), e?.storageOptions))),
            (this.relayer = new d0({
              core: this,
              logger: this.logger,
              relayUrl: this.relayUrl,
              projectId: this.projectId,
            })),
            (this.pairing = new hc(this, this.logger)),
            (this.verify = new hv(this, this.logger, this.storage)),
            (this.echoClient = new hA(this.projectId || "", this.logger)),
            (this.linkModeSupportedApps = []),
            (this.eventClient = new hR(this, this.logger, e?.telemetryEnabled)),
            this.setGlobalCore(this);
        }
        static async init(e) {
          let t = new hB(e);
          await t.initialize();
          let r = await t.crypto.getClientId();
          return await t.storage.setItem("WALLETCONNECT_CLIENT_ID", r), t;
        }
        get context() {
          return (0, ee.oI)(this.logger);
        }
        async start() {
          this.initialized || (await this.initialize());
        }
        async getLogsBlob() {
          var e;
          return null == (e = this.logChunkController)
            ? void 0
            : e.logsToBlob({ clientId: await this.crypto.getClientId() });
        }
        async addLinkModeSupportedApp(e) {
          this.linkModeSupportedApps.includes(e) ||
            (this.linkModeSupportedApps.push(e),
            await this.storage.setItem(l4, this.linkModeSupportedApps));
        }
        async initialize() {
          this.logger.trace("Initialized");
          try {
            await this.crypto.init(),
              await this.history.init(),
              await this.expirer.init(),
              await this.relayer.init(),
              await this.heartbeat.init(),
              await this.pairing.init(),
              (this.linkModeSupportedApps =
                (await this.storage.getItem(l4)) || []),
              (this.initialized = !0),
              this.logger.info("Core Initialization Success");
          } catch (e) {
            throw (
              (this.logger.warn(
                `Core Initialization Failure at epoch ${Date.now()}`,
                e
              ),
              this.logger.error(e.message),
              e)
            );
          }
        }
        getGlobalCore(e = "") {
          try {
            if (this.isGlobalCoreDisabled()) return;
            let t = `_walletConnectCore_${e}`,
              r = `${t}_count`;
            return (
              (globalThis[r] = (globalThis[r] || 0) + 1),
              globalThis[r] > 1 &&
                console.warn(
                  `WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[r]} times.`
                ),
              globalThis[t]
            );
          } catch (e) {
            console.warn("Failed to get global WalletConnect core", e);
            return;
          }
        }
        setGlobalCore(e) {
          var t;
          try {
            if (this.isGlobalCoreDisabled()) return;
            let r = `_walletConnectCore_${
              (null == (t = e.opts) ? void 0 : t.customStoragePrefix) || ""
            }`;
            globalThis[r] = e;
          } catch (e) {
            console.warn("Failed to set global WalletConnect core", e);
          }
        }
        isGlobalCoreDisabled() {
          try {
            return "u" > typeof lK && "true" === lK.env.DISABLE_GLOBAL_CORE;
          } catch {
            return !0;
          }
        }
      }
      let hF = "client",
        hW = `wc@2:${hF}:`,
        hq = { name: hF, logger: "error" },
        hH = "WALLETCONNECT_DEEPLINK_CHOICE",
        hz = "Proposal expired",
        hV = v.SEVEN_DAYS,
        hK = {
          wc_sessionPropose: {
            req: { ttl: v.FIVE_MINUTES, prompt: !0, tag: 1100 },
            res: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1101 },
            reject: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1120 },
            autoReject: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1121 },
          },
          wc_sessionSettle: {
            req: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1102 },
            res: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1103 },
          },
          wc_sessionUpdate: {
            req: { ttl: v.ONE_DAY, prompt: !1, tag: 1104 },
            res: { ttl: v.ONE_DAY, prompt: !1, tag: 1105 },
          },
          wc_sessionExtend: {
            req: { ttl: v.ONE_DAY, prompt: !1, tag: 1106 },
            res: { ttl: v.ONE_DAY, prompt: !1, tag: 1107 },
          },
          wc_sessionRequest: {
            req: { ttl: v.FIVE_MINUTES, prompt: !0, tag: 1108 },
            res: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1109 },
          },
          wc_sessionEvent: {
            req: { ttl: v.FIVE_MINUTES, prompt: !0, tag: 1110 },
            res: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1111 },
          },
          wc_sessionDelete: {
            req: { ttl: v.ONE_DAY, prompt: !1, tag: 1112 },
            res: { ttl: v.ONE_DAY, prompt: !1, tag: 1113 },
          },
          wc_sessionPing: {
            req: { ttl: v.ONE_DAY, prompt: !1, tag: 1114 },
            res: { ttl: v.ONE_DAY, prompt: !1, tag: 1115 },
          },
          wc_sessionAuthenticate: {
            req: { ttl: v.ONE_HOUR, prompt: !0, tag: 1116 },
            res: { ttl: v.ONE_HOUR, prompt: !1, tag: 1117 },
            reject: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1118 },
            autoReject: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1119 },
          },
        },
        hG = { min: v.FIVE_MINUTES, max: v.SEVEN_DAYS },
        hY = { idle: "IDLE", active: "ACTIVE" },
        hZ = {
          eth_sendTransaction: { key: "" },
          eth_sendRawTransaction: { key: "" },
          wallet_sendCalls: { key: "" },
          solana_signTransaction: { key: "signature" },
          solana_signAllTransactions: { key: "transactions" },
          solana_signAndSendTransaction: { key: "signature" },
        },
        hJ = [
          "wc_sessionPropose",
          "wc_sessionRequest",
          "wc_authRequest",
          "wc_sessionAuthenticate",
        ],
        hX = "wc@1.5:auth:",
        hQ = `${hX}:PUB_KEY`;
      var h0 = Object.defineProperty,
        h1 = Object.defineProperties,
        h2 = Object.getOwnPropertyDescriptors,
        h3 = Object.getOwnPropertySymbols,
        h5 = Object.prototype.hasOwnProperty,
        h8 = Object.prototype.propertyIsEnumerable,
        h6 = (e, t, r) =>
          t in e
            ? h0(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        h4 = (e, t) => {
          for (var r in t || (t = {})) h5.call(t, r) && h6(e, r, t[r]);
          if (h3) for (var r of h3(t)) h8.call(t, r) && h6(e, r, t[r]);
          return e;
        },
        h9 = (e, t) => h1(e, h2(t)),
        h7 = (e, t, r) => h6(e, "symbol" != typeof t ? t + "" : t, r);
      class pe extends eC {
        constructor(e) {
          super(e),
            h7(this, "name", "engine"),
            h7(this, "events", new (w())()),
            h7(this, "initialized", !1),
            h7(this, "requestQueue", { state: hY.idle, queue: [] }),
            h7(this, "sessionRequestQueue", { state: hY.idle, queue: [] }),
            h7(this, "requestQueueDelay", v.ONE_SECOND),
            h7(this, "expectedPairingMethodMap", new Map()),
            h7(this, "recentlyDeletedMap", new Map()),
            h7(this, "recentlyDeletedLimit", 200),
            h7(this, "relayMessageCache", []),
            h7(this, "pendingSessions", new Map()),
            h7(this, "init", async () => {
              this.initialized ||
                (await this.cleanup(),
                this.registerRelayerEvents(),
                this.registerExpirerEvents(),
                this.registerPairingEvents(),
                await this.registerLinkModeListeners(),
                this.client.core.pairing.register({ methods: Object.keys(hK) }),
                (this.initialized = !0),
                setTimeout(async () => {
                  await this.processPendingMessageEvents(),
                    (this.sessionRequestQueue.queue =
                      this.getPendingSessionRequests()),
                    this.processSessionRequestQueue();
                }, (0, v.toMiliseconds)(this.requestQueueDelay)));
            }),
            h7(this, "connect", async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              let t = h9(h4({}, e), {
                requiredNamespaces: e.requiredNamespaces || {},
                optionalNamespaces: e.optionalNamespaces || {},
              });
              await this.isValidConnect(t),
                (t.optionalNamespaces = (function (e, t) {
                  var r, i, s, n, a, o;
                  let c = c5(e),
                    l = c5(t),
                    u = {};
                  for (let e of Object.keys(c).concat(Object.keys(l)))
                    u[e] = {
                      chains: nL(
                        null == (r = c[e]) ? void 0 : r.chains,
                        null == (i = l[e]) ? void 0 : i.chains
                      ),
                      methods: nL(
                        null == (s = c[e]) ? void 0 : s.methods,
                        null == (n = l[e]) ? void 0 : n.methods
                      ),
                      events: nL(
                        null == (a = c[e]) ? void 0 : a.events,
                        null == (o = l[e]) ? void 0 : o.events
                      ),
                    };
                  return u;
                })(t.requiredNamespaces, t.optionalNamespaces)),
                (t.requiredNamespaces = {});
              let {
                  pairingTopic: r,
                  requiredNamespaces: i,
                  optionalNamespaces: s,
                  sessionProperties: n,
                  scopedProperties: a,
                  relays: o,
                } = t,
                c = r,
                l,
                u = !1;
              try {
                if (c) {
                  let e = this.client.core.pairing.pairings.get(c);
                  this.client.logger.warn(
                    "connect() with existing pairing topic is deprecated and will be removed in the next major release."
                  ),
                    (u = e.active);
                }
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    `connect() -> pairing.get(${c}) failed`
                  ),
                  e)
                );
              }
              if (!c || !u) {
                let { topic: e, uri: t } =
                  await this.client.core.pairing.create();
                (c = e), (l = t);
              }
              if (!c) {
                let { message: e } = c9(
                  "NO_MATCHING_KEY",
                  `connect() pairing topic: ${c}`
                );
                throw Error(e);
              }
              let d = await this.client.core.crypto.generateKeyPair(),
                h = hK.wc_sessionPropose.req.ttl || v.FIVE_MINUTES,
                p = nk(h),
                f = h9(
                  h4(
                    h4(
                      {
                        requiredNamespaces: i,
                        optionalNamespaces: s,
                        relays: o ?? [{ protocol: "irn" }],
                        proposer: {
                          publicKey: d,
                          metadata: this.client.metadata,
                        },
                        expiryTimestamp: p,
                        pairingTopic: c,
                      },
                      n && { sessionProperties: n }
                    ),
                    a && { scopedProperties: a }
                  ),
                  { id: lI() }
                ),
                g = nU("session_connect", f.id),
                { reject: m, resolve: y, done: b } = nO(h, hz),
                w = ({ id: e }) => {
                  e === f.id &&
                    (this.client.events.off("proposal_expire", w),
                    this.pendingSessions.delete(f.id),
                    this.events.emit(g, { error: { message: hz, code: 0 } }));
                };
              return (
                this.client.events.on("proposal_expire", w),
                this.events.once(g, ({ error: e, session: t }) => {
                  this.client.events.off("proposal_expire", w),
                    e ? m(e) : t && y(t);
                }),
                await this.sendRequest({
                  topic: c,
                  method: "wc_sessionPropose",
                  params: f,
                  throwOnFailedPublish: !0,
                  clientRpcId: f.id,
                }),
                await this.setProposal(f.id, f),
                { uri: l, approval: b }
              );
            }),
            h7(this, "pair", async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                return await this.client.core.pairing.pair(e);
              } catch (e) {
                throw (this.client.logger.error("pair() failed"), e);
              }
            }),
            h7(this, "approve", async (e) => {
              var t, r, i;
              let s = this.client.core.eventClient.createEvent({
                properties: {
                  topic: null == (t = e?.id) ? void 0 : t.toString(),
                  trace: [uc.session_approve_started],
                },
              });
              try {
                this.isInitialized(), await this.confirmOnlineStateOrThrow();
              } catch (e) {
                throw (s.setError(ul.no_internet_connection), e);
              }
              try {
                await this.isValidProposalId(e?.id);
              } catch (t) {
                throw (
                  (this.client.logger.error(
                    `approve() -> proposal.get(${e?.id}) failed`
                  ),
                  s.setError(ul.proposal_not_found),
                  t)
                );
              }
              try {
                await this.isValidApprove(e);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    "approve() -> isValidApprove() failed"
                  ),
                  s.setError(ul.session_approve_namespace_validation_failure),
                  e)
                );
              }
              let {
                  id: n,
                  relayProtocol: a,
                  namespaces: o,
                  sessionProperties: c,
                  scopedProperties: l,
                  sessionConfig: u,
                } = e,
                d = this.client.proposal.get(n);
              this.client.core.eventClient.deleteEvent({ eventId: s.eventId });
              let {
                  pairingTopic: h,
                  proposer: p,
                  requiredNamespaces: f,
                  optionalNamespaces: g,
                } = d,
                m =
                  null == (r = this.client.core.eventClient)
                    ? void 0
                    : r.getEvent({ topic: h });
              m ||
                (m =
                  null == (i = this.client.core.eventClient)
                    ? void 0
                    : i.createEvent({
                        type: uc.session_approve_started,
                        properties: {
                          topic: h,
                          trace: [
                            uc.session_approve_started,
                            uc.session_namespaces_validation_success,
                          ],
                        },
                      }));
              let y = await this.client.core.crypto.generateKeyPair(),
                b = p.publicKey,
                w = await this.client.core.crypto.generateSharedKey(y, b),
                v = h4(
                  h4(
                    h4(
                      {
                        relay: { protocol: a ?? "irn" },
                        namespaces: o,
                        controller: {
                          publicKey: y,
                          metadata: this.client.metadata,
                        },
                        expiry: nk(hV),
                      },
                      c && { sessionProperties: c }
                    ),
                    l && { scopedProperties: l }
                  ),
                  u && { sessionConfig: u }
                ),
                E = l8.relay;
              m.addTrace(uc.subscribing_session_topic);
              try {
                await this.client.core.relayer.subscribe(w, {
                  transportType: E,
                });
              } catch (e) {
                throw (m.setError(ul.subscribe_session_topic_failure), e);
              }
              m.addTrace(uc.subscribe_session_topic_success);
              let _ = h9(h4({}, v), {
                topic: w,
                requiredNamespaces: f,
                optionalNamespaces: g,
                pairingTopic: h,
                acknowledged: !1,
                self: v.controller,
                peer: { publicKey: p.publicKey, metadata: p.metadata },
                controller: y,
                transportType: l8.relay,
              });
              await this.client.session.set(w, _), m.addTrace(uc.store_session);
              try {
                m.addTrace(uc.publishing_session_settle),
                  await this.sendRequest({
                    topic: w,
                    method: "wc_sessionSettle",
                    params: v,
                    throwOnFailedPublish: !0,
                  }).catch((e) => {
                    throw (m?.setError(ul.session_settle_publish_failure), e);
                  }),
                  m.addTrace(uc.session_settle_publish_success),
                  m.addTrace(uc.publishing_session_approve),
                  await this.sendResult({
                    id: n,
                    topic: h,
                    result: {
                      relay: { protocol: a ?? "irn" },
                      responderPublicKey: y,
                    },
                    throwOnFailedPublish: !0,
                  }).catch((e) => {
                    throw (m?.setError(ul.session_approve_publish_failure), e);
                  }),
                  m.addTrace(uc.session_approve_publish_success);
              } catch (e) {
                throw (
                  (this.client.logger.error(e),
                  this.client.session.delete(w, c7("USER_DISCONNECTED")),
                  await this.client.core.relayer.unsubscribe(w),
                  e)
                );
              }
              return (
                this.client.core.eventClient.deleteEvent({
                  eventId: m.eventId,
                }),
                await this.client.core.pairing.updateMetadata({
                  topic: h,
                  metadata: p.metadata,
                }),
                await this.client.proposal.delete(n, c7("USER_DISCONNECTED")),
                await this.client.core.pairing.activate({ topic: h }),
                await this.setExpiry(w, nk(hV)),
                {
                  topic: w,
                  acknowledged: () =>
                    Promise.resolve(this.client.session.get(w)),
                }
              );
            }),
            h7(this, "reject", async (e) => {
              let t;
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                await this.isValidReject(e);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    "reject() -> isValidReject() failed"
                  ),
                  e)
                );
              }
              let { id: r, reason: i } = e;
              try {
                t = this.client.proposal.get(r).pairingTopic;
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    `reject() -> proposal.get(${r}) failed`
                  ),
                  e)
                );
              }
              t &&
                (await this.sendError({
                  id: r,
                  topic: t,
                  error: i,
                  rpcOpts: hK.wc_sessionPropose.reject,
                }),
                await this.client.proposal.delete(r, c7("USER_DISCONNECTED")));
            }),
            h7(this, "update", async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                await this.isValidUpdate(e);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    "update() -> isValidUpdate() failed"
                  ),
                  e)
                );
              }
              let { topic: t, namespaces: r } = e,
                { done: i, resolve: s, reject: n } = nO(),
                a = lI(),
                o = lS().toString(),
                c = this.client.session.get(t).namespaces;
              return (
                this.events.once(nU("session_update", a), ({ error: e }) => {
                  e ? n(e) : s();
                }),
                await this.client.session.update(t, { namespaces: r }),
                await this.sendRequest({
                  topic: t,
                  method: "wc_sessionUpdate",
                  params: { namespaces: r },
                  throwOnFailedPublish: !0,
                  clientRpcId: a,
                  relayRpcId: o,
                }).catch((e) => {
                  this.client.logger.error(e),
                    this.client.session.update(t, { namespaces: c }),
                    n(e);
                }),
                { acknowledged: i }
              );
            }),
            h7(this, "extend", async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                await this.isValidExtend(e);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    "extend() -> isValidExtend() failed"
                  ),
                  e)
                );
              }
              let { topic: t } = e,
                r = lI(),
                { done: i, resolve: s, reject: n } = nO();
              return (
                this.events.once(nU("session_extend", r), ({ error: e }) => {
                  e ? n(e) : s();
                }),
                await this.setExpiry(t, nk(hV)),
                this.sendRequest({
                  topic: t,
                  method: "wc_sessionExtend",
                  params: {},
                  clientRpcId: r,
                  throwOnFailedPublish: !0,
                }).catch((e) => {
                  n(e);
                }),
                { acknowledged: i }
              );
            }),
            h7(this, "request", async (e) => {
              this.isInitialized();
              try {
                await this.isValidRequest(e);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    "request() -> isValidRequest() failed"
                  ),
                  e)
                );
              }
              let {
                  chainId: t,
                  request: r,
                  topic: i,
                  expiry: s = hK.wc_sessionRequest.req.ttl,
                } = e,
                n = this.client.session.get(i);
              n?.transportType === l8.relay &&
                (await this.confirmOnlineStateOrThrow());
              let a = lI(),
                o = lS().toString(),
                {
                  done: c,
                  resolve: l,
                  reject: u,
                } = nO(s, "Request expired. Please try again.");
              this.events.once(
                nU("session_request", a),
                ({ error: e, result: t }) => {
                  e ? u(e) : l(t);
                }
              );
              let d = "wc_sessionRequest",
                h = this.getAppLinkIfEnabled(n.peer.metadata, n.transportType);
              if (h)
                return (
                  await this.sendRequest({
                    clientRpcId: a,
                    relayRpcId: o,
                    topic: i,
                    method: d,
                    params: {
                      request: h9(h4({}, r), { expiryTimestamp: nk(s) }),
                      chainId: t,
                    },
                    expiry: s,
                    throwOnFailedPublish: !0,
                    appLink: h,
                  }).catch((e) => u(e)),
                  this.client.events.emit("session_request_sent", {
                    topic: i,
                    request: r,
                    chainId: t,
                    id: a,
                  }),
                  await c()
                );
              let p = {
                  request: h9(h4({}, r), { expiryTimestamp: nk(s) }),
                  chainId: t,
                },
                f = this.shouldSetTVF(d, p);
              return await Promise.all([
                new Promise(async (e) => {
                  await this.sendRequest(
                    h4(
                      {
                        clientRpcId: a,
                        relayRpcId: o,
                        topic: i,
                        method: d,
                        params: p,
                        expiry: s,
                        throwOnFailedPublish: !0,
                      },
                      f && { tvf: this.getTVFParams(a, p) }
                    )
                  ).catch((e) => u(e)),
                    this.client.events.emit("session_request_sent", {
                      topic: i,
                      request: r,
                      chainId: t,
                      id: a,
                    }),
                    e();
                }),
                new Promise(async (e) => {
                  var t;
                  if (!(null != (t = n.sessionConfig) && t.disableDeepLink)) {
                    let e = await nj(this.client.core.storage, hH);
                    await nM({ id: a, topic: i, wcDeepLink: e });
                  }
                  e();
                }),
                c(),
              ]).then((e) => e[2]);
            }),
            h7(this, "respond", async (e) => {
              this.isInitialized(), await this.isValidRespond(e);
              let { topic: t, response: r } = e,
                { id: i } = r,
                s = this.client.session.get(t);
              s.transportType === l8.relay &&
                (await this.confirmOnlineStateOrThrow());
              let n = this.getAppLinkIfEnabled(
                s.peer.metadata,
                s.transportType
              );
              l$(r)
                ? await this.sendResult({
                    id: i,
                    topic: t,
                    result: r.result,
                    throwOnFailedPublish: !0,
                    appLink: n,
                  })
                : lB(r) &&
                  (await this.sendError({
                    id: i,
                    topic: t,
                    error: r.error,
                    appLink: n,
                  })),
                this.cleanupAfterResponse(e);
            }),
            h7(this, "ping", async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                await this.isValidPing(e);
              } catch (e) {
                throw (
                  (this.client.logger.error("ping() -> isValidPing() failed"),
                  e)
                );
              }
              let { topic: t } = e;
              if (this.client.session.keys.includes(t)) {
                let e = lI(),
                  r = lS().toString(),
                  { done: i, resolve: s, reject: n } = nO();
                this.events.once(nU("session_ping", e), ({ error: e }) => {
                  e ? n(e) : s();
                }),
                  await Promise.all([
                    this.sendRequest({
                      topic: t,
                      method: "wc_sessionPing",
                      params: {},
                      throwOnFailedPublish: !0,
                      clientRpcId: e,
                      relayRpcId: r,
                    }),
                    i(),
                  ]);
              } else
                this.client.core.pairing.pairings.keys.includes(t) &&
                  (this.client.logger.warn(
                    "ping() on pairing topic is deprecated and will be removed in the next major release."
                  ),
                  await this.client.core.pairing.ping({ topic: t }));
            }),
            h7(this, "emit", async (e) => {
              this.isInitialized(),
                await this.confirmOnlineStateOrThrow(),
                await this.isValidEmit(e);
              let { topic: t, event: r, chainId: i } = e,
                s = lS().toString(),
                n = lI();
              await this.sendRequest({
                topic: t,
                method: "wc_sessionEvent",
                params: { event: r, chainId: i },
                throwOnFailedPublish: !0,
                relayRpcId: s,
                clientRpcId: n,
              });
            }),
            h7(this, "disconnect", async (e) => {
              this.isInitialized(),
                await this.confirmOnlineStateOrThrow(),
                await this.isValidDisconnect(e);
              let { topic: t } = e;
              if (this.client.session.keys.includes(t))
                await this.sendRequest({
                  topic: t,
                  method: "wc_sessionDelete",
                  params: c7("USER_DISCONNECTED"),
                  throwOnFailedPublish: !0,
                }),
                  await this.deleteSession({ topic: t, emitEvent: !1 });
              else if (this.client.core.pairing.pairings.keys.includes(t))
                await this.client.core.pairing.disconnect({ topic: t });
              else {
                let { message: e } = c9(
                  "MISMATCHED_TOPIC",
                  `Session or pairing topic not found: ${t}`
                );
                throw Error(e);
              }
            }),
            h7(
              this,
              "find",
              (e) => (
                this.isInitialized(),
                this.client.session.getAll().filter((t) =>
                  (function (e, t) {
                    let { requiredNamespaces: r } = t,
                      i = Object.keys(e.namespaces),
                      s = Object.keys(r),
                      n = !0;
                    return (
                      !!nS(s, i) &&
                      (i.forEach((t) => {
                        let {
                            accounts: i,
                            methods: s,
                            events: a,
                          } = e.namespaces[t],
                          o = c1(i),
                          c = r[t];
                        (nS(nc(t, c), o) &&
                          nS(c.methods, s) &&
                          nS(c.events, a)) ||
                          (n = !1);
                      }),
                      n)
                    );
                  })(t, e)
                )
              )
            ),
            h7(this, "getPendingSessionRequests", () =>
              this.client.pendingRequest.getAll()
            ),
            h7(this, "authenticate", async (e, t) => {
              var r, i, s;
              let n;
              this.isInitialized(), this.isValidAuthenticate(e);
              let a =
                  t &&
                  this.client.core.linkModeSupportedApps.includes(t) &&
                  (null == (r = this.client.metadata.redirect)
                    ? void 0
                    : r.linkMode),
                o = a ? l8.link_mode : l8.relay;
              o === l8.relay && (await this.confirmOnlineStateOrThrow());
              let {
                  chains: c,
                  statement: l = "",
                  uri: u,
                  domain: d,
                  nonce: h,
                  type: p,
                  exp: f,
                  nbf: g,
                  methods: m = [],
                  expiry: y,
                } = e,
                b = [...(e.resources || [])],
                { topic: w, uri: v } = await this.client.core.pairing.create({
                  methods: ["wc_sessionAuthenticate"],
                  transportType: o,
                });
              this.client.logger.info({
                message: "Generated new pairing",
                pairing: { topic: w, uri: v },
              });
              let E = await this.client.core.crypto.generateKeyPair(),
                _ = cR(E);
              if (
                (await Promise.all([
                  this.client.auth.authKeys.set(hQ, {
                    responseTopic: _,
                    publicKey: E,
                  }),
                  this.client.auth.pairingTopics.set(_, {
                    topic: _,
                    pairingTopic: w,
                  }),
                ]),
                await this.client.core.relayer.subscribe(_, {
                  transportType: o,
                }),
                this.client.logger.info(
                  `sending request to new pairing topic: ${w}`
                ),
                m.length > 0)
              ) {
                let { namespace: e } = na(c[0]),
                  t = aD(
                    (function (e, t, r, i = {}) {
                      return (
                        r?.sort((e, t) => e.localeCompare(t)),
                        {
                          att: {
                            [e]: (function (e, t, r = {}) {
                              return Object.assign(
                                {},
                                ...(t = t?.sort((e, t) =>
                                  e.localeCompare(t)
                                )).map((t) => ({ [`${e}/${t}`]: [r] }))
                              );
                            })(t, r, i),
                          },
                        }
                      );
                    })(e, "request", m)
                  );
                aj(b) &&
                  ((i = t),
                  (s = b.pop()),
                  (t = aD(
                    (function (e, t) {
                      ak(e), ak(t);
                      let r = Object.keys(e.att)
                          .concat(Object.keys(t.att))
                          .sort((e, t) => e.localeCompare(t)),
                        i = { att: {} };
                      return (
                        r.forEach((r) => {
                          var s, n;
                          Object.keys(
                            (null == (s = e.att) ? void 0 : s[r]) || {}
                          )
                            .concat(
                              Object.keys(
                                (null == (n = t.att) ? void 0 : n[r]) || {}
                              )
                            )
                            .sort((e, t) => e.localeCompare(t))
                            .forEach((s) => {
                              var n, a;
                              i.att[r] = aS(aI({}, i.att[r]), {
                                [s]:
                                  (null == (n = e.att[r]) ? void 0 : n[s]) ||
                                  (null == (a = t.att[r]) ? void 0 : a[s]),
                              });
                            });
                        }),
                        i
                      );
                    })(aU(i), aU(s))
                  ))),
                  b.push(t);
              }
              let C =
                  y && y > hK.wc_sessionAuthenticate.req.ttl
                    ? y
                    : hK.wc_sessionAuthenticate.req.ttl,
                A = {
                  authPayload: {
                    type: p ?? "caip122",
                    chains: c,
                    statement: l,
                    aud: u,
                    domain: d,
                    version: "1",
                    nonce: h,
                    iat: new Date().toISOString(),
                    exp: f,
                    nbf: g,
                    resources: b,
                  },
                  requester: { publicKey: E, metadata: this.client.metadata },
                  expiryTimestamp: nk(C),
                },
                I = {
                  requiredNamespaces: {},
                  optionalNamespaces: {
                    eip155: {
                      chains: c,
                      methods: [...new Set(["personal_sign", ...m])],
                      events: ["chainChanged", "accountsChanged"],
                    },
                  },
                  relays: [{ protocol: "irn" }],
                  pairingTopic: w,
                  proposer: { publicKey: E, metadata: this.client.metadata },
                  expiryTimestamp: nk(hK.wc_sessionPropose.req.ttl),
                  id: lI(),
                },
                { done: S, resolve: N, reject: T } = nO(C, "Request expired"),
                O = lI(),
                x = nU("session_connect", I.id),
                P = nU("session_request", O),
                R = async ({ error: e, session: t }) => {
                  this.events.off(P, k), e ? T(e) : t && N({ session: t });
                },
                k = async (e) => {
                  var r, i, s;
                  let n;
                  if (
                    (await this.deletePendingAuthRequest(O, {
                      message: "fulfilled",
                      code: 0,
                    }),
                    e.error)
                  ) {
                    let t = c7(
                      "WC_METHOD_UNSUPPORTED",
                      "wc_sessionAuthenticate"
                    );
                    return e.error.code === t.code
                      ? void 0
                      : (this.events.off(x, R), T(e.error.message));
                  }
                  await this.deleteProposal(I.id), this.events.off(x, R);
                  let { cacaos: a, responder: c } = e.result,
                    l = [],
                    u = [];
                  for (let e of a) {
                    (await aP({
                      cacao: e,
                      projectId: this.client.core.projectId,
                    })) ||
                      (this.client.logger.error(
                        e,
                        "Signature verification failed"
                      ),
                      T(
                        c7(
                          "SESSION_SETTLEMENT_FAILED",
                          "Signature verification failed"
                        )
                      ));
                    let { p: t } = e,
                      r = aj(t.resources),
                      i = [aO(t.iss)],
                      s = ax(t.iss);
                    if (r) {
                      let e = aL(r),
                        t = aM(r);
                      l.push(...e), i.push(...t);
                    }
                    for (let e of i) u.push(`${e}:${s}`);
                  }
                  let d = await this.client.core.crypto.generateSharedKey(
                    E,
                    c.publicKey
                  );
                  l.length > 0 &&
                    ((n = {
                      topic: d,
                      acknowledged: !0,
                      self: { publicKey: E, metadata: this.client.metadata },
                      peer: c,
                      controller: c.publicKey,
                      expiry: nk(hV),
                      requiredNamespaces: {},
                      optionalNamespaces: {},
                      relay: { protocol: "irn" },
                      pairingTopic: w,
                      namespaces: c8([...new Set(l)], [...new Set(u)]),
                      transportType: o,
                    }),
                    await this.client.core.relayer.subscribe(d, {
                      transportType: o,
                    }),
                    await this.client.session.set(d, n),
                    w &&
                      (await this.client.core.pairing.updateMetadata({
                        topic: w,
                        metadata: c.metadata,
                      })),
                    (n = this.client.session.get(d))),
                    null != (r = this.client.metadata.redirect) &&
                      r.linkMode &&
                      null != (i = c.metadata.redirect) &&
                      i.linkMode &&
                      null != (s = c.metadata.redirect) &&
                      s.universal &&
                      t &&
                      (this.client.core.addLinkModeSupportedApp(
                        c.metadata.redirect.universal
                      ),
                      this.client.session.update(d, {
                        transportType: l8.link_mode,
                      })),
                    N({ auths: a, session: n });
                };
              this.events.once(x, R), this.events.once(P, k);
              try {
                if (a) {
                  let e = lN("wc_sessionAuthenticate", A, O);
                  this.client.core.history.set(w, e);
                  let r = await this.client.core.crypto.encode("", e, {
                    type: 2,
                    encoding: cO,
                  });
                  n = cz(t, w, r);
                } else
                  await Promise.all([
                    this.sendRequest({
                      topic: w,
                      method: "wc_sessionAuthenticate",
                      params: A,
                      expiry: e.expiry,
                      throwOnFailedPublish: !0,
                      clientRpcId: O,
                    }),
                    this.sendRequest({
                      topic: w,
                      method: "wc_sessionPropose",
                      params: I,
                      expiry: hK.wc_sessionPropose.req.ttl,
                      throwOnFailedPublish: !0,
                      clientRpcId: I.id,
                    }),
                  ]);
              } catch (e) {
                throw (this.events.off(x, R), this.events.off(P, k), e);
              }
              return (
                await this.setProposal(I.id, I),
                await this.setAuthRequest(O, {
                  request: h9(h4({}, A), { verifyContext: {} }),
                  pairingTopic: w,
                  transportType: o,
                }),
                { uri: n ?? v, response: S }
              );
            }),
            h7(this, "approveSessionAuthenticate", async (e) => {
              let t,
                { id: r, auths: i } = e,
                s = this.client.core.eventClient.createEvent({
                  properties: {
                    topic: r.toString(),
                    trace: [uu.authenticated_session_approve_started],
                  },
                });
              try {
                this.isInitialized();
              } catch (e) {
                throw (s.setError(ud.no_internet_connection), e);
              }
              let n = this.getPendingAuthRequest(r);
              if (!n)
                throw (
                  (s.setError(
                    ud.authenticated_session_pending_request_not_found
                  ),
                  Error(`Could not find pending auth request with id ${r}`))
                );
              let a = n.transportType || l8.relay;
              a === l8.relay && (await this.confirmOnlineStateOrThrow());
              let o = n.requester.publicKey,
                c = await this.client.core.crypto.generateKeyPair(),
                l = cR(o),
                u = { type: 1, receiverPublicKey: o, senderPublicKey: c },
                d = [],
                h = [];
              for (let e of i) {
                if (
                  !(await aP({
                    cacao: e,
                    projectId: this.client.core.projectId,
                  }))
                ) {
                  s.setError(ud.invalid_cacao);
                  let e = c7(
                    "SESSION_SETTLEMENT_FAILED",
                    "Signature verification failed"
                  );
                  throw (
                    (await this.sendError({
                      id: r,
                      topic: l,
                      error: e,
                      encodeOpts: u,
                    }),
                    Error(e.message))
                  );
                }
                s.addTrace(uu.cacaos_verified);
                let { p: t } = e,
                  i = aj(t.resources),
                  n = [aO(t.iss)],
                  a = ax(t.iss);
                if (i) {
                  let e = aL(i),
                    t = aM(i);
                  d.push(...e), n.push(...t);
                }
                for (let e of n) h.push(`${e}:${a}`);
              }
              let p = await this.client.core.crypto.generateSharedKey(c, o);
              if (
                (s.addTrace(uu.create_authenticated_session_topic),
                d?.length > 0)
              ) {
                (t = {
                  topic: p,
                  acknowledged: !0,
                  self: { publicKey: c, metadata: this.client.metadata },
                  peer: { publicKey: o, metadata: n.requester.metadata },
                  controller: o,
                  expiry: nk(hV),
                  authentication: i,
                  requiredNamespaces: {},
                  optionalNamespaces: {},
                  relay: { protocol: "irn" },
                  pairingTopic: n.pairingTopic,
                  namespaces: c8([...new Set(d)], [...new Set(h)]),
                  transportType: a,
                }),
                  s.addTrace(uu.subscribing_authenticated_session_topic);
                try {
                  await this.client.core.relayer.subscribe(p, {
                    transportType: a,
                  });
                } catch (e) {
                  throw (
                    (s.setError(
                      ud.subscribe_authenticated_session_topic_failure
                    ),
                    e)
                  );
                }
                s.addTrace(uu.subscribe_authenticated_session_topic_success),
                  await this.client.session.set(p, t),
                  s.addTrace(uu.store_authenticated_session),
                  await this.client.core.pairing.updateMetadata({
                    topic: n.pairingTopic,
                    metadata: n.requester.metadata,
                  });
              }
              s.addTrace(uu.publishing_authenticated_session_approve);
              try {
                await this.sendResult({
                  topic: l,
                  id: r,
                  result: {
                    cacaos: i,
                    responder: { publicKey: c, metadata: this.client.metadata },
                  },
                  encodeOpts: u,
                  throwOnFailedPublish: !0,
                  appLink: this.getAppLinkIfEnabled(n.requester.metadata, a),
                });
              } catch (e) {
                throw (
                  (s.setError(ud.authenticated_session_approve_publish_failure),
                  e)
                );
              }
              return (
                await this.client.auth.requests.delete(r, {
                  message: "fulfilled",
                  code: 0,
                }),
                await this.client.core.pairing.activate({
                  topic: n.pairingTopic,
                }),
                this.client.core.eventClient.deleteEvent({
                  eventId: s.eventId,
                }),
                { session: t }
              );
            }),
            h7(this, "rejectSessionAuthenticate", async (e) => {
              this.isInitialized();
              let { id: t, reason: r } = e,
                i = this.getPendingAuthRequest(t);
              if (!i)
                throw Error(`Could not find pending auth request with id ${t}`);
              i.transportType === l8.relay &&
                (await this.confirmOnlineStateOrThrow());
              let s = i.requester.publicKey,
                n = await this.client.core.crypto.generateKeyPair(),
                a = cR(s);
              await this.sendError({
                id: t,
                topic: a,
                error: r,
                encodeOpts: {
                  type: 1,
                  receiverPublicKey: s,
                  senderPublicKey: n,
                },
                rpcOpts: hK.wc_sessionAuthenticate.reject,
                appLink: this.getAppLinkIfEnabled(
                  i.requester.metadata,
                  i.transportType
                ),
              }),
                await this.client.auth.requests.delete(t, {
                  message: "rejected",
                  code: 0,
                }),
                await this.client.proposal.delete(t, c7("USER_DISCONNECTED"));
            }),
            h7(this, "formatAuthMessage", (e) => {
              this.isInitialized();
              let { request: t, iss: r } = e;
              return aR(t, r);
            }),
            h7(this, "processRelayMessageCache", () => {
              setTimeout(async () => {
                if (0 !== this.relayMessageCache.length)
                  for (; this.relayMessageCache.length > 0; )
                    try {
                      let e = this.relayMessageCache.shift();
                      e && (await this.onRelayMessage(e));
                    } catch (e) {
                      this.client.logger.error(e);
                    }
              }, 50);
            }),
            h7(this, "cleanupDuplicatePairings", async (e) => {
              if (e.pairingTopic)
                try {
                  let t = this.client.core.pairing.pairings.get(e.pairingTopic),
                    r = this.client.core.pairing.pairings
                      .getAll()
                      .filter((r) => {
                        var i, s;
                        return (
                          (null == (i = r.peerMetadata) ? void 0 : i.url) &&
                          (null == (s = r.peerMetadata) ? void 0 : s.url) ===
                            e.peer.metadata.url &&
                          r.topic &&
                          r.topic !== t.topic
                        );
                      });
                  if (0 === r.length) return;
                  this.client.logger.info(
                    `Cleaning up ${r.length} duplicate pairing(s)`
                  ),
                    await Promise.all(
                      r.map((e) =>
                        this.client.core.pairing.disconnect({ topic: e.topic })
                      )
                    ),
                    this.client.logger.info(
                      "Duplicate pairings clean up finished"
                    );
                } catch (e) {
                  this.client.logger.error(e);
                }
            }),
            h7(this, "deleteSession", async (e) => {
              var t;
              let {
                  topic: r,
                  expirerHasDeleted: i = !1,
                  emitEvent: s = !0,
                  id: n = 0,
                } = e,
                { self: a } = this.client.session.get(r);
              await this.client.core.relayer.unsubscribe(r),
                await this.client.session.delete(r, c7("USER_DISCONNECTED")),
                this.addToRecentlyDeleted(r, "session"),
                this.client.core.crypto.keychain.has(a.publicKey) &&
                  (await this.client.core.crypto.deleteKeyPair(a.publicKey)),
                this.client.core.crypto.keychain.has(r) &&
                  (await this.client.core.crypto.deleteSymKey(r)),
                i || this.client.core.expirer.del(r),
                this.client.core.storage
                  .removeItem(hH)
                  .catch((e) => this.client.logger.warn(e)),
                this.getPendingSessionRequests().forEach((e) => {
                  e.topic === r &&
                    this.deletePendingSessionRequest(
                      e.id,
                      c7("USER_DISCONNECTED")
                    );
                }),
                r ===
                  (null == (t = this.sessionRequestQueue.queue[0])
                    ? void 0
                    : t.topic) && (this.sessionRequestQueue.state = hY.idle),
                s &&
                  this.client.events.emit("session_delete", {
                    id: n,
                    topic: r,
                  });
            }),
            h7(this, "deleteProposal", async (e, t) => {
              if (t)
                try {
                  let t = this.client.proposal.get(e),
                    r = this.client.core.eventClient.getEvent({
                      topic: t.pairingTopic,
                    });
                  r?.setError(ul.proposal_expired);
                } catch {}
              await Promise.all([
                this.client.proposal.delete(e, c7("USER_DISCONNECTED")),
                t ? Promise.resolve() : this.client.core.expirer.del(e),
              ]),
                this.addToRecentlyDeleted(e, "proposal");
            }),
            h7(this, "deletePendingSessionRequest", async (e, t, r = !1) => {
              await Promise.all([
                this.client.pendingRequest.delete(e, t),
                r ? Promise.resolve() : this.client.core.expirer.del(e),
              ]),
                this.addToRecentlyDeleted(e, "request"),
                (this.sessionRequestQueue.queue =
                  this.sessionRequestQueue.queue.filter((t) => t.id !== e)),
                r &&
                  ((this.sessionRequestQueue.state = hY.idle),
                  this.client.events.emit("session_request_expire", { id: e }));
            }),
            h7(this, "deletePendingAuthRequest", async (e, t, r = !1) => {
              await Promise.all([
                this.client.auth.requests.delete(e, t),
                r ? Promise.resolve() : this.client.core.expirer.del(e),
              ]);
            }),
            h7(this, "setExpiry", async (e, t) => {
              this.client.session.keys.includes(e) &&
                (this.client.core.expirer.set(e, t),
                await this.client.session.update(e, { expiry: t }));
            }),
            h7(this, "setProposal", async (e, t) => {
              this.client.core.expirer.set(e, nk(hK.wc_sessionPropose.req.ttl)),
                await this.client.proposal.set(e, t);
            }),
            h7(this, "setAuthRequest", async (e, t) => {
              let {
                request: r,
                pairingTopic: i,
                transportType: s = l8.relay,
              } = t;
              this.client.core.expirer.set(e, r.expiryTimestamp),
                await this.client.auth.requests.set(e, {
                  authPayload: r.authPayload,
                  requester: r.requester,
                  expiryTimestamp: r.expiryTimestamp,
                  id: e,
                  pairingTopic: i,
                  verifyContext: r.verifyContext,
                  transportType: s,
                });
            }),
            h7(this, "setPendingSessionRequest", async (e) => {
              let { id: t, topic: r, params: i, verifyContext: s } = e,
                n =
                  i.request.expiryTimestamp || nk(hK.wc_sessionRequest.req.ttl);
              this.client.core.expirer.set(t, n),
                await this.client.pendingRequest.set(t, {
                  id: t,
                  topic: r,
                  params: i,
                  verifyContext: s,
                });
            }),
            h7(this, "sendRequest", async (e) => {
              let t,
                i,
                {
                  topic: s,
                  method: n,
                  params: a,
                  expiry: o,
                  relayRpcId: c,
                  clientRpcId: l,
                  throwOnFailedPublish: u,
                  appLink: d,
                  tvf: h,
                } = e,
                p = lN(n, a, l),
                f = !!d;
              try {
                let e = f ? cO : cT;
                t = await this.client.core.crypto.encode(s, p, { encoding: e });
              } catch (e) {
                throw (
                  (await this.cleanup(),
                  this.client.logger.error(
                    `sendRequest() -> core.crypto.encode() for topic ${s} failed`
                  ),
                  e)
                );
              }
              if (hJ.includes(n)) {
                let e = ck(JSON.stringify(p)),
                  r = ck(t);
                i = await this.client.core.verify.register({
                  id: r,
                  decryptedId: e,
                });
              }
              let g = hK[n].req;
              if (
                ((g.attestation = i),
                o && (g.ttl = o),
                c && (g.id = c),
                this.client.core.history.set(s, p),
                f)
              ) {
                let e = cz(d, s, t);
                await r.g.Linking.openURL(e, this.client.name);
              } else {
                let e = hK[n].req;
                o && (e.ttl = o),
                  c && (e.id = c),
                  (e.tvf = h9(h4({}, h), { correlationId: p.id })),
                  u
                    ? ((e.internal = h9(h4({}, e.internal), {
                        throwOnFailedPublish: !0,
                      })),
                      await this.client.core.relayer.publish(s, t, e))
                    : this.client.core.relayer
                        .publish(s, t, e)
                        .catch((e) => this.client.logger.error(e));
              }
              return p.id;
            }),
            h7(this, "sendResult", async (e) => {
              let t,
                i,
                s,
                {
                  id: n,
                  topic: a,
                  result: o,
                  throwOnFailedPublish: c,
                  encodeOpts: l,
                  appLink: u,
                } = e,
                d = lT(n, o),
                h = u && "u" > typeof (null == r.g ? void 0 : r.g.Linking);
              try {
                let e = h ? cO : cT;
                t = await this.client.core.crypto.encode(
                  a,
                  d,
                  h9(h4({}, l || {}), { encoding: e })
                );
              } catch (e) {
                throw (
                  (await this.cleanup(),
                  this.client.logger.error(
                    `sendResult() -> core.crypto.encode() for topic ${a} failed`
                  ),
                  e)
                );
              }
              try {
                let e = (i = await this.client.core.history.get(a, n)).request;
                try {
                  this.shouldSetTVF(e.method, e.params) &&
                    (s = this.getTVFParams(n, e.params, o));
                } catch (e) {
                  this.client.logger.warn(
                    "sendResult() -> getTVFParams() failed",
                    e
                  );
                }
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    `sendResult() -> history.get(${a}, ${n}) failed`
                  ),
                  e)
                );
              }
              if (h) {
                let e = cz(u, a, t);
                await r.g.Linking.openURL(e, this.client.name);
              } else {
                let e = hK[i.request.method].res;
                (e.tvf = h9(h4({}, s), { correlationId: n })),
                  c
                    ? ((e.internal = h9(h4({}, e.internal), {
                        throwOnFailedPublish: !0,
                      })),
                      await this.client.core.relayer.publish(a, t, e))
                    : this.client.core.relayer
                        .publish(a, t, e)
                        .catch((e) => this.client.logger.error(e));
              }
              await this.client.core.history.resolve(d);
            }),
            h7(this, "sendError", async (e) => {
              let t,
                i,
                {
                  id: s,
                  topic: n,
                  error: a,
                  encodeOpts: o,
                  rpcOpts: c,
                  appLink: l,
                } = e,
                u = lO(s, a),
                d = l && "u" > typeof (null == r.g ? void 0 : r.g.Linking);
              try {
                let e = d ? cO : cT;
                t = await this.client.core.crypto.encode(
                  n,
                  u,
                  h9(h4({}, o || {}), { encoding: e })
                );
              } catch (e) {
                throw (
                  (await this.cleanup(),
                  this.client.logger.error(
                    `sendError() -> core.crypto.encode() for topic ${n} failed`
                  ),
                  e)
                );
              }
              try {
                i = await this.client.core.history.get(n, s);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    `sendError() -> history.get(${n}, ${s}) failed`
                  ),
                  e)
                );
              }
              if (d) {
                let e = cz(l, n, t);
                await r.g.Linking.openURL(e, this.client.name);
              } else {
                let e = i.request.method,
                  r = c || hK[e].res;
                this.client.core.relayer.publish(n, t, r);
              }
              await this.client.core.history.resolve(u);
            }),
            h7(this, "cleanup", async () => {
              let e = [],
                t = [];
              this.client.session.getAll().forEach((t) => {
                let r = !1;
                nD(t.expiry) && (r = !0),
                  this.client.core.crypto.keychain.has(t.topic) || (r = !0),
                  r && e.push(t.topic);
              }),
                this.client.proposal.getAll().forEach((e) => {
                  nD(e.expiryTimestamp) && t.push(e.id);
                }),
                await Promise.all([
                  ...e.map((e) => this.deleteSession({ topic: e })),
                  ...t.map((e) => this.deleteProposal(e)),
                ]);
            }),
            h7(this, "onProviderMessageEvent", async (e) => {
              !this.initialized || this.relayMessageCache.length > 0
                ? this.relayMessageCache.push(e)
                : await this.onRelayMessage(e);
            }),
            h7(this, "onRelayEventRequest", async (e) => {
              this.requestQueue.queue.push(e),
                await this.processRequestsQueue();
            }),
            h7(this, "processRequestsQueue", async () => {
              if (this.requestQueue.state === hY.active)
                return void this.client.logger.info(
                  "Request queue already active, skipping..."
                );
              for (
                this.client.logger.info(
                  `Request queue starting with ${this.requestQueue.queue.length} requests`
                );
                this.requestQueue.queue.length > 0;

              ) {
                this.requestQueue.state = hY.active;
                let e = this.requestQueue.queue.shift();
                if (e)
                  try {
                    await this.processRequest(e);
                  } catch (e) {
                    this.client.logger.warn(e);
                  }
              }
              this.requestQueue.state = hY.idle;
            }),
            h7(this, "processRequest", async (e) => {
              let {
                  topic: t,
                  payload: r,
                  attestation: i,
                  transportType: s,
                  encryptedId: n,
                } = e,
                a = r.method;
              if (
                !this.shouldIgnorePairingRequest({ topic: t, requestMethod: a })
              )
                switch (a) {
                  case "wc_sessionPropose":
                    return await this.onSessionProposeRequest({
                      topic: t,
                      payload: r,
                      attestation: i,
                      encryptedId: n,
                    });
                  case "wc_sessionSettle":
                    return await this.onSessionSettleRequest(t, r);
                  case "wc_sessionUpdate":
                    return await this.onSessionUpdateRequest(t, r);
                  case "wc_sessionExtend":
                    return await this.onSessionExtendRequest(t, r);
                  case "wc_sessionPing":
                    return await this.onSessionPingRequest(t, r);
                  case "wc_sessionDelete":
                    return await this.onSessionDeleteRequest(t, r);
                  case "wc_sessionRequest":
                    return await this.onSessionRequest({
                      topic: t,
                      payload: r,
                      attestation: i,
                      encryptedId: n,
                      transportType: s,
                    });
                  case "wc_sessionEvent":
                    return await this.onSessionEventRequest(t, r);
                  case "wc_sessionAuthenticate":
                    return await this.onSessionAuthenticateRequest({
                      topic: t,
                      payload: r,
                      attestation: i,
                      encryptedId: n,
                      transportType: s,
                    });
                  default:
                    return this.client.logger.info(
                      `Unsupported request method ${a}`
                    );
                }
            }),
            h7(this, "onRelayEventResponse", async (e) => {
              let { topic: t, payload: r, transportType: i } = e,
                s = (await this.client.core.history.get(t, r.id)).request
                  .method;
              switch (s) {
                case "wc_sessionPropose":
                  return this.onSessionProposeResponse(t, r, i);
                case "wc_sessionSettle":
                  return this.onSessionSettleResponse(t, r);
                case "wc_sessionUpdate":
                  return this.onSessionUpdateResponse(t, r);
                case "wc_sessionExtend":
                  return this.onSessionExtendResponse(t, r);
                case "wc_sessionPing":
                  return this.onSessionPingResponse(t, r);
                case "wc_sessionRequest":
                  return this.onSessionRequestResponse(t, r);
                case "wc_sessionAuthenticate":
                  return this.onSessionAuthenticateResponse(t, r);
                default:
                  return this.client.logger.info(
                    `Unsupported response method ${s}`
                  );
              }
            }),
            h7(this, "onRelayEventUnknownPayload", (e) => {
              let { topic: t } = e,
                { message: r } = c9(
                  "MISSING_OR_INVALID",
                  `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`
                );
              throw Error(r);
            }),
            h7(this, "shouldIgnorePairingRequest", (e) => {
              let { topic: t, requestMethod: r } = e,
                i = this.expectedPairingMethodMap.get(t);
              return (
                !(!i || i.includes(r)) &&
                !!(
                  i.includes("wc_sessionAuthenticate") &&
                  this.client.events.listenerCount("session_authenticate") > 0
                )
              );
            }),
            h7(this, "onSessionProposeRequest", async (e) => {
              let { topic: t, payload: r, attestation: i, encryptedId: s } = e,
                { params: n, id: a } = r;
              try {
                let e = this.client.core.eventClient.getEvent({ topic: t });
                0 === this.client.events.listenerCount("session_proposal") &&
                  (console.warn("No listener for session_proposal event"),
                  e?.setError(uo.proposal_listener_not_found)),
                  this.isValidConnect(h4({}, r.params));
                let o = n.expiryTimestamp || nk(hK.wc_sessionPropose.req.ttl),
                  c = h4({ id: a, pairingTopic: t, expiryTimestamp: o }, n);
                await this.setProposal(a, c);
                let l = await this.getVerifyContext({
                  attestationId: i,
                  hash: ck(JSON.stringify(r)),
                  encryptedId: s,
                  metadata: c.proposer.metadata,
                });
                e?.addTrace(ua.emit_session_proposal),
                  this.client.events.emit("session_proposal", {
                    id: a,
                    params: c,
                    verifyContext: l,
                  });
              } catch (e) {
                await this.sendError({
                  id: a,
                  topic: t,
                  error: e,
                  rpcOpts: hK.wc_sessionPropose.autoReject,
                }),
                  this.client.logger.error(e);
              }
            }),
            h7(this, "onSessionProposeResponse", async (e, t, r) => {
              let { id: i } = t;
              if (l$(t)) {
                let { result: s } = t;
                this.client.logger.trace({
                  type: "method",
                  method: "onSessionProposeResponse",
                  result: s,
                });
                let n = this.client.proposal.get(i);
                this.client.logger.trace({
                  type: "method",
                  method: "onSessionProposeResponse",
                  proposal: n,
                });
                let a = n.proposer.publicKey;
                this.client.logger.trace({
                  type: "method",
                  method: "onSessionProposeResponse",
                  selfPublicKey: a,
                });
                let o = s.responderPublicKey;
                this.client.logger.trace({
                  type: "method",
                  method: "onSessionProposeResponse",
                  peerPublicKey: o,
                });
                let c = await this.client.core.crypto.generateSharedKey(a, o);
                this.pendingSessions.set(i, {
                  sessionTopic: c,
                  pairingTopic: e,
                  proposalId: i,
                  publicKey: a,
                });
                let l = await this.client.core.relayer.subscribe(c, {
                  transportType: r,
                });
                this.client.logger.trace({
                  type: "method",
                  method: "onSessionProposeResponse",
                  subscriptionId: l,
                }),
                  await this.client.core.pairing.activate({ topic: e });
              } else if (lB(t)) {
                await this.client.proposal.delete(i, c7("USER_DISCONNECTED"));
                let e = nU("session_connect", i);
                if (0 === this.events.listenerCount(e))
                  throw Error(`emitting ${e} without any listeners, 954`);
                this.events.emit(e, { error: t.error });
              }
            }),
            h7(this, "onSessionSettleRequest", async (e, t) => {
              let { id: r, params: i } = t;
              try {
                this.isValidSessionSettleRequest(i);
                let {
                    relay: r,
                    controller: s,
                    expiry: n,
                    namespaces: a,
                    sessionProperties: o,
                    scopedProperties: c,
                    sessionConfig: l,
                  } = t.params,
                  u = [...this.pendingSessions.values()].find(
                    (t) => t.sessionTopic === e
                  );
                if (!u)
                  return this.client.logger.error(
                    `Pending session not found for topic ${e}`
                  );
                let d = this.client.proposal.get(u.proposalId),
                  h = h9(
                    h4(
                      h4(
                        h4(
                          {
                            topic: e,
                            relay: r,
                            expiry: n,
                            namespaces: a,
                            acknowledged: !0,
                            pairingTopic: u.pairingTopic,
                            requiredNamespaces: d.requiredNamespaces,
                            optionalNamespaces: d.optionalNamespaces,
                            controller: s.publicKey,
                            self: {
                              publicKey: u.publicKey,
                              metadata: this.client.metadata,
                            },
                            peer: {
                              publicKey: s.publicKey,
                              metadata: s.metadata,
                            },
                          },
                          o && { sessionProperties: o }
                        ),
                        c && { scopedProperties: c }
                      ),
                      l && { sessionConfig: l }
                    ),
                    { transportType: l8.relay }
                  );
                await this.client.session.set(h.topic, h),
                  await this.setExpiry(h.topic, h.expiry),
                  await this.client.core.pairing.updateMetadata({
                    topic: u.pairingTopic,
                    metadata: h.peer.metadata,
                  }),
                  this.client.events.emit("session_connect", { session: h }),
                  this.events.emit(nU("session_connect", u.proposalId), {
                    session: h,
                  }),
                  this.pendingSessions.delete(u.proposalId),
                  this.deleteProposal(u.proposalId, !1),
                  this.cleanupDuplicatePairings(h),
                  await this.sendResult({
                    id: t.id,
                    topic: e,
                    result: !0,
                    throwOnFailedPublish: !0,
                  });
              } catch (t) {
                await this.sendError({ id: r, topic: e, error: t }),
                  this.client.logger.error(t);
              }
            }),
            h7(this, "onSessionSettleResponse", async (e, t) => {
              let { id: r } = t;
              l$(t)
                ? (await this.client.session.update(e, { acknowledged: !0 }),
                  this.events.emit(nU("session_approve", r), {}))
                : lB(t) &&
                  (await this.client.session.delete(e, c7("USER_DISCONNECTED")),
                  this.events.emit(nU("session_approve", r), {
                    error: t.error,
                  }));
            }),
            h7(this, "onSessionUpdateRequest", async (e, t) => {
              let { params: r, id: i } = t;
              try {
                let t = `${e}_session_update`,
                  s = ly.get(t);
                if (s && this.isRequestOutOfSync(s, i)) {
                  this.client.logger.warn(
                    `Discarding out of sync request - ${i}`
                  ),
                    this.sendError({
                      id: i,
                      topic: e,
                      error: c7("INVALID_UPDATE_REQUEST"),
                    });
                  return;
                }
                this.isValidUpdate(h4({ topic: e }, r));
                try {
                  ly.set(t, i),
                    await this.client.session.update(e, {
                      namespaces: r.namespaces,
                    }),
                    await this.sendResult({
                      id: i,
                      topic: e,
                      result: !0,
                      throwOnFailedPublish: !0,
                    });
                } catch (e) {
                  throw (ly.delete(t), e);
                }
                this.client.events.emit("session_update", {
                  id: i,
                  topic: e,
                  params: r,
                });
              } catch (t) {
                await this.sendError({ id: i, topic: e, error: t }),
                  this.client.logger.error(t);
              }
            }),
            h7(
              this,
              "isRequestOutOfSync",
              (e, t) => t.toString().slice(0, -3) < e.toString().slice(0, -3)
            ),
            h7(this, "onSessionUpdateResponse", (e, t) => {
              let { id: r } = t,
                i = nU("session_update", r);
              if (0 === this.events.listenerCount(i))
                throw Error(`emitting ${i} without any listeners`);
              l$(t)
                ? this.events.emit(nU("session_update", r), {})
                : lB(t) &&
                  this.events.emit(nU("session_update", r), { error: t.error });
            }),
            h7(this, "onSessionExtendRequest", async (e, t) => {
              let { id: r } = t;
              try {
                this.isValidExtend({ topic: e }),
                  await this.setExpiry(e, nk(hV)),
                  await this.sendResult({
                    id: r,
                    topic: e,
                    result: !0,
                    throwOnFailedPublish: !0,
                  }),
                  this.client.events.emit("session_extend", {
                    id: r,
                    topic: e,
                  });
              } catch (t) {
                await this.sendError({ id: r, topic: e, error: t }),
                  this.client.logger.error(t);
              }
            }),
            h7(this, "onSessionExtendResponse", (e, t) => {
              let { id: r } = t,
                i = nU("session_extend", r);
              if (0 === this.events.listenerCount(i))
                throw Error(`emitting ${i} without any listeners`);
              l$(t)
                ? this.events.emit(nU("session_extend", r), {})
                : lB(t) &&
                  this.events.emit(nU("session_extend", r), { error: t.error });
            }),
            h7(this, "onSessionPingRequest", async (e, t) => {
              let { id: r } = t;
              try {
                this.isValidPing({ topic: e }),
                  await this.sendResult({
                    id: r,
                    topic: e,
                    result: !0,
                    throwOnFailedPublish: !0,
                  }),
                  this.client.events.emit("session_ping", { id: r, topic: e });
              } catch (t) {
                await this.sendError({ id: r, topic: e, error: t }),
                  this.client.logger.error(t);
              }
            }),
            h7(this, "onSessionPingResponse", (e, t) => {
              let { id: r } = t,
                i = nU("session_ping", r);
              setTimeout(() => {
                if (0 === this.events.listenerCount(i))
                  throw Error(`emitting ${i} without any listeners 2176`);
                l$(t)
                  ? this.events.emit(nU("session_ping", r), {})
                  : lB(t) &&
                    this.events.emit(nU("session_ping", r), { error: t.error });
              }, 500);
            }),
            h7(this, "onSessionDeleteRequest", async (e, t) => {
              let { id: r } = t;
              try {
                this.isValidDisconnect({ topic: e, reason: t.params }),
                  Promise.all([
                    new Promise((t) => {
                      this.client.core.relayer.once(l2.publish, async () => {
                        t(await this.deleteSession({ topic: e, id: r }));
                      });
                    }),
                    this.sendResult({
                      id: r,
                      topic: e,
                      result: !0,
                      throwOnFailedPublish: !0,
                    }),
                    this.cleanupPendingSentRequestsForTopic({
                      topic: e,
                      error: c7("USER_DISCONNECTED"),
                    }),
                  ]).catch((e) => this.client.logger.error(e));
              } catch (e) {
                this.client.logger.error(e);
              }
            }),
            h7(this, "onSessionRequest", async (e) => {
              var t, r, i;
              let {
                  topic: s,
                  payload: n,
                  attestation: a,
                  encryptedId: o,
                  transportType: c,
                } = e,
                { id: l, params: u } = n;
              try {
                await this.isValidRequest(h4({ topic: s }, u));
                let e = this.client.session.get(s),
                  n = await this.getVerifyContext({
                    attestationId: a,
                    hash: ck(JSON.stringify(lN("wc_sessionRequest", u, l))),
                    encryptedId: o,
                    metadata: e.peer.metadata,
                    transportType: c,
                  }),
                  d = { id: l, topic: s, params: u, verifyContext: n };
                await this.setPendingSessionRequest(d),
                  c === l8.link_mode &&
                    null != (t = e.peer.metadata.redirect) &&
                    t.universal &&
                    this.client.core.addLinkModeSupportedApp(
                      null == (r = e.peer.metadata.redirect)
                        ? void 0
                        : r.universal
                    ),
                  null != (i = this.client.signConfig) && i.disableRequestQueue
                    ? this.emitSessionRequest(d)
                    : (this.addSessionRequestToSessionRequestQueue(d),
                      this.processSessionRequestQueue());
              } catch (e) {
                await this.sendError({ id: l, topic: s, error: e }),
                  this.client.logger.error(e);
              }
            }),
            h7(this, "onSessionRequestResponse", (e, t) => {
              let { id: r } = t,
                i = nU("session_request", r);
              if (0 === this.events.listenerCount(i))
                throw Error(`emitting ${i} without any listeners`);
              l$(t)
                ? this.events.emit(nU("session_request", r), {
                    result: t.result,
                  })
                : lB(t) &&
                  this.events.emit(nU("session_request", r), {
                    error: t.error,
                  });
            }),
            h7(this, "onSessionEventRequest", async (e, t) => {
              let { id: r, params: i } = t;
              try {
                let t = `${e}_session_event_${i.event.name}`,
                  s = ly.get(t);
                if (s && this.isRequestOutOfSync(s, r))
                  return void this.client.logger.info(
                    `Discarding out of sync request - ${r}`
                  );
                this.isValidEmit(h4({ topic: e }, i)),
                  this.client.events.emit("session_event", {
                    id: r,
                    topic: e,
                    params: i,
                  }),
                  ly.set(t, r);
              } catch (t) {
                await this.sendError({ id: r, topic: e, error: t }),
                  this.client.logger.error(t);
              }
            }),
            h7(this, "onSessionAuthenticateResponse", (e, t) => {
              let { id: r } = t;
              this.client.logger.trace({
                type: "method",
                method: "onSessionAuthenticateResponse",
                topic: e,
                payload: t,
              }),
                l$(t)
                  ? this.events.emit(nU("session_request", r), {
                      result: t.result,
                    })
                  : lB(t) &&
                    this.events.emit(nU("session_request", r), {
                      error: t.error,
                    });
            }),
            h7(this, "onSessionAuthenticateRequest", async (e) => {
              var t;
              let {
                topic: r,
                payload: i,
                attestation: s,
                encryptedId: n,
                transportType: a,
              } = e;
              try {
                let {
                    requester: e,
                    authPayload: o,
                    expiryTimestamp: c,
                  } = i.params,
                  l = await this.getVerifyContext({
                    attestationId: s,
                    hash: ck(JSON.stringify(i)),
                    encryptedId: n,
                    metadata: e.metadata,
                    transportType: a,
                  }),
                  u = {
                    requester: e,
                    pairingTopic: r,
                    id: i.id,
                    authPayload: o,
                    verifyContext: l,
                    expiryTimestamp: c,
                  };
                await this.setAuthRequest(i.id, {
                  request: u,
                  pairingTopic: r,
                  transportType: a,
                }),
                  a === l8.link_mode &&
                    null != (t = e.metadata.redirect) &&
                    t.universal &&
                    this.client.core.addLinkModeSupportedApp(
                      e.metadata.redirect.universal
                    ),
                  this.client.events.emit("session_authenticate", {
                    topic: r,
                    params: i.params,
                    id: i.id,
                    verifyContext: l,
                  });
              } catch (n) {
                this.client.logger.error(n);
                let e = i.params.requester.publicKey,
                  t = await this.client.core.crypto.generateKeyPair(),
                  s = this.getAppLinkIfEnabled(i.params.requester.metadata, a);
                await this.sendError({
                  id: i.id,
                  topic: r,
                  error: n,
                  encodeOpts: {
                    type: 1,
                    receiverPublicKey: e,
                    senderPublicKey: t,
                  },
                  rpcOpts: hK.wc_sessionAuthenticate.autoReject,
                  appLink: s,
                });
              }
            }),
            h7(this, "addSessionRequestToSessionRequestQueue", (e) => {
              this.sessionRequestQueue.queue.push(e);
            }),
            h7(this, "cleanupAfterResponse", (e) => {
              this.deletePendingSessionRequest(e.response.id, {
                message: "fulfilled",
                code: 0,
              }),
                setTimeout(() => {
                  (this.sessionRequestQueue.state = hY.idle),
                    this.processSessionRequestQueue();
                }, (0, v.toMiliseconds)(this.requestQueueDelay));
            }),
            h7(
              this,
              "cleanupPendingSentRequestsForTopic",
              ({ topic: e, error: t }) => {
                let r = this.client.core.history.pending;
                r.length > 0 &&
                  r
                    .filter(
                      (t) =>
                        t.topic === e &&
                        "wc_sessionRequest" === t.request.method
                    )
                    .forEach((e) => {
                      let r = nU("session_request", e.request.id);
                      if (0 === this.events.listenerCount(r))
                        throw Error(`emitting ${r} without any listeners`);
                      this.events.emit(nU("session_request", e.request.id), {
                        error: t,
                      });
                    });
              }
            ),
            h7(this, "processSessionRequestQueue", () => {
              if (this.sessionRequestQueue.state === hY.active)
                return void this.client.logger.info(
                  "session request queue is already active."
                );
              let e = this.sessionRequestQueue.queue[0];
              if (!e)
                return void this.client.logger.info(
                  "session request queue is empty."
                );
              try {
                (this.sessionRequestQueue.state = hY.active),
                  this.emitSessionRequest(e);
              } catch (e) {
                this.client.logger.error(e);
              }
            }),
            h7(this, "emitSessionRequest", (e) => {
              this.client.events.emit("session_request", e);
            }),
            h7(this, "onPairingCreated", (e) => {
              if (
                (e.methods &&
                  this.expectedPairingMethodMap.set(e.topic, e.methods),
                e.active)
              )
                return;
              let t = this.client.proposal
                .getAll()
                .find((t) => t.pairingTopic === e.topic);
              t &&
                this.onSessionProposeRequest({
                  topic: e.topic,
                  payload: lN(
                    "wc_sessionPropose",
                    h9(h4({}, t), {
                      requiredNamespaces: t.requiredNamespaces,
                      optionalNamespaces: t.optionalNamespaces,
                      relays: t.relays,
                      proposer: t.proposer,
                      sessionProperties: t.sessionProperties,
                      scopedProperties: t.scopedProperties,
                    }),
                    t.id
                  ),
                });
            }),
            h7(this, "isValidConnect", async (e) => {
              if (!lu(e)) {
                let { message: t } = c9(
                  "MISSING_OR_INVALID",
                  `connect() params: ${JSON.stringify(e)}`
                );
                throw Error(t);
              }
              let {
                pairingTopic: t,
                requiredNamespaces: r,
                optionalNamespaces: i,
                sessionProperties: s,
                scopedProperties: n,
                relays: a,
              } = e;
              if (
                (lr(t) || (await this.isValidPairingTopic(t)),
                !(function (e, t) {
                  let r = !1;
                  return (
                    t && !e
                      ? (r = !0)
                      : e &&
                        le(e) &&
                        e.length &&
                        e.forEach((e) => {
                          r = ll(e);
                        }),
                    r
                  );
                })(a, !0))
              ) {
                let { message: e } = c9(
                  "MISSING_OR_INVALID",
                  `connect() relays: ${a}`
                );
                throw Error(e);
              }
              if (!lr(r) && 0 !== lt(r)) {
                let e =
                  "requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";
                ["fatal", "error", "silent"].includes(this.client.logger.level)
                  ? console.warn(e)
                  : this.client.logger.warn(e),
                  this.validateNamespaces(r, "requiredNamespaces");
              }
              if (
                (lr(i) ||
                  0 === lt(i) ||
                  this.validateNamespaces(i, "optionalNamespaces"),
                lr(s) || this.validateSessionProps(s, "sessionProperties"),
                !lr(n))
              ) {
                this.validateSessionProps(n, "scopedProperties");
                let e = Object.keys(r || {}).concat(Object.keys(i || {}));
                if (!Object.keys(n).every((t) => e.includes(t)))
                  throw Error(
                    `Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(
                      n
                    )}, required/optional namespaces: ${JSON.stringify(e)}`
                  );
              }
            }),
            h7(this, "validateNamespaces", (e, t) => {
              let r = (function (e, t, r) {
                let i = null;
                if (e && lt(e)) {
                  let s,
                    n = lo(e, t);
                  n && (i = n);
                  let a =
                    ((s = null),
                    Object.entries(e).forEach(([e, i]) => {
                      var n, a;
                      let o;
                      if (s) return;
                      let c =
                        ((n = nc(e, i)),
                        (a = `${t} ${r}`),
                        (o = null),
                        le(n) && n.length
                          ? n.forEach((e) => {
                              o ||
                                ln(e) ||
                                (o = c7(
                                  "UNSUPPORTED_CHAINS",
                                  `${a}, chain ${e} should be a string and conform to "namespace:chainId" format`
                                ));
                            })
                          : ln(e) ||
                            (o = c7(
                              "UNSUPPORTED_CHAINS",
                              `${a}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`
                            )),
                        o);
                      c && (s = c);
                    }),
                    s);
                  a && (i = a);
                } else
                  i = c9(
                    "MISSING_OR_INVALID",
                    `${t}, ${r} should be an object with data`
                  );
                return i;
              })(e, "connect()", t);
              if (r) throw Error(r.message);
            }),
            h7(this, "isValidApprove", async (e) => {
              if (!lu(e))
                throw Error(
                  c9("MISSING_OR_INVALID", `approve() params: ${e}`).message
                );
              let {
                id: t,
                namespaces: r,
                relayProtocol: i,
                sessionProperties: s,
                scopedProperties: n,
              } = e;
              this.checkRecentlyDeleted(t), await this.isValidProposalId(t);
              let a = this.client.proposal.get(t),
                o = lc(r, "approve()");
              if (o) throw Error(o.message);
              let c = lh(a.requiredNamespaces, r, "approve()");
              if (c) throw Error(c.message);
              if (!li(i, !0)) {
                let { message: e } = c9(
                  "MISSING_OR_INVALID",
                  `approve() relayProtocol: ${i}`
                );
                throw Error(e);
              }
              if (
                (lr(s) || this.validateSessionProps(s, "sessionProperties"),
                !lr(n))
              ) {
                this.validateSessionProps(n, "scopedProperties");
                let e = new Set(Object.keys(r));
                if (!Object.keys(n).every((t) => e.has(t)))
                  throw Error(
                    `Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(
                      n
                    )}, approved namespaces: ${Array.from(e).join(", ")}`
                  );
              }
            }),
            h7(this, "isValidReject", async (e) => {
              if (!lu(e)) {
                let { message: t } = c9(
                  "MISSING_OR_INVALID",
                  `reject() params: ${e}`
                );
                throw Error(t);
              }
              let { id: t, reason: r } = e;
              if (
                (this.checkRecentlyDeleted(t),
                await this.isValidProposalId(t),
                !(function (e) {
                  return !(
                    !e ||
                    "object" != typeof e ||
                    !e.code ||
                    !ls(e.code, !1) ||
                    !e.message ||
                    !li(e.message, !1)
                  );
                })(r))
              ) {
                let { message: e } = c9(
                  "MISSING_OR_INVALID",
                  `reject() reason: ${JSON.stringify(r)}`
                );
                throw Error(e);
              }
            }),
            h7(this, "isValidSessionSettleRequest", (e) => {
              if (!lu(e)) {
                let { message: t } = c9(
                  "MISSING_OR_INVALID",
                  `onSessionSettleRequest() params: ${e}`
                );
                throw Error(t);
              }
              let { relay: t, controller: r, namespaces: i, expiry: s } = e;
              if (!ll(t)) {
                let { message: e } = c9(
                  "MISSING_OR_INVALID",
                  "onSessionSettleRequest() relay protocol should be a string"
                );
                throw Error(e);
              }
              let n = (function (e, t) {
                let r = null;
                return (
                  li(e?.publicKey, !1) ||
                    (r = c9(
                      "MISSING_OR_INVALID",
                      `${t} controller public key should be a string`
                    )),
                  r
                );
              })(r, "onSessionSettleRequest()");
              if (n) throw Error(n.message);
              let a = lc(i, "onSessionSettleRequest()");
              if (a) throw Error(a.message);
              if (nD(s)) {
                let { message: e } = c9("EXPIRED", "onSessionSettleRequest()");
                throw Error(e);
              }
            }),
            h7(this, "isValidUpdate", async (e) => {
              if (!lu(e)) {
                let { message: t } = c9(
                  "MISSING_OR_INVALID",
                  `update() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t, namespaces: r } = e;
              this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
              let i = this.client.session.get(t),
                s = lc(r, "update()");
              if (s) throw Error(s.message);
              let n = lh(i.requiredNamespaces, r, "update()");
              if (n) throw Error(n.message);
            }),
            h7(this, "isValidExtend", async (e) => {
              if (!lu(e)) {
                let { message: t } = c9(
                  "MISSING_OR_INVALID",
                  `extend() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t } = e;
              this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
            }),
            h7(this, "isValidRequest", async (e) => {
              if (!lu(e)) {
                let { message: t } = c9(
                  "MISSING_OR_INVALID",
                  `request() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t, request: r, chainId: i, expiry: s } = e;
              this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
              let { namespaces: n } = this.client.session.get(t);
              if (!ld(n, i)) {
                let { message: e } = c9(
                  "MISSING_OR_INVALID",
                  `request() chainId: ${i}`
                );
                throw Error(e);
              }
              if (
                !(function (e) {
                  return !(lr(e) || !li(e.method, !1));
                })(r)
              ) {
                let { message: e } = c9(
                  "MISSING_OR_INVALID",
                  `request() ${JSON.stringify(r)}`
                );
                throw Error(e);
              }
              if (
                !(function (e, t, r) {
                  return (
                    !!li(r, !1) &&
                    (function (e, t) {
                      let r = [];
                      return (
                        Object.values(e).forEach((e) => {
                          c1(e.accounts).includes(t) && r.push(...e.methods);
                        }),
                        r
                      );
                    })(e, t).includes(r)
                  );
                })(n, i, r.method)
              ) {
                let { message: e } = c9(
                  "MISSING_OR_INVALID",
                  `request() method: ${r.method}`
                );
                throw Error(e);
              }
              if (
                s &&
                !(function (e, t) {
                  return ls(e, !1) && e <= t.max && e >= t.min;
                })(s, hG)
              ) {
                let { message: e } = c9(
                  "MISSING_OR_INVALID",
                  `request() expiry: ${s}. Expiry must be a number (in seconds) between ${hG.min} and ${hG.max}`
                );
                throw Error(e);
              }
            }),
            h7(this, "isValidRespond", async (e) => {
              var t;
              if (!lu(e)) {
                let { message: t } = c9(
                  "MISSING_OR_INVALID",
                  `respond() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: r, response: i } = e;
              try {
                await this.isValidSessionTopic(r);
              } catch (r) {
                throw (
                  (null != (t = e?.response) &&
                    t.id &&
                    this.cleanupAfterResponse(e),
                  r)
                );
              }
              if (
                !(function (e) {
                  return !(
                    lr(e) ||
                    (lr(e.result) && lr(e.error)) ||
                    !ls(e.id, !1) ||
                    !li(e.jsonrpc, !1)
                  );
                })(i)
              ) {
                let { message: e } = c9(
                  "MISSING_OR_INVALID",
                  `respond() response: ${JSON.stringify(i)}`
                );
                throw Error(e);
              }
            }),
            h7(this, "isValidPing", async (e) => {
              if (!lu(e)) {
                let { message: t } = c9(
                  "MISSING_OR_INVALID",
                  `ping() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t } = e;
              await this.isValidSessionOrPairingTopic(t);
            }),
            h7(this, "isValidEmit", async (e) => {
              if (!lu(e)) {
                let { message: t } = c9(
                  "MISSING_OR_INVALID",
                  `emit() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t, event: r, chainId: i } = e;
              await this.isValidSessionTopic(t);
              let { namespaces: s } = this.client.session.get(t);
              if (!ld(s, i)) {
                let { message: e } = c9(
                  "MISSING_OR_INVALID",
                  `emit() chainId: ${i}`
                );
                throw Error(e);
              }
              if (
                !(function (e) {
                  return !(lr(e) || !li(e.name, !1));
                })(r) ||
                !(function (e, t, r) {
                  return (
                    !!li(r, !1) &&
                    (function (e, t) {
                      let r = [];
                      return (
                        Object.values(e).forEach((e) => {
                          c1(e.accounts).includes(t) && r.push(...e.events);
                        }),
                        r
                      );
                    })(e, t).includes(r)
                  );
                })(s, i, r.name)
              ) {
                let { message: e } = c9(
                  "MISSING_OR_INVALID",
                  `emit() event: ${JSON.stringify(r)}`
                );
                throw Error(e);
              }
            }),
            h7(this, "isValidDisconnect", async (e) => {
              if (!lu(e)) {
                let { message: t } = c9(
                  "MISSING_OR_INVALID",
                  `disconnect() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t } = e;
              await this.isValidSessionOrPairingTopic(t);
            }),
            h7(this, "isValidAuthenticate", (e) => {
              let { chains: t, uri: r, domain: i, nonce: s } = e;
              if (!Array.isArray(t) || 0 === t.length)
                throw Error("chains is required and must be a non-empty array");
              if (!li(r, !1)) throw Error("uri is required parameter");
              if (!li(i, !1)) throw Error("domain is required parameter");
              if (!li(s, !1)) throw Error("nonce is required parameter");
              if ([...new Set(t.map((e) => na(e).namespace))].length > 1)
                throw Error(
                  "Multi-namespace requests are not supported. Please request single namespace only."
                );
              let { namespace: n } = na(t[0]);
              if ("eip155" !== n)
                throw Error(
                  "Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains."
                );
            }),
            h7(this, "getVerifyContext", async (e) => {
              let {
                  attestationId: t,
                  hash: r,
                  encryptedId: i,
                  metadata: s,
                  transportType: n,
                } = e,
                a = {
                  verified: {
                    verifyUrl: s.verifyUrl || ui,
                    validation: "UNKNOWN",
                    origin: s.url || "",
                  },
                };
              try {
                if (n === l8.link_mode) {
                  let e = this.getAppLinkIfEnabled(s, n);
                  return (
                    (a.verified.validation =
                      e && new URL(e).origin === new URL(s.url).origin
                        ? "VALID"
                        : "INVALID"),
                    a
                  );
                }
                let e = await this.client.core.verify.resolve({
                  attestationId: t,
                  hash: r,
                  encryptedId: i,
                  verifyUrl: s.verifyUrl,
                });
                e &&
                  ((a.verified.origin = e.origin),
                  (a.verified.isScam = e.isScam),
                  (a.verified.validation =
                    e.origin === new URL(s.url).origin ? "VALID" : "INVALID"));
              } catch (e) {
                this.client.logger.warn(e);
              }
              return (
                this.client.logger.debug(
                  `Verify context: ${JSON.stringify(a)}`
                ),
                a
              );
            }),
            h7(this, "validateSessionProps", (e, t) => {
              Object.values(e).forEach((r, i) => {
                if (null == r) {
                  let { message: s } = c9(
                    "MISSING_OR_INVALID",
                    `${t} must contain an existing value for each key. Received: ${r} for key ${
                      Object.keys(e)[i]
                    }`
                  );
                  throw Error(s);
                }
              });
            }),
            h7(this, "getPendingAuthRequest", (e) => {
              let t = this.client.auth.requests.get(e);
              return "object" == typeof t ? t : void 0;
            }),
            h7(this, "addToRecentlyDeleted", (e, t) => {
              if (
                (this.recentlyDeletedMap.set(e, t),
                this.recentlyDeletedMap.size >= this.recentlyDeletedLimit)
              ) {
                let e = 0,
                  t = this.recentlyDeletedLimit / 2;
                for (let r of this.recentlyDeletedMap.keys()) {
                  if (e++ >= t) break;
                  this.recentlyDeletedMap.delete(r);
                }
              }
            }),
            h7(this, "checkRecentlyDeleted", (e) => {
              let t = this.recentlyDeletedMap.get(e);
              if (t) {
                let { message: r } = c9(
                  "MISSING_OR_INVALID",
                  `Record was recently deleted - ${t}: ${e}`
                );
                throw Error(r);
              }
            }),
            h7(this, "isLinkModeEnabled", (e, t) => {
              var i, s, n, a, o, c, l, u, d;
              return (
                !!e &&
                t === l8.link_mode &&
                (null ==
                (s = null == (i = this.client.metadata) ? void 0 : i.redirect)
                  ? void 0
                  : s.linkMode) === !0 &&
                (null ==
                (a = null == (n = this.client.metadata) ? void 0 : n.redirect)
                  ? void 0
                  : a.universal) !== void 0 &&
                (null ==
                (c = null == (o = this.client.metadata) ? void 0 : o.redirect)
                  ? void 0
                  : c.universal) !== "" &&
                (null == (l = e?.redirect) ? void 0 : l.universal) !== void 0 &&
                (null == (u = e?.redirect) ? void 0 : u.universal) !== "" &&
                (null == (d = e?.redirect) ? void 0 : d.linkMode) === !0 &&
                this.client.core.linkModeSupportedApps.includes(
                  e.redirect.universal
                ) &&
                "u" > typeof (null == r.g ? void 0 : r.g.Linking)
              );
            }),
            h7(this, "getAppLinkIfEnabled", (e, t) => {
              var r;
              return this.isLinkModeEnabled(e, t)
                ? null == (r = e?.redirect)
                  ? void 0
                  : r.universal
                : void 0;
            }),
            h7(this, "handleLinkModeMessage", ({ url: e }) => {
              if (!e || !e.includes("wc_ev") || !e.includes("topic")) return;
              let t = n$(e, "topic") || "",
                r = decodeURIComponent(n$(e, "wc_ev") || ""),
                i = this.client.session.keys.includes(t);
              i &&
                this.client.session.update(t, { transportType: l8.link_mode }),
                this.client.core.dispatchEnvelope({
                  topic: t,
                  message: r,
                  sessionExists: i,
                });
            }),
            h7(this, "registerLinkModeListeners", async () => {
              var e;
              if (
                nF() ||
                (nv() &&
                  null != (e = this.client.metadata.redirect) &&
                  e.linkMode)
              ) {
                let e = null == r.g ? void 0 : r.g.Linking;
                if ("u" > typeof e) {
                  e.addEventListener(
                    "url",
                    this.handleLinkModeMessage,
                    this.client.name
                  );
                  let t = await e.getInitialURL();
                  t &&
                    setTimeout(() => {
                      this.handleLinkModeMessage({ url: t });
                    }, 50);
                }
              }
            }),
            h7(this, "shouldSetTVF", (e, t) => {
              if (!t || "wc_sessionRequest" !== e) return !1;
              let { request: r } = t;
              return Object.keys(hZ).includes(r.method);
            }),
            h7(this, "getTVFParams", (e, t, r) => {
              var i, s;
              try {
                let n = t.request.method,
                  a = this.extractTxHashesFromResult(n, r);
                return h9(
                  h4(
                    { correlationId: e, rpcMethods: [n], chainId: t.chainId },
                    this.isValidContractData(t.request.params) && {
                      contractAddresses: [
                        null ==
                        (s = null == (i = t.request.params) ? void 0 : i[0])
                          ? void 0
                          : s.to,
                      ],
                    }
                  ),
                  { txHashes: a }
                );
              } catch (e) {
                this.client.logger.warn("Error getting TVF params", e);
              }
              return {};
            }),
            h7(this, "isValidContractData", (e) => {
              var t;
              if (!e) return !1;
              try {
                let r = e?.data || (null == (t = e?.[0]) ? void 0 : t.data);
                if (!r.startsWith("0x")) return !1;
                let i = r.slice(2);
                return !!/^[0-9a-fA-F]*$/.test(i) && i.length % 2 == 0;
              } catch {}
              return !1;
            }),
            h7(this, "extractTxHashesFromResult", (e, t) => {
              try {
                let r = hZ[e];
                if ("string" == typeof t) return [t];
                let i = t[r.key];
                if (le(i))
                  return "solana_signAllTransactions" === e
                    ? i.map((e) =>
                        (function (e) {
                          let t = atob(e),
                            r = new Uint8Array(t.length);
                          for (let e = 0; e < t.length; e++)
                            r[e] = t.charCodeAt(e);
                          let i = r[0];
                          if (0 === i) throw Error("No signatures found");
                          if (r.length < 1 + 64 * i)
                            throw Error(
                              "Transaction data too short for claimed signature count"
                            );
                          if (r.length < 100)
                            throw Error("Transaction too short");
                          let s = nn.from(e, "base64").slice(1, 65);
                          return i$.A.encode(s);
                        })(e)
                      )
                    : i;
                if ("string" == typeof i) return [i];
              } catch (e) {
                this.client.logger.warn(
                  "Error extracting tx hashes from result",
                  e
                );
              }
              return [];
            });
        }
        async processPendingMessageEvents() {
          try {
            let e = this.client.session.keys,
              t = this.client.core.relayer.messages.getWithoutAck(e);
            for (let [e, r] of Object.entries(t))
              for (let t of r)
                try {
                  await this.onProviderMessageEvent({
                    topic: e,
                    message: t,
                    publishedAt: Date.now(),
                  });
                } catch {
                  this.client.logger.warn(
                    `Error processing pending message event for topic: ${e}, message: ${t}`
                  );
                }
          } catch (e) {
            this.client.logger.warn("processPendingMessageEvents failed", e);
          }
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = c9("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
        async confirmOnlineStateOrThrow() {
          await this.client.core.relayer.confirmOnlineStateOrThrow();
        }
        registerRelayerEvents() {
          this.client.core.relayer.on(l2.message, (e) => {
            this.onProviderMessageEvent(e);
          });
        }
        async onRelayMessage(e) {
          let { topic: t, message: r, attestation: i, transportType: s } = e,
            { publicKey: n } = this.client.auth.authKeys.keys.includes(hQ)
              ? this.client.auth.authKeys.get(hQ)
              : { responseTopic: void 0, publicKey: void 0 };
          try {
            let e = await this.client.core.crypto.decode(t, r, {
              receiverPublicKey: n,
              encoding: s === l8.link_mode ? cO : cT,
            });
            lM(e)
              ? (this.client.core.history.set(t, e),
                await this.onRelayEventRequest({
                  topic: t,
                  payload: e,
                  attestation: i,
                  transportType: s,
                  encryptedId: ck(r),
                }))
              : lj(e)
              ? (await this.client.core.history.resolve(e),
                await this.onRelayEventResponse({
                  topic: t,
                  payload: e,
                  transportType: s,
                }),
                this.client.core.history.delete(t, e.id))
              : await this.onRelayEventUnknownPayload({
                  topic: t,
                  payload: e,
                  transportType: s,
                }),
              await this.client.core.relayer.messages.ack(t, r);
          } catch (e) {
            this.client.logger.error(e);
          }
        }
        registerExpirerEvents() {
          this.client.core.expirer.on(ur.expired, async (e) => {
            let { topic: t, id: r } = nR(e.target);
            return r && this.client.pendingRequest.keys.includes(r)
              ? await this.deletePendingSessionRequest(r, c9("EXPIRED"), !0)
              : r && this.client.auth.requests.keys.includes(r)
              ? await this.deletePendingAuthRequest(r, c9("EXPIRED"), !0)
              : void (t
                  ? this.client.session.keys.includes(t) &&
                    (await this.deleteSession({
                      topic: t,
                      expirerHasDeleted: !0,
                    }),
                    this.client.events.emit("session_expire", { topic: t }))
                  : r &&
                    (await this.deleteProposal(r, !0),
                    this.client.events.emit("proposal_expire", { id: r })));
          });
        }
        registerPairingEvents() {
          this.client.core.pairing.events.on(ue.create, (e) =>
            this.onPairingCreated(e)
          ),
            this.client.core.pairing.events.on(ue.delete, (e) => {
              this.addToRecentlyDeleted(e.topic, "pairing");
            });
        }
        isValidPairingTopic(e) {
          if (!li(e, !1)) {
            let { message: t } = c9(
              "MISSING_OR_INVALID",
              `pairing topic should be a string: ${e}`
            );
            throw Error(t);
          }
          if (!this.client.core.pairing.pairings.keys.includes(e)) {
            let { message: t } = c9(
              "NO_MATCHING_KEY",
              `pairing topic doesn't exist: ${e}`
            );
            throw Error(t);
          }
          if (nD(this.client.core.pairing.pairings.get(e).expiry)) {
            let { message: t } = c9("EXPIRED", `pairing topic: ${e}`);
            throw Error(t);
          }
        }
        async isValidSessionTopic(e) {
          if (!li(e, !1)) {
            let { message: t } = c9(
              "MISSING_OR_INVALID",
              `session topic should be a string: ${e}`
            );
            throw Error(t);
          }
          if (
            (this.checkRecentlyDeleted(e),
            !this.client.session.keys.includes(e))
          ) {
            let { message: t } = c9(
              "NO_MATCHING_KEY",
              `session topic doesn't exist: ${e}`
            );
            throw Error(t);
          }
          if (nD(this.client.session.get(e).expiry)) {
            await this.deleteSession({ topic: e });
            let { message: t } = c9("EXPIRED", `session topic: ${e}`);
            throw Error(t);
          }
          if (!this.client.core.crypto.keychain.has(e)) {
            let { message: t } = c9(
              "MISSING_OR_INVALID",
              `session topic does not exist in keychain: ${e}`
            );
            throw (await this.deleteSession({ topic: e }), Error(t));
          }
        }
        async isValidSessionOrPairingTopic(e) {
          if (
            (this.checkRecentlyDeleted(e), this.client.session.keys.includes(e))
          )
            await this.isValidSessionTopic(e);
          else if (this.client.core.pairing.pairings.keys.includes(e))
            this.isValidPairingTopic(e);
          else if (li(e, !1)) {
            let { message: t } = c9(
              "NO_MATCHING_KEY",
              `session or pairing topic doesn't exist: ${e}`
            );
            throw Error(t);
          } else {
            let { message: t } = c9(
              "MISSING_OR_INVALID",
              `session or pairing topic should be a string: ${e}`
            );
            throw Error(t);
          }
        }
        async isValidProposalId(e) {
          if ("number" != typeof e) {
            let { message: t } = c9(
              "MISSING_OR_INVALID",
              `proposal id should be a number: ${e}`
            );
            throw Error(t);
          }
          if (!this.client.proposal.keys.includes(e)) {
            let { message: t } = c9(
              "NO_MATCHING_KEY",
              `proposal id doesn't exist: ${e}`
            );
            throw Error(t);
          }
          if (nD(this.client.proposal.get(e).expiryTimestamp)) {
            await this.deleteProposal(e);
            let { message: t } = c9("EXPIRED", `proposal id: ${e}`);
            throw Error(t);
          }
        }
      }
      class pt extends hs {
        constructor(e, t) {
          super(e, t, "proposal", hW), (this.core = e), (this.logger = t);
        }
      }
      class pr extends hs {
        constructor(e, t) {
          super(e, t, "session", hW), (this.core = e), (this.logger = t);
        }
      }
      class pi extends hs {
        constructor(e, t) {
          super(e, t, "request", hW, (e) => e.id),
            (this.core = e),
            (this.logger = t);
        }
      }
      class ps extends hs {
        constructor(e, t) {
          super(e, t, "authKeys", hX, () => hQ),
            (this.core = e),
            (this.logger = t);
        }
      }
      class pn extends hs {
        constructor(e, t) {
          super(e, t, "pairingTopics", hX), (this.core = e), (this.logger = t);
        }
      }
      class pa extends hs {
        constructor(e, t) {
          super(e, t, "requests", hX, (e) => e.id),
            (this.core = e),
            (this.logger = t);
        }
      }
      var po = Object.defineProperty,
        pc = (e, t, r) =>
          t in e
            ? po(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        pl = (e, t, r) => pc(e, "symbol" != typeof t ? t + "" : t, r);
      class pu {
        constructor(e, t) {
          (this.core = e),
            (this.logger = t),
            pl(this, "authKeys"),
            pl(this, "pairingTopics"),
            pl(this, "requests"),
            (this.authKeys = new ps(this.core, this.logger)),
            (this.pairingTopics = new pn(this.core, this.logger)),
            (this.requests = new pa(this.core, this.logger));
        }
        async init() {
          await this.authKeys.init(),
            await this.pairingTopics.init(),
            await this.requests.init();
        }
      }
      var pd = Object.defineProperty,
        ph = (e, t, r) =>
          t in e
            ? pd(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        pp = (e, t, r) => ph(e, "symbol" != typeof t ? t + "" : t, r);
      class pf extends e_ {
        constructor(e) {
          super(e),
            pp(this, "protocol", "wc"),
            pp(this, "version", 2),
            pp(this, "name", hq.name),
            pp(this, "metadata"),
            pp(this, "core"),
            pp(this, "logger"),
            pp(this, "events", new b.EventEmitter()),
            pp(this, "engine"),
            pp(this, "session"),
            pp(this, "proposal"),
            pp(this, "pendingRequest"),
            pp(this, "auth"),
            pp(this, "signConfig"),
            pp(this, "on", (e, t) => this.events.on(e, t)),
            pp(this, "once", (e, t) => this.events.once(e, t)),
            pp(this, "off", (e, t) => this.events.off(e, t)),
            pp(this, "removeListener", (e, t) =>
              this.events.removeListener(e, t)
            ),
            pp(this, "removeAllListeners", (e) =>
              this.events.removeAllListeners(e)
            ),
            pp(this, "connect", async (e) => {
              try {
                return await this.engine.connect(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pp(this, "pair", async (e) => {
              try {
                return await this.engine.pair(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pp(this, "approve", async (e) => {
              try {
                return await this.engine.approve(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pp(this, "reject", async (e) => {
              try {
                return await this.engine.reject(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pp(this, "update", async (e) => {
              try {
                return await this.engine.update(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pp(this, "extend", async (e) => {
              try {
                return await this.engine.extend(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pp(this, "request", async (e) => {
              try {
                return await this.engine.request(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pp(this, "respond", async (e) => {
              try {
                return await this.engine.respond(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pp(this, "ping", async (e) => {
              try {
                return await this.engine.ping(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pp(this, "emit", async (e) => {
              try {
                return await this.engine.emit(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pp(this, "disconnect", async (e) => {
              try {
                return await this.engine.disconnect(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pp(this, "find", (e) => {
              try {
                return this.engine.find(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pp(this, "getPendingSessionRequests", () => {
              try {
                return this.engine.getPendingSessionRequests();
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pp(this, "authenticate", async (e, t) => {
              try {
                return await this.engine.authenticate(e, t);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pp(this, "formatAuthMessage", (e) => {
              try {
                return this.engine.formatAuthMessage(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pp(this, "approveSessionAuthenticate", async (e) => {
              try {
                return await this.engine.approveSessionAuthenticate(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pp(this, "rejectSessionAuthenticate", async (e) => {
              try {
                return await this.engine.rejectSessionAuthenticate(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            (this.name = e?.name || hq.name),
            (this.metadata = (function (e) {
              var t, r;
              let i = nA();
              try {
                return (
                  null != e &&
                    e.url &&
                    i.url &&
                    new URL(e.url).host !== new URL(i.url).host &&
                    (console.warn(
                      `The configured WalletConnect 'metadata.url':${e.url} differs from the actual page url:${i.url}. This is probably unintended and can lead to issues.`
                    ),
                    (e.url = i.url)),
                  null != (t = e?.icons) &&
                    t.length &&
                    e.icons.length > 0 &&
                    (e.icons = e.icons.filter((e) => "" !== e)),
                  ny(nm(nm({}, i), e), {
                    url: e?.url || i.url,
                    name: e?.name || i.name,
                    description: e?.description || i.description,
                    icons:
                      null != (r = e?.icons) && r.length && e.icons.length > 0
                        ? e.icons
                        : i.icons,
                  })
                );
              } catch (t) {
                return console.warn("Error populating app metadata", t), e || i;
              }
            })(e?.metadata)),
            (this.signConfig = e?.signConfig);
          let t =
            "u" > typeof e?.logger && "string" != typeof e?.logger
              ? e.logger
              : (0, ee.h6)((0, ee.iP)({ level: e?.logger || hq.logger }));
          (this.core = e?.core || new hB(e)),
            (this.logger = (0, ee.U5)(t, this.name)),
            (this.session = new pr(this.core, this.logger)),
            (this.proposal = new pt(this.core, this.logger)),
            (this.pendingRequest = new pi(this.core, this.logger)),
            (this.engine = new pe(this)),
            (this.auth = new pu(this.core, this.logger));
        }
        static async init(e) {
          let t = new pf(e);
          return await t.initialize(), t;
        }
        get context() {
          return (0, ee.oI)(this.logger);
        }
        get pairing() {
          return this.core.pairing.pairings;
        }
        async initialize() {
          this.logger.trace("Initialized");
          try {
            await this.core.start(),
              await this.session.init(),
              await this.proposal.init(),
              await this.pendingRequest.init(),
              await this.auth.init(),
              await this.engine.init(),
              this.logger.info("SignClient Initialization Success"),
              setTimeout(() => {
                this.engine.processRelayMessageCache();
              }, (0, v.toMiliseconds)(v.ONE_SECOND));
          } catch (e) {
            throw (
              (this.logger.info("SignClient Initialization Failure"),
              this.logger.error(e.message),
              e)
            );
          }
        }
      }
      var pg = r(7599),
        pm = r.n(pg),
        py = Object.defineProperty,
        pb = Object.defineProperties,
        pw = Object.getOwnPropertyDescriptors,
        pv = Object.getOwnPropertySymbols,
        pE = Object.prototype.hasOwnProperty,
        p_ = Object.prototype.propertyIsEnumerable,
        pC = (e, t, r) =>
          t in e
            ? py(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        pA = (e, t) => {
          for (var r in t || (t = {})) pE.call(t, r) && pC(e, r, t[r]);
          if (pv) for (var r of pv(t)) p_.call(t, r) && pC(e, r, t[r]);
          return e;
        },
        pI = (e, t) => pb(e, pw(t));
      let pS = {
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
        },
        method: "POST",
      };
      class pN {
        constructor(e, t = !1) {
          if (
            ((this.url = e),
            (this.disableProviderPing = t),
            (this.events = new b.EventEmitter()),
            (this.isAvailable = !1),
            (this.registering = !1),
            !lD(e))
          )
            throw Error(
              `Provided URL is not compatible with HTTP connection: ${e}`
            );
          (this.url = e), (this.disableProviderPing = t);
        }
        get connected() {
          return this.isAvailable;
        }
        get connecting() {
          return this.registering;
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async open(e = this.url) {
          await this.register(e);
        }
        async close() {
          if (!this.isAvailable) throw Error("Connection already closed");
          this.onClose();
        }
        async send(e) {
          this.isAvailable || (await this.register());
          try {
            let t = (0, H.h)(e),
              r = await (
                await pm()(this.url, pI(pA({}, pS), { body: t }))
              ).json();
            this.onPayload({ data: r });
          } catch (t) {
            this.onError(e.id, t);
          }
        }
        async register(e = this.url) {
          if (!lD(e))
            throw Error(
              `Provided URL is not compatible with HTTP connection: ${e}`
            );
          if (this.registering) {
            let e = this.events.getMaxListeners();
            return (
              (this.events.listenerCount("register_error") >= e ||
                this.events.listenerCount("open") >= e) &&
                this.events.setMaxListeners(e + 1),
              new Promise((e, t) => {
                this.events.once("register_error", (e) => {
                  this.resetMaxListeners(), t(e);
                }),
                  this.events.once("open", () => {
                    if (
                      (this.resetMaxListeners(), typeof this.isAvailable > "u")
                    )
                      return t(Error("HTTP connection is missing or invalid"));
                    e();
                  });
              })
            );
          }
          (this.url = e), (this.registering = !0);
          try {
            if (!this.disableProviderPing) {
              let t = (0, H.h)({
                id: 1,
                jsonrpc: "2.0",
                method: "test",
                params: [],
              });
              await pm()(e, pI(pA({}, pS), { body: t }));
            }
            this.onOpen();
          } catch (t) {
            let e = this.parseError(t);
            throw (this.events.emit("register_error", e), this.onClose(), e);
          }
        }
        onOpen() {
          (this.isAvailable = !0),
            (this.registering = !1),
            this.events.emit("open");
        }
        onClose() {
          (this.isAvailable = !1),
            (this.registering = !1),
            this.events.emit("close");
        }
        onPayload(e) {
          if (typeof e.data > "u") return;
          let t = "string" == typeof e.data ? (0, H.j)(e.data) : e.data;
          this.events.emit("payload", t);
        }
        onError(e, t) {
          let r = this.parseError(t),
            i = lO(e, r.message || r.toString());
          this.events.emit("payload", i);
        }
        parseError(e, t = this.url) {
          return lC(e, t, "HTTP");
        }
        resetMaxListeners() {
          this.events.getMaxListeners() > 10 && this.events.setMaxListeners(10);
        }
      }
      var pT = r(44134).Buffer;
      let pO = "error",
        px = "wc@2:universal_provider:",
        pP = "https://rpc.walletconnect.org/v1/",
        pR = "generic",
        pk = `${pP}bundler`,
        pD = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
      function pU() {}
      function pL(e) {
        return null == e || ("object" != typeof e && "function" != typeof e);
      }
      function pM(e) {
        return ArrayBuffer.isView(e) && !(e instanceof DataView);
      }
      function pj(e) {
        return "object" == typeof e && null !== e;
      }
      function p$(e) {
        return Object.getOwnPropertySymbols(e).filter((t) =>
          Object.prototype.propertyIsEnumerable.call(e, t)
        );
      }
      function pB(e) {
        return null == e
          ? void 0 === e
            ? "[object Undefined]"
            : "[object Null]"
          : Object.prototype.toString.call(e);
      }
      let pF = "[object String]",
        pW = "[object Number]",
        pq = "[object Boolean]",
        pH = "[object Arguments]";
      function pz(e, t, r, i = new Map(), s) {
        let n = s?.(e, t, r, i);
        if (null != n) return n;
        if (pL(e)) return e;
        if (i.has(e)) return i.get(e);
        if (Array.isArray(e)) {
          let t = Array(e.length);
          i.set(e, t);
          for (let n = 0; n < e.length; n++) t[n] = pz(e[n], n, r, i, s);
          return (
            Object.hasOwn(e, "index") && (t.index = e.index),
            Object.hasOwn(e, "input") && (t.input = e.input),
            t
          );
        }
        if (e instanceof Date) return new Date(e.getTime());
        if (e instanceof RegExp) {
          let t = new RegExp(e.source, e.flags);
          return (t.lastIndex = e.lastIndex), t;
        }
        if (e instanceof Map) {
          let t = new Map();
          for (let [n, a] of (i.set(e, t), e)) t.set(n, pz(a, n, r, i, s));
          return t;
        }
        if (e instanceof Set) {
          let t = new Set();
          for (let n of (i.set(e, t), e)) t.add(pz(n, void 0, r, i, s));
          return t;
        }
        if ("u" > typeof pT && pT.isBuffer(e)) return e.subarray();
        if (pM(e)) {
          let t = new (Object.getPrototypeOf(e).constructor)(e.length);
          i.set(e, t);
          for (let n = 0; n < e.length; n++) t[n] = pz(e[n], n, r, i, s);
          return t;
        }
        if (
          e instanceof ArrayBuffer ||
          ("u" > typeof SharedArrayBuffer && e instanceof SharedArrayBuffer)
        )
          return e.slice(0);
        if (e instanceof DataView) {
          let t = new DataView(e.buffer.slice(0), e.byteOffset, e.byteLength);
          return i.set(e, t), pV(t, e, r, i, s), t;
        }
        if ("u" > typeof File && e instanceof File) {
          let t = new File([e], e.name, { type: e.type });
          return i.set(e, t), pV(t, e, r, i, s), t;
        }
        if (e instanceof Blob) {
          let t = new Blob([e], { type: e.type });
          return i.set(e, t), pV(t, e, r, i, s), t;
        }
        if (e instanceof Error) {
          let t = new e.constructor();
          return (
            i.set(e, t),
            (t.message = e.message),
            (t.name = e.name),
            (t.stack = e.stack),
            (t.cause = e.cause),
            pV(t, e, r, i, s),
            t
          );
        }
        if (
          "object" == typeof e &&
          (function (e) {
            switch (pB(e)) {
              case pH:
              case "[object Array]":
              case "[object ArrayBuffer]":
              case "[object DataView]":
              case pq:
              case "[object Date]":
              case "[object Float32Array]":
              case "[object Float64Array]":
              case "[object Int8Array]":
              case "[object Int16Array]":
              case "[object Int32Array]":
              case "[object Map]":
              case pW:
              case "[object Object]":
              case "[object RegExp]":
              case "[object Set]":
              case pF:
              case "[object Symbol]":
              case "[object Uint8Array]":
              case "[object Uint8ClampedArray]":
              case "[object Uint16Array]":
              case "[object Uint32Array]":
                return !0;
              default:
                return !1;
            }
          })(e)
        ) {
          let t = Object.create(Object.getPrototypeOf(e));
          return i.set(e, t), pV(t, e, r, i, s), t;
        }
        return e;
      }
      function pV(e, t, r = e, i, s) {
        let n = [...Object.keys(t), ...p$(t)];
        for (let a = 0; a < n.length; a++) {
          let o = n[a],
            c = Object.getOwnPropertyDescriptor(e, o);
          (null == c || c.writable) && (e[o] = pz(t[o], o, r, i, s));
        }
      }
      function pK(e) {
        var t;
        return (
          (t = (t, r, i, s) => {
            let n = void 0;
            if (null != n) return n;
            if ("object" == typeof e)
              switch (Object.prototype.toString.call(e)) {
                case pW:
                case pF:
                case pq: {
                  let t = new e.constructor(e?.valueOf());
                  return pV(t, e), t;
                }
                case pH: {
                  let t = {};
                  return (
                    pV(t, e),
                    (t.length = e.length),
                    (t[Symbol.iterator] = e[Symbol.iterator]),
                    t
                  );
                }
                default:
                  return;
              }
          }),
          pz(e, void 0, e, new Map(), t)
        );
      }
      function pG(e) {
        return (
          null !== e && "object" == typeof e && "[object Arguments]" === pB(e)
        );
      }
      var pY = Object.defineProperty,
        pZ = Object.defineProperties,
        pJ = Object.getOwnPropertyDescriptors,
        pX = Object.getOwnPropertySymbols,
        pQ = Object.prototype.hasOwnProperty,
        p0 = Object.prototype.propertyIsEnumerable,
        p1 = (e, t, r) =>
          t in e
            ? pY(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        p2 = (e, t) => {
          for (var r in t || (t = {})) pQ.call(t, r) && p1(e, r, t[r]);
          if (pX) for (var r of pX(t)) p0.call(t, r) && p1(e, r, t[r]);
          return e;
        },
        p3 = (e, t) => pZ(e, pJ(t));
      function p5(e, t, r) {
        var i;
        let s = na(e);
        return (
          (null == (i = t.rpcMap) ? void 0 : i[s.reference]) ||
          `${pP}?chainId=${s.namespace}:${s.reference}&projectId=${r}`
        );
      }
      function p8(e) {
        return e.includes(":") ? e.split(":")[1] : e;
      }
      function p6(e) {
        return e.map((e) => `${e.split(":")[0]}:${e.split(":")[1]}`);
      }
      function p4(e = {}, t = {}) {
        return (function (e, ...t) {
          return (function (e, ...t) {
            let r = t.slice(0, -1),
              i = t[t.length - 1],
              s = e;
            for (let e = 0; e < r.length; e++)
              s = (function e(t, r, i, s) {
                if (
                  (pL(t) && (t = Object(t)), null == r || "object" != typeof r)
                )
                  return t;
                if (s.has(r))
                  return (function (e) {
                    if (pL(e)) return e;
                    if (
                      Array.isArray(e) ||
                      pM(e) ||
                      e instanceof ArrayBuffer ||
                      ("u" > typeof SharedArrayBuffer &&
                        e instanceof SharedArrayBuffer)
                    )
                      return e.slice(0);
                    let t = Object.getPrototypeOf(e),
                      r = t.constructor;
                    if (
                      e instanceof Date ||
                      e instanceof Map ||
                      e instanceof Set
                    )
                      return new r(e);
                    if (e instanceof RegExp) {
                      let t = new r(e);
                      return (t.lastIndex = e.lastIndex), t;
                    }
                    if (e instanceof DataView) return new r(e.buffer.slice(0));
                    if (e instanceof Error) {
                      let t = new r(e.message);
                      return (
                        (t.stack = e.stack),
                        (t.name = e.name),
                        (t.cause = e.cause),
                        t
                      );
                    }
                    return "u" > typeof File && e instanceof File
                      ? new r([e], e.name, {
                          type: e.type,
                          lastModified: e.lastModified,
                        })
                      : "object" == typeof e
                      ? Object.assign(Object.create(t), e)
                      : e;
                  })(s.get(r));
                if ((s.set(r, t), Array.isArray(r))) {
                  r = r.slice();
                  for (let e = 0; e < r.length; e++) r[e] = r[e] ?? void 0;
                }
                let n = [...Object.keys(r), ...p$(r)];
                for (let a = 0; a < n.length; a++) {
                  let o = n[a],
                    c = r[o],
                    l = t[o];
                  if (
                    (pG(c) && (c = { ...c }),
                    pG(l) && (l = { ...l }),
                    "u" > typeof pT && pT.isBuffer(c) && (c = pK(c)),
                    Array.isArray(c))
                  )
                    if ("object" == typeof l && null != l) {
                      let e = [],
                        t = Reflect.ownKeys(l);
                      for (let r = 0; r < t.length; r++) {
                        let i = t[r];
                        e[i] = l[i];
                      }
                      l = e;
                    } else l = [];
                  let u = i(l, c, o, t, r, s);
                  null != u
                    ? (t[o] = u)
                    : Array.isArray(c) || (pj(l) && pj(c))
                    ? (t[o] = e(l, c, i, s))
                    : null == l &&
                      (function (e) {
                        if ("object" != typeof e || null == e) return !1;
                        if (null === Object.getPrototypeOf(e)) return !0;
                        if (
                          "[object Object]" !==
                          Object.prototype.toString.call(e)
                        ) {
                          let t = e[Symbol.toStringTag];
                          return (
                            null != t &&
                            !!Object.getOwnPropertyDescriptor(
                              e,
                              Symbol.toStringTag
                            )?.writable &&
                            e.toString() === `[object ${t}]`
                          );
                        }
                        let t = e;
                        for (; null !== Object.getPrototypeOf(t); )
                          t = Object.getPrototypeOf(t);
                        return Object.getPrototypeOf(e) === t;
                      })(c)
                    ? (t[o] = e({}, c, i, s))
                    : null == l && pM(c)
                    ? (t[o] = pK(c))
                    : (void 0 === l || void 0 !== c) && (t[o] = c);
                }
                return t;
              })(s, r[e], i, new Map());
            return s;
          })(e, ...t, pU);
        })(p9(e), p9(t));
      }
      function p9(e) {
        var t, r, i, s, n;
        let a = {};
        if (!lt(e)) return a;
        for (let [o, c] of Object.entries(e)) {
          let e = c2(o) ? [o] : c.chains,
            l = c.methods || [],
            u = c.events || [],
            d = c.rpcMap || {},
            h = c3(o);
          (a[h] = p3(p2(p2({}, a[h]), c), {
            chains: nL(e, null == (t = a[h]) ? void 0 : t.chains),
            methods: nL(l, null == (r = a[h]) ? void 0 : r.methods),
            events: nL(u, null == (i = a[h]) ? void 0 : i.events),
          })),
            (lt(d) || lt((null == (s = a[h]) ? void 0 : s.rpcMap) || {})) &&
              (a[h].rpcMap = p2(
                p2({}, d),
                null == (n = a[h]) ? void 0 : n.rpcMap
              ));
        }
        return a;
      }
      function p7(e) {
        return e.includes(":") ? e.split(":")[2] : e;
      }
      function fe(e) {
        let t = {};
        for (let [r, i] of Object.entries(e)) {
          let e = i.methods || [],
            s = i.events || [],
            n = i.accounts || [],
            a = c2(r) ? [r] : i.chains ? i.chains : p6(i.accounts);
          t[r] = { chains: a, methods: e, events: s, accounts: n };
        }
        return t;
      }
      function ft(e) {
        return "number" == typeof e
          ? e
          : e.includes("0x")
          ? parseInt(e, 16)
          : isNaN(Number((e = e.includes(":") ? e.split(":")[1] : e)))
          ? e
          : Number(e);
      }
      let fr = {},
        fi = (e) => fr[e],
        fs = (e, t) => {
          fr[e] = t;
        };
      var fn = Object.defineProperty,
        fa = (e, t, r) =>
          t in e
            ? fn(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        fo = (e, t, r) => fa(e, "symbol" != typeof t ? t + "" : t, r);
      class fc {
        constructor(e) {
          fo(this, "name", "polkadot"),
            fo(this, "client"),
            fo(this, "httpProviders"),
            fo(this, "events"),
            fo(this, "namespace"),
            fo(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = fi("events")),
            (this.client = fi("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(pD.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return (
            (e &&
              e
                .filter((e) => e.split(":")[1] === this.chainId.toString())
                .map((e) => e.split(":")[2])) ||
            []
          );
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = p8(t);
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || p5(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new lF(new pN(r, fi("disableProviderPing")));
        }
      }
      var fl = Object.defineProperty,
        fu = Object.defineProperties,
        fd = Object.getOwnPropertyDescriptors,
        fh = Object.getOwnPropertySymbols,
        fp = Object.prototype.hasOwnProperty,
        ff = Object.prototype.propertyIsEnumerable,
        fg = (e, t, r) =>
          t in e
            ? fl(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        fm = (e, t) => {
          for (var r in t || (t = {})) fp.call(t, r) && fg(e, r, t[r]);
          if (fh) for (var r of fh(t)) ff.call(t, r) && fg(e, r, t[r]);
          return e;
        },
        fy = (e, t) => fu(e, fd(t)),
        fb = (e, t, r) => fg(e, "symbol" != typeof t ? t + "" : t, r);
      class fw {
        constructor(e) {
          fb(this, "name", "eip155"),
            fb(this, "client"),
            fb(this, "chainId"),
            fb(this, "namespace"),
            fb(this, "httpProviders"),
            fb(this, "events"),
            (this.namespace = e.namespace),
            (this.events = fi("events")),
            (this.client = fi("client")),
            (this.httpProviders = this.createHttpProviders()),
            (this.chainId = parseInt(this.getDefaultChain()));
        }
        async request(e) {
          switch (e.request.method) {
            case "eth_requestAccounts":
            case "eth_accounts":
              return this.getAccounts();
            case "wallet_switchEthereumChain":
              return await this.handleSwitchChain(e);
            case "eth_chainId":
              return parseInt(this.getDefaultChain());
            case "wallet_getCapabilities":
              return await this.getCapabilities(e);
            case "wallet_getCallsStatus":
              return await this.getCallStatus(e);
          }
          return this.namespace.methods.includes(e.request.method)
            ? await this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(parseInt(e), t),
            (this.chainId = parseInt(e)),
            this.events.emit(pD.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId.toString();
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        createHttpProvider(e, t) {
          let r =
            t ||
            p5(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new lF(new pN(r, fi("disableProviderPing")));
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = parseInt(p8(t));
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        getHttpProvider() {
          let e = this.chainId,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        async handleSwitchChain(e) {
          var t, r;
          let i = e.request.params
              ? null == (t = e.request.params[0])
                ? void 0
                : t.chainId
              : "0x0",
            s = parseInt((i = i.startsWith("0x") ? i : `0x${i}`), 16);
          if (this.isChainApproved(s)) this.setDefaultChain(`${s}`);
          else if (
            this.namespace.methods.includes("wallet_switchEthereumChain")
          )
            await this.client.request({
              topic: e.topic,
              request: { method: e.request.method, params: [{ chainId: i }] },
              chainId: null == (r = this.namespace.chains) ? void 0 : r[0],
            }),
              this.setDefaultChain(`${s}`);
          else
            throw Error(
              `Failed to switch to chain 'eip155:${s}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`
            );
          return null;
        }
        isChainApproved(e) {
          return this.namespace.chains.includes(`${this.name}:${e}`);
        }
        async getCapabilities(e) {
          var t, r, i, s, n;
          let a =
              null == (r = null == (t = e.request) ? void 0 : t.params)
                ? void 0
                : r[0],
            o =
              (null == (s = null == (i = e.request) ? void 0 : i.params)
                ? void 0
                : s[1]) || [],
            c = `${a}${o.join(",")}`;
          if (!a)
            throw Error(
              "Missing address parameter in `wallet_getCapabilities` request"
            );
          let l = this.client.session.get(e.topic),
            u =
              (null == (n = l?.sessionProperties) ? void 0 : n.capabilities) ||
              {};
          if (null != u && u[c]) return u?.[c];
          let d = await this.client.request(e);
          try {
            await this.client.session.update(e.topic, {
              sessionProperties: fy(fm({}, l.sessionProperties || {}), {
                capabilities: fy(fm({}, u || {}), { [c]: d }),
              }),
            });
          } catch (e) {
            console.warn("Failed to update session with capabilities", e);
          }
          return d;
        }
        async getCallStatus(e) {
          var t, r;
          let i = this.client.session.get(e.topic),
            s = null == (t = i.sessionProperties) ? void 0 : t.bundler_name;
          if (s) {
            let t = this.getBundlerUrl(e.chainId, s);
            try {
              return await this.getUserOperationReceipt(t, e);
            } catch (e) {
              console.warn("Failed to fetch call status from bundler", e, t);
            }
          }
          let n = null == (r = i.sessionProperties) ? void 0 : r.bundler_url;
          if (n)
            try {
              return await this.getUserOperationReceipt(n, e);
            } catch (e) {
              console.warn(
                "Failed to fetch call status from custom bundler",
                e,
                n
              );
            }
          if (this.namespace.methods.includes(e.request.method))
            return await this.client.request(e);
          throw Error("Fetching call status not approved by the wallet.");
        }
        async getUserOperationReceipt(e, t) {
          var r;
          let i = new URL(e),
            s = await fetch(i, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(
                lN("eth_getUserOperationReceipt", [
                  null == (r = t.request.params) ? void 0 : r[0],
                ])
              ),
            });
          if (!s.ok)
            throw Error(`Failed to fetch user operation receipt - ${s.status}`);
          return await s.json();
        }
        getBundlerUrl(e, t) {
          return `${pk}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${t}`;
        }
      }
      var fv = Object.defineProperty,
        fE = (e, t, r) =>
          t in e
            ? fv(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        f_ = (e, t, r) => fE(e, "symbol" != typeof t ? t + "" : t, r);
      class fC {
        constructor(e) {
          f_(this, "name", "solana"),
            f_(this, "client"),
            f_(this, "httpProviders"),
            f_(this, "events"),
            f_(this, "namespace"),
            f_(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = fi("events")),
            (this.client = fi("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(pD.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = p8(t);
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || p5(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new lF(new pN(r, fi("disableProviderPing")));
        }
      }
      var fA = Object.defineProperty,
        fI = (e, t, r) =>
          t in e
            ? fA(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        fS = (e, t, r) => fI(e, "symbol" != typeof t ? t + "" : t, r);
      class fN {
        constructor(e) {
          fS(this, "name", "cosmos"),
            fS(this, "client"),
            fS(this, "httpProviders"),
            fS(this, "events"),
            fS(this, "namespace"),
            fS(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = fi("events")),
            (this.client = fi("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(
              pD.DEFAULT_CHAIN_CHANGED,
              `${this.name}:${this.chainId}`
            );
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = p8(t);
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || p5(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new lF(new pN(r, fi("disableProviderPing")));
        }
      }
      var fT = Object.defineProperty,
        fO = (e, t, r) =>
          t in e
            ? fT(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        fx = (e, t, r) => fO(e, "symbol" != typeof t ? t + "" : t, r);
      class fP {
        constructor(e) {
          fx(this, "name", "algorand"),
            fx(this, "client"),
            fx(this, "httpProviders"),
            fx(this, "events"),
            fx(this, "namespace"),
            fx(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = fi("events")),
            (this.client = fi("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          if (!this.httpProviders[e]) {
            let r =
              t ||
              p5(
                `${this.name}:${e}`,
                this.namespace,
                this.client.core.projectId
              );
            if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
            this.setHttpProvider(e, r);
          }
          (this.chainId = e),
            this.events.emit(
              pD.DEFAULT_CHAIN_CHANGED,
              `${this.name}:${this.chainId}`
            );
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              e[t] = this.createHttpProvider(
                t,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || p5(e, this.namespace, this.client.core.projectId);
          return typeof r > "u"
            ? void 0
            : new lF(new pN(r, fi("disableProviderPing")));
        }
      }
      var fR = Object.defineProperty,
        fk = (e, t, r) =>
          t in e
            ? fR(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        fD = (e, t, r) => fk(e, "symbol" != typeof t ? t + "" : t, r);
      class fU {
        constructor(e) {
          fD(this, "name", "cip34"),
            fD(this, "client"),
            fD(this, "httpProviders"),
            fD(this, "events"),
            fD(this, "namespace"),
            fD(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = fi("events")),
            (this.client = fi("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(
              pD.DEFAULT_CHAIN_CHANGED,
              `${this.name}:${this.chainId}`
            );
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              let r = this.getCardanoRPCUrl(t),
                i = p8(t);
              e[i] = this.createHttpProvider(i, r);
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        getCardanoRPCUrl(e) {
          let t = this.namespace.rpcMap;
          if (t) return t[e];
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || this.getCardanoRPCUrl(e);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new lF(new pN(r, fi("disableProviderPing")));
        }
      }
      var fL = Object.defineProperty,
        fM = (e, t, r) =>
          t in e
            ? fL(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        fj = (e, t, r) => fM(e, "symbol" != typeof t ? t + "" : t, r);
      class f$ {
        constructor(e) {
          fj(this, "name", "elrond"),
            fj(this, "client"),
            fj(this, "httpProviders"),
            fj(this, "events"),
            fj(this, "namespace"),
            fj(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = fi("events")),
            (this.client = fi("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(pD.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = p8(t);
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || p5(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new lF(new pN(r, fi("disableProviderPing")));
        }
      }
      var fB = Object.defineProperty,
        fF = (e, t, r) =>
          t in e
            ? fB(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        fW = (e, t, r) => fF(e, "symbol" != typeof t ? t + "" : t, r);
      class fq {
        constructor(e) {
          fW(this, "name", "multiversx"),
            fW(this, "client"),
            fW(this, "httpProviders"),
            fW(this, "events"),
            fW(this, "namespace"),
            fW(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = fi("events")),
            (this.client = fi("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(pD.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = p8(t);
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || p5(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new lF(new pN(r, fi("disableProviderPing")));
        }
      }
      var fH = Object.defineProperty,
        fz = (e, t, r) =>
          t in e
            ? fH(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        fV = (e, t, r) => fz(e, "symbol" != typeof t ? t + "" : t, r);
      class fK {
        constructor(e) {
          fV(this, "name", "near"),
            fV(this, "client"),
            fV(this, "httpProviders"),
            fV(this, "events"),
            fV(this, "namespace"),
            fV(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = fi("events")),
            (this.client = fi("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          if (((this.chainId = e), !this.httpProviders[e])) {
            let r = t || p5(`${this.name}:${e}`, this.namespace);
            if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
            this.setHttpProvider(e, r);
          }
          this.events.emit(
            pD.DEFAULT_CHAIN_CHANGED,
            `${this.name}:${this.chainId}`
          );
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return (
            (e &&
              e
                .filter((e) => e.split(":")[1] === this.chainId.toString())
                .map((e) => e.split(":")[2])) ||
            []
          );
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              e[t] = this.createHttpProvider(
                t,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || p5(e, this.namespace);
          return typeof r > "u"
            ? void 0
            : new lF(new pN(r, fi("disableProviderPing")));
        }
      }
      var fG = Object.defineProperty,
        fY = (e, t, r) =>
          t in e
            ? fG(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        fZ = (e, t, r) => fY(e, "symbol" != typeof t ? t + "" : t, r);
      class fJ {
        constructor(e) {
          fZ(this, "name", "tezos"),
            fZ(this, "client"),
            fZ(this, "httpProviders"),
            fZ(this, "events"),
            fZ(this, "namespace"),
            fZ(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = fi("events")),
            (this.client = fi("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          if (((this.chainId = e), !this.httpProviders[e])) {
            let r = t || p5(`${this.name}:${e}`, this.namespace);
            if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
            this.setHttpProvider(e, r);
          }
          this.events.emit(
            pD.DEFAULT_CHAIN_CHANGED,
            `${this.name}:${this.chainId}`
          );
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return (
            (e &&
              e
                .filter((e) => e.split(":")[1] === this.chainId.toString())
                .map((e) => e.split(":")[2])) ||
            []
          );
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              e[t] = this.createHttpProvider(t);
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || p5(e, this.namespace);
          return typeof r > "u" ? void 0 : new lF(new pN(r));
        }
      }
      var fX = Object.defineProperty,
        fQ = (e, t, r) =>
          t in e
            ? fX(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        f0 = (e, t, r) => fQ(e, "symbol" != typeof t ? t + "" : t, r);
      class f1 {
        constructor(e) {
          f0(this, "name", pR),
            f0(this, "client"),
            f0(this, "httpProviders"),
            f0(this, "events"),
            f0(this, "namespace"),
            f0(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = fi("events")),
            (this.client = fi("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          (this.namespace.chains = [
            ...new Set((this.namespace.chains || []).concat(e.chains || [])),
          ]),
            (this.namespace.accounts = [
              ...new Set(
                (this.namespace.accounts || []).concat(e.accounts || [])
              ),
            ]),
            (this.namespace.methods = [
              ...new Set(
                (this.namespace.methods || []).concat(e.methods || [])
              ),
            ]),
            (this.namespace.events = [
              ...new Set((this.namespace.events || []).concat(e.events || [])),
            ]),
            (this.httpProviders = this.createHttpProviders());
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider(e.chainId).request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(pD.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          var e, t;
          let r = {};
          return (
            null == (t = null == (e = this.namespace) ? void 0 : e.accounts) ||
              t.forEach((e) => {
                let t = na(e);
                r[`${t.namespace}:${t.reference}`] = this.createHttpProvider(e);
              }),
            r
          );
        }
        getHttpProvider(e) {
          let t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || p5(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new lF(new pN(r, fi("disableProviderPing")));
        }
      }
      var f2 = Object.defineProperty,
        f3 = Object.defineProperties,
        f5 = Object.getOwnPropertyDescriptors,
        f8 = Object.getOwnPropertySymbols,
        f6 = Object.prototype.hasOwnProperty,
        f4 = Object.prototype.propertyIsEnumerable,
        f9 = (e, t, r) =>
          t in e
            ? f2(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        f7 = (e, t) => {
          for (var r in t || (t = {})) f6.call(t, r) && f9(e, r, t[r]);
          if (f8) for (var r of f8(t)) f4.call(t, r) && f9(e, r, t[r]);
          return e;
        },
        ge = (e, t) => f3(e, f5(t)),
        gt = (e, t, r) => f9(e, "symbol" != typeof t ? t + "" : t, r);
      class gr {
        constructor(e) {
          gt(this, "client"),
            gt(this, "namespaces"),
            gt(this, "optionalNamespaces"),
            gt(this, "sessionProperties"),
            gt(this, "scopedProperties"),
            gt(this, "events", new (w())()),
            gt(this, "rpcProviders", {}),
            gt(this, "session"),
            gt(this, "providerOpts"),
            gt(this, "logger"),
            gt(this, "uri"),
            gt(this, "disableProviderPing", !1),
            (this.providerOpts = e),
            (this.logger =
              "u" > typeof e?.logger && "string" != typeof e?.logger
                ? e.logger
                : (0, ee.h6)((0, ee.iP)({ level: e?.logger || pO }))),
            (this.disableProviderPing = e?.disableProviderPing || !1);
        }
        static async init(e) {
          let t = new gr(e);
          return await t.initialize(), t;
        }
        async request(e, t, r) {
          let [i, s] = this.validateChain(t);
          if (!this.session)
            throw Error("Please call connect() before request()");
          return await this.getProvider(i).request({
            request: f7({}, e),
            chainId: `${i}:${s}`,
            topic: this.session.topic,
            expiry: r,
          });
        }
        sendAsync(e, t, r, i) {
          let s = new Date().getTime();
          this.request(e, r, i)
            .then((e) => t(null, lT(s, e)))
            .catch((e) => t(e, void 0));
        }
        async enable() {
          if (!this.client) throw Error("Sign Client not initialized");
          return (
            this.session ||
              (await this.connect({
                namespaces: this.namespaces,
                optionalNamespaces: this.optionalNamespaces,
                sessionProperties: this.sessionProperties,
                scopedProperties: this.scopedProperties,
              })),
            await this.requestAccounts()
          );
        }
        async disconnect() {
          var e;
          if (!this.session)
            throw Error("Please call connect() before enable()");
          await this.client.disconnect({
            topic: null == (e = this.session) ? void 0 : e.topic,
            reason: c7("USER_DISCONNECTED"),
          }),
            await this.cleanup();
        }
        async connect(e) {
          if (!this.client) throw Error("Sign Client not initialized");
          if (
            (this.setNamespaces(e),
            await this.cleanupPendingPairings(),
            !e.skipPairing)
          )
            return await this.pair(e.pairingTopic);
        }
        async authenticate(e, t) {
          if (!this.client) throw Error("Sign Client not initialized");
          this.setNamespaces(e), await this.cleanupPendingPairings();
          let { uri: r, response: i } = await this.client.authenticate(e, t);
          r && ((this.uri = r), this.events.emit("display_uri", r));
          let s = await i();
          if (((this.session = s.session), this.session)) {
            let e = fe(this.session.namespaces);
            (this.namespaces = p4(this.namespaces, e)),
              await this.persist("namespaces", this.namespaces),
              this.onConnect();
          }
          return s;
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        get isWalletConnect() {
          return !0;
        }
        async pair(e) {
          let { uri: t, approval: r } = await this.client.connect({
            pairingTopic: e,
            requiredNamespaces: this.namespaces,
            optionalNamespaces: this.optionalNamespaces,
            sessionProperties: this.sessionProperties,
            scopedProperties: this.scopedProperties,
          });
          t && ((this.uri = t), this.events.emit("display_uri", t));
          let i = await r();
          this.session = i;
          let s = fe(i.namespaces);
          return (
            (this.namespaces = p4(this.namespaces, s)),
            await this.persist("namespaces", this.namespaces),
            await this.persist("optionalNamespaces", this.optionalNamespaces),
            this.onConnect(),
            this.session
          );
        }
        setDefaultChain(e, t) {
          try {
            if (!this.session) return;
            let [r, i] = this.validateChain(e),
              s = this.getProvider(r);
            s.name === pR
              ? s.setDefaultChain(`${r}:${i}`, t)
              : s.setDefaultChain(i, t);
          } catch (e) {
            if (!/Please call connect/.test(e.message)) throw e;
          }
        }
        async cleanupPendingPairings(e = {}) {
          this.logger.info("Cleaning up inactive pairings...");
          let t = this.client.pairing.getAll();
          if (le(t)) {
            for (let r of t)
              e.deletePairings
                ? this.client.core.expirer.set(r.topic, 0)
                : await this.client.core.relayer.subscriber.unsubscribe(
                    r.topic
                  );
            this.logger.info(`Inactive pairings cleared: ${t.length}`);
          }
        }
        abortPairingAttempt() {
          this.logger.warn(
            "abortPairingAttempt is deprecated. This is now a no-op."
          );
        }
        async checkStorage() {
          (this.namespaces = (await this.getFromStore("namespaces")) || {}),
            (this.optionalNamespaces =
              (await this.getFromStore("optionalNamespaces")) || {}),
            this.session && this.createProviders();
        }
        async initialize() {
          this.logger.trace("Initialized"),
            await this.createClient(),
            await this.checkStorage(),
            this.registerEventListeners();
        }
        async createClient() {
          var e, t;
          if (
            ((this.client =
              this.providerOpts.client ||
              (await pf.init({
                core: this.providerOpts.core,
                logger: this.providerOpts.logger || pO,
                relayUrl:
                  this.providerOpts.relayUrl || "wss://relay.walletconnect.org",
                projectId: this.providerOpts.projectId,
                metadata: this.providerOpts.metadata,
                storageOptions: this.providerOpts.storageOptions,
                storage: this.providerOpts.storage,
                name: this.providerOpts.name,
                customStoragePrefix: this.providerOpts.customStoragePrefix,
                telemetryEnabled: this.providerOpts.telemetryEnabled,
              }))),
            this.providerOpts.session)
          )
            try {
              this.session = this.client.session.get(
                this.providerOpts.session.topic
              );
            } catch (r) {
              throw (
                (this.logger.error("Failed to get session", r),
                Error(
                  `The provided session: ${
                    null ==
                    (t = null == (e = this.providerOpts) ? void 0 : e.session)
                      ? void 0
                      : t.topic
                  } doesn't exist in the Sign client`
                ))
              );
            }
          else {
            let e = this.client.session.getAll();
            this.session = e[0];
          }
          this.logger.trace("SignClient Initialized");
        }
        createProviders() {
          if (!this.client) throw Error("Sign Client not initialized");
          if (!this.session)
            throw Error(
              "Session not initialized. Please call connect() before enable()"
            );
          let e = [
            ...new Set(Object.keys(this.session.namespaces).map((e) => c3(e))),
          ];
          fs("client", this.client),
            fs("events", this.events),
            fs("disableProviderPing", this.disableProviderPing),
            e.forEach((e) => {
              if (!this.session) return;
              let t = (function (e, t) {
                  let r = Object.keys(t.namespaces).filter((t) =>
                    t.includes(e)
                  );
                  if (!r.length) return [];
                  let i = [];
                  return (
                    r.forEach((e) => {
                      let r = t.namespaces[e].accounts;
                      i.push(...r);
                    }),
                    i
                  );
                })(e, this.session),
                r = p6(t),
                i = ge(
                  f7({}, p4(this.namespaces, this.optionalNamespaces)[e]),
                  { accounts: t, chains: r }
                );
              switch (e) {
                case "eip155":
                  this.rpcProviders[e] = new fw({ namespace: i });
                  break;
                case "algorand":
                  this.rpcProviders[e] = new fP({ namespace: i });
                  break;
                case "solana":
                  this.rpcProviders[e] = new fC({ namespace: i });
                  break;
                case "cosmos":
                  this.rpcProviders[e] = new fN({ namespace: i });
                  break;
                case "polkadot":
                  this.rpcProviders[e] = new fc({ namespace: i });
                  break;
                case "cip34":
                  this.rpcProviders[e] = new fU({ namespace: i });
                  break;
                case "elrond":
                  this.rpcProviders[e] = new f$({ namespace: i });
                  break;
                case "multiversx":
                  this.rpcProviders[e] = new fq({ namespace: i });
                  break;
                case "near":
                  this.rpcProviders[e] = new fK({ namespace: i });
                  break;
                case "tezos":
                  this.rpcProviders[e] = new fJ({ namespace: i });
                  break;
                default:
                  this.rpcProviders[pR]
                    ? this.rpcProviders[pR].updateNamespace(i)
                    : (this.rpcProviders[pR] = new f1({ namespace: i }));
              }
            });
        }
        registerEventListeners() {
          if (typeof this.client > "u")
            throw Error("Sign Client is not initialized");
          this.client.on("session_ping", (e) => {
            var t;
            let { topic: r } = e;
            r === (null == (t = this.session) ? void 0 : t.topic) &&
              this.events.emit("session_ping", e);
          }),
            this.client.on("session_event", (e) => {
              var t;
              let { params: r, topic: i } = e;
              if (i !== (null == (t = this.session) ? void 0 : t.topic)) return;
              let { event: s } = r;
              if ("accountsChanged" === s.name) {
                let e = s.data;
                e && le(e) && this.events.emit("accountsChanged", e.map(p7));
              } else if ("chainChanged" === s.name) {
                let e = r.chainId,
                  t = r.event.data,
                  i = c3(e),
                  s = ft(e) !== ft(t) ? `${i}:${ft(t)}` : e;
                this.onChainChanged(s);
              } else this.events.emit(s.name, s.data);
              this.events.emit("session_event", e);
            }),
            this.client.on("session_update", ({ topic: e, params: t }) => {
              var r, i;
              if (e !== (null == (r = this.session) ? void 0 : r.topic)) return;
              let { namespaces: s } = t,
                n = null == (i = this.client) ? void 0 : i.session.get(e);
              (this.session = ge(f7({}, n), { namespaces: s })),
                this.onSessionUpdate(),
                this.events.emit("session_update", { topic: e, params: t });
            }),
            this.client.on("session_delete", async (e) => {
              var t;
              e.topic === (null == (t = this.session) ? void 0 : t.topic) &&
                (await this.cleanup(),
                this.events.emit("session_delete", e),
                this.events.emit(
                  "disconnect",
                  ge(f7({}, c7("USER_DISCONNECTED")), { data: e.topic })
                ));
            }),
            this.on(pD.DEFAULT_CHAIN_CHANGED, (e) => {
              this.onChainChanged(e, !0);
            });
        }
        getProvider(e) {
          return this.rpcProviders[e] || this.rpcProviders[pR];
        }
        onSessionUpdate() {
          Object.keys(this.rpcProviders).forEach((e) => {
            var t;
            this.getProvider(e).updateNamespace(
              null == (t = this.session) ? void 0 : t.namespaces[e]
            );
          });
        }
        setNamespaces(e) {
          let {
            namespaces: t = {},
            optionalNamespaces: r = {},
            sessionProperties: i,
            scopedProperties: s,
          } = e;
          (this.optionalNamespaces = p4(t, r)),
            (this.sessionProperties = i),
            (this.scopedProperties = s);
        }
        validateChain(e) {
          let [t, r] = e?.split(":") || ["", ""];
          if (!this.namespaces || !Object.keys(this.namespaces).length)
            return [t, r];
          if (
            t &&
            !Object.keys(this.namespaces || {})
              .map((e) => c3(e))
              .includes(t)
          )
            throw Error(
              `Namespace '${t}' is not configured. Please call connect() first with namespace config.`
            );
          if (t && r) return [t, r];
          let i = c3(Object.keys(this.namespaces)[0]),
            s = this.rpcProviders[i].getDefaultChain();
          return [i, s];
        }
        async requestAccounts() {
          let [e] = this.validateChain();
          return await this.getProvider(e).requestAccounts();
        }
        async onChainChanged(e, t = !1) {
          if (!this.namespaces) return;
          let [r, i] = this.validateChain(e);
          if (!i) return;
          this.updateNamespaceChain(r, i), this.events.emit("chainChanged", i);
          let s = this.getProvider(r).getDefaultChain();
          t || this.getProvider(r).setDefaultChain(i),
            this.emitAccountsChangedOnChainChange({
              namespace: r,
              previousChainId: s,
              newChainId: e,
            }),
            await this.persist("namespaces", this.namespaces);
        }
        emitAccountsChangedOnChainChange({
          namespace: e,
          previousChainId: t,
          newChainId: r,
        }) {
          var i, s;
          try {
            if (t === r) return;
            let n =
              null ==
              (s = null == (i = this.session) ? void 0 : i.namespaces[e])
                ? void 0
                : s.accounts;
            if (!n) return;
            let a = n.filter((e) => e.includes(`${r}:`)).map(p7);
            if (!le(a)) return;
            this.events.emit("accountsChanged", a);
          } catch (e) {
            this.logger.warn(
              "Failed to emit accountsChanged on chain change",
              e
            );
          }
        }
        updateNamespaceChain(e, t) {
          if (!this.namespaces) return;
          let r = this.namespaces[e] ? e : `${e}:${t}`;
          this.namespaces[r]
            ? this.namespaces[r] && (this.namespaces[r].defaultChain = t)
            : (this.namespaces[r] = {
                chains: [],
                methods: [],
                events: [],
                defaultChain: t,
              });
        }
        onConnect() {
          this.createProviders(),
            this.events.emit("connect", { session: this.session });
        }
        async cleanup() {
          (this.namespaces = void 0),
            (this.optionalNamespaces = void 0),
            (this.sessionProperties = void 0),
            await this.deleteFromStore("namespaces"),
            await this.deleteFromStore("optionalNamespaces"),
            await this.deleteFromStore("sessionProperties"),
            (this.session = void 0),
            await this.cleanupPendingPairings({ deletePairings: !0 }),
            await this.cleanupStorage();
        }
        async persist(e, t) {
          var r;
          let i = (null == (r = this.session) ? void 0 : r.topic) || "";
          await this.client.core.storage.setItem(`${px}/${e}${i}`, t);
        }
        async getFromStore(e) {
          var t;
          let r = (null == (t = this.session) ? void 0 : t.topic) || "";
          return await this.client.core.storage.getItem(`${px}/${e}${r}`);
        }
        async deleteFromStore(e) {
          var t;
          let r = (null == (t = this.session) ? void 0 : t.topic) || "";
          await this.client.core.storage.removeItem(`${px}/${e}${r}`);
        }
        async cleanupStorage() {
          var e;
          try {
            if ((null == (e = this.client) ? void 0 : e.session.length) > 0)
              return;
            for (let e of await this.client.core.storage.getKeys())
              e.startsWith(px) &&
                (await this.client.core.storage.removeItem(e));
          } catch (e) {
            this.logger.warn("Failed to cleanup storage", e);
          }
        }
      }
    },
    50548: (e, t, r) => {
      "use strict";
      let i;
      r.d(t, { Y: () => rb });
      var s,
        n,
        a,
        o,
        c = r(60500),
        l = r(45312),
        u = r(519);
      !(function (e) {
        (e.assertEqual = (e) => e),
          (e.assertIs = function (e) {}),
          (e.assertNever = function (e) {
            throw Error();
          }),
          (e.arrayToEnum = (e) => {
            let t = {};
            for (let r of e) t[r] = r;
            return t;
          }),
          (e.getValidEnumValues = (t) => {
            let r = e.objectKeys(t).filter((e) => "number" != typeof t[t[e]]),
              i = {};
            for (let e of r) i[e] = t[e];
            return e.objectValues(i);
          }),
          (e.objectValues = (t) =>
            e.objectKeys(t).map(function (e) {
              return t[e];
            })),
          (e.objectKeys =
            "function" == typeof Object.keys
              ? (e) => Object.keys(e)
              : (e) => {
                  let t = [];
                  for (let r in e)
                    Object.prototype.hasOwnProperty.call(e, r) && t.push(r);
                  return t;
                }),
          (e.find = (e, t) => {
            for (let r of e) if (t(r)) return r;
          }),
          (e.isInteger =
            "function" == typeof Number.isInteger
              ? (e) => Number.isInteger(e)
              : (e) =>
                  "number" == typeof e && isFinite(e) && Math.floor(e) === e),
          (e.joinValues = function (e, t = " | ") {
            return e.map((e) => ("string" == typeof e ? `'${e}'` : e)).join(t);
          }),
          (e.jsonStringifyReplacer = (e, t) =>
            "bigint" == typeof t ? t.toString() : t);
      })(s || (s = {})),
        ((n || (n = {})).mergeShapes = (e, t) => ({ ...e, ...t }));
      let d = s.arrayToEnum([
          "string",
          "nan",
          "number",
          "integer",
          "float",
          "boolean",
          "date",
          "bigint",
          "symbol",
          "function",
          "undefined",
          "null",
          "array",
          "object",
          "unknown",
          "promise",
          "void",
          "never",
          "map",
          "set",
        ]),
        h = (e) => {
          switch (typeof e) {
            case "undefined":
              return d.undefined;
            case "string":
              return d.string;
            case "number":
              return isNaN(e) ? d.nan : d.number;
            case "boolean":
              return d.boolean;
            case "function":
              return d.function;
            case "bigint":
              return d.bigint;
            case "symbol":
              return d.symbol;
            case "object":
              if (Array.isArray(e)) return d.array;
              if (null === e) return d.null;
              if (
                e.then &&
                "function" == typeof e.then &&
                e.catch &&
                "function" == typeof e.catch
              )
                return d.promise;
              if ("undefined" != typeof Map && e instanceof Map) return d.map;
              if ("undefined" != typeof Set && e instanceof Set) return d.set;
              if ("undefined" != typeof Date && e instanceof Date)
                return d.date;
              return d.object;
            default:
              return d.unknown;
          }
        },
        p = s.arrayToEnum([
          "invalid_type",
          "invalid_literal",
          "custom",
          "invalid_union",
          "invalid_union_discriminator",
          "invalid_enum_value",
          "unrecognized_keys",
          "invalid_arguments",
          "invalid_return_type",
          "invalid_date",
          "invalid_string",
          "too_small",
          "too_big",
          "invalid_intersection_types",
          "not_multiple_of",
          "not_finite",
        ]);
      class f extends Error {
        constructor(e) {
          super(),
            (this.issues = []),
            (this.addIssue = (e) => {
              this.issues = [...this.issues, e];
            }),
            (this.addIssues = (e = []) => {
              this.issues = [...this.issues, ...e];
            });
          let t = new.target.prototype;
          Object.setPrototypeOf
            ? Object.setPrototypeOf(this, t)
            : (this.__proto__ = t),
            (this.name = "ZodError"),
            (this.issues = e);
        }
        get errors() {
          return this.issues;
        }
        format(e) {
          let t =
              e ||
              function (e) {
                return e.message;
              },
            r = { _errors: [] },
            i = (e) => {
              for (let s of e.issues)
                if ("invalid_union" === s.code) s.unionErrors.map(i);
                else if ("invalid_return_type" === s.code) i(s.returnTypeError);
                else if ("invalid_arguments" === s.code) i(s.argumentsError);
                else if (0 === s.path.length) r._errors.push(t(s));
                else {
                  let e = r,
                    i = 0;
                  for (; i < s.path.length; ) {
                    let r = s.path[i];
                    i === s.path.length - 1
                      ? ((e[r] = e[r] || { _errors: [] }),
                        e[r]._errors.push(t(s)))
                      : (e[r] = e[r] || { _errors: [] }),
                      (e = e[r]),
                      i++;
                  }
                }
            };
          return i(this), r;
        }
        toString() {
          return this.message;
        }
        get message() {
          return JSON.stringify(this.issues, s.jsonStringifyReplacer, 2);
        }
        get isEmpty() {
          return 0 === this.issues.length;
        }
        flatten(e = (e) => e.message) {
          let t = {},
            r = [];
          for (let i of this.issues)
            i.path.length > 0
              ? ((t[i.path[0]] = t[i.path[0]] || []), t[i.path[0]].push(e(i)))
              : r.push(e(i));
          return { formErrors: r, fieldErrors: t };
        }
        get formErrors() {
          return this.flatten();
        }
      }
      f.create = (e) => new f(e);
      let g = (e, t) => {
          let r;
          switch (e.code) {
            case p.invalid_type:
              r =
                e.received === d.undefined
                  ? "Required"
                  : `Expected ${e.expected}, received ${e.received}`;
              break;
            case p.invalid_literal:
              r = `Invalid literal value, expected ${JSON.stringify(
                e.expected,
                s.jsonStringifyReplacer
              )}`;
              break;
            case p.unrecognized_keys:
              r = `Unrecognized key(s) in object: ${s.joinValues(
                e.keys,
                ", "
              )}`;
              break;
            case p.invalid_union:
              r = "Invalid input";
              break;
            case p.invalid_union_discriminator:
              r = `Invalid discriminator value. Expected ${s.joinValues(
                e.options
              )}`;
              break;
            case p.invalid_enum_value:
              r = `Invalid enum value. Expected ${s.joinValues(
                e.options
              )}, received '${e.received}'`;
              break;
            case p.invalid_arguments:
              r = "Invalid function arguments";
              break;
            case p.invalid_return_type:
              r = "Invalid function return type";
              break;
            case p.invalid_date:
              r = "Invalid date";
              break;
            case p.invalid_string:
              "object" == typeof e.validation
                ? "includes" in e.validation
                  ? ((r = `Invalid input: must include "${e.validation.includes}"`),
                    "number" == typeof e.validation.position &&
                      (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`))
                  : "startsWith" in e.validation
                  ? (r = `Invalid input: must start with "${e.validation.startsWith}"`)
                  : "endsWith" in e.validation
                  ? (r = `Invalid input: must end with "${e.validation.endsWith}"`)
                  : s.assertNever(e.validation)
                : (r =
                    "regex" !== e.validation
                      ? `Invalid ${e.validation}`
                      : "Invalid");
              break;
            case p.too_small:
              r =
                "array" === e.type
                  ? `Array must contain ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "at least"
                        : "more than"
                    } ${e.minimum} element(s)`
                  : "string" === e.type
                  ? `String must contain ${
                      e.exact ? "exactly" : e.inclusive ? "at least" : "over"
                    } ${e.minimum} character(s)`
                  : "number" === e.type
                  ? `Number must be ${
                      e.exact
                        ? "exactly equal to "
                        : e.inclusive
                        ? "greater than or equal to "
                        : "greater than "
                    }${e.minimum}`
                  : "date" === e.type
                  ? `Date must be ${
                      e.exact
                        ? "exactly equal to "
                        : e.inclusive
                        ? "greater than or equal to "
                        : "greater than "
                    }${new Date(Number(e.minimum))}`
                  : "Invalid input";
              break;
            case p.too_big:
              r =
                "array" === e.type
                  ? `Array must contain ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "at most"
                        : "less than"
                    } ${e.maximum} element(s)`
                  : "string" === e.type
                  ? `String must contain ${
                      e.exact ? "exactly" : e.inclusive ? "at most" : "under"
                    } ${e.maximum} character(s)`
                  : "number" === e.type
                  ? `Number must be ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "less than or equal to"
                        : "less than"
                    } ${e.maximum}`
                  : "bigint" === e.type
                  ? `BigInt must be ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "less than or equal to"
                        : "less than"
                    } ${e.maximum}`
                  : "date" === e.type
                  ? `Date must be ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "smaller than or equal to"
                        : "smaller than"
                    } ${new Date(Number(e.maximum))}`
                  : "Invalid input";
              break;
            case p.custom:
              r = "Invalid input";
              break;
            case p.invalid_intersection_types:
              r = "Intersection results could not be merged";
              break;
            case p.not_multiple_of:
              r = `Number must be a multiple of ${e.multipleOf}`;
              break;
            case p.not_finite:
              r = "Number must be finite";
              break;
            default:
              (r = t.defaultError), s.assertNever(e);
          }
          return { message: r };
        },
        m = g;
      function y() {
        return m;
      }
      let b = (e) => {
        let { data: t, path: r, errorMaps: i, issueData: s } = e,
          n = [...r, ...(s.path || [])],
          a = { ...s, path: n },
          o = "";
        for (let e of i
          .filter((e) => !!e)
          .slice()
          .reverse())
          o = e(a, { data: t, defaultError: o }).message;
        return { ...s, path: n, message: s.message || o };
      };
      function w(e, t) {
        let r = b({
          issueData: t,
          data: e.data,
          path: e.path,
          errorMaps: [
            e.common.contextualErrorMap,
            e.schemaErrorMap,
            y(),
            g,
          ].filter((e) => !!e),
        });
        e.common.issues.push(r);
      }
      class v {
        constructor() {
          this.value = "valid";
        }
        dirty() {
          "valid" === this.value && (this.value = "dirty");
        }
        abort() {
          "aborted" !== this.value && (this.value = "aborted");
        }
        static mergeArray(e, t) {
          let r = [];
          for (let i of t) {
            if ("aborted" === i.status) return E;
            "dirty" === i.status && e.dirty(), r.push(i.value);
          }
          return { status: e.value, value: r };
        }
        static async mergeObjectAsync(e, t) {
          let r = [];
          for (let e of t) r.push({ key: await e.key, value: await e.value });
          return v.mergeObjectSync(e, r);
        }
        static mergeObjectSync(e, t) {
          let r = {};
          for (let i of t) {
            let { key: t, value: s } = i;
            if ("aborted" === t.status || "aborted" === s.status) return E;
            "dirty" === t.status && e.dirty(),
              "dirty" === s.status && e.dirty(),
              "__proto__" !== t.value &&
                (void 0 !== s.value || i.alwaysSet) &&
                (r[t.value] = s.value);
          }
          return { status: e.value, value: r };
        }
      }
      let E = Object.freeze({ status: "aborted" }),
        _ = (e) => ({ status: "dirty", value: e }),
        C = (e) => ({ status: "valid", value: e }),
        A = (e) => "aborted" === e.status,
        I = (e) => "dirty" === e.status,
        S = (e) => "valid" === e.status,
        N = (e) => "undefined" != typeof Promise && e instanceof Promise;
      !(function (e) {
        (e.errToObj = (e) => ("string" == typeof e ? { message: e } : e || {})),
          (e.toString = (e) =>
            "string" == typeof e ? e : null == e ? void 0 : e.message);
      })(a || (a = {}));
      class T {
        constructor(e, t, r, i) {
          (this._cachedPath = []),
            (this.parent = e),
            (this.data = t),
            (this._path = r),
            (this._key = i);
        }
        get path() {
          return (
            this._cachedPath.length ||
              (this._key instanceof Array
                ? this._cachedPath.push(...this._path, ...this._key)
                : this._cachedPath.push(...this._path, this._key)),
            this._cachedPath
          );
        }
      }
      let O = (e, t) => {
        if (S(t)) return { success: !0, data: t.value };
        if (!e.common.issues.length)
          throw Error("Validation failed but no issues detected.");
        return {
          success: !1,
          get error() {
            if (this._error) return this._error;
            let t = new f(e.common.issues);
            return (this._error = t), this._error;
          },
        };
      };
      function x(e) {
        if (!e) return {};
        let {
          errorMap: t,
          invalid_type_error: r,
          required_error: i,
          description: s,
        } = e;
        if (t && (r || i))
          throw Error(
            'Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.'
          );
        return t
          ? { errorMap: t, description: s }
          : {
              errorMap: (e, t) =>
                "invalid_type" !== e.code
                  ? { message: t.defaultError }
                  : void 0 === t.data
                  ? { message: null != i ? i : t.defaultError }
                  : { message: null != r ? r : t.defaultError },
              description: s,
            };
      }
      class P {
        constructor(e) {
          (this.spa = this.safeParseAsync),
            (this._def = e),
            (this.parse = this.parse.bind(this)),
            (this.safeParse = this.safeParse.bind(this)),
            (this.parseAsync = this.parseAsync.bind(this)),
            (this.safeParseAsync = this.safeParseAsync.bind(this)),
            (this.spa = this.spa.bind(this)),
            (this.refine = this.refine.bind(this)),
            (this.refinement = this.refinement.bind(this)),
            (this.superRefine = this.superRefine.bind(this)),
            (this.optional = this.optional.bind(this)),
            (this.nullable = this.nullable.bind(this)),
            (this.nullish = this.nullish.bind(this)),
            (this.array = this.array.bind(this)),
            (this.promise = this.promise.bind(this)),
            (this.or = this.or.bind(this)),
            (this.and = this.and.bind(this)),
            (this.transform = this.transform.bind(this)),
            (this.brand = this.brand.bind(this)),
            (this.default = this.default.bind(this)),
            (this.catch = this.catch.bind(this)),
            (this.describe = this.describe.bind(this)),
            (this.pipe = this.pipe.bind(this)),
            (this.readonly = this.readonly.bind(this)),
            (this.isNullable = this.isNullable.bind(this)),
            (this.isOptional = this.isOptional.bind(this));
        }
        get description() {
          return this._def.description;
        }
        _getType(e) {
          return h(e.data);
        }
        _getOrReturnCtx(e, t) {
          return (
            t || {
              common: e.parent.common,
              data: e.data,
              parsedType: h(e.data),
              schemaErrorMap: this._def.errorMap,
              path: e.path,
              parent: e.parent,
            }
          );
        }
        _processInputParams(e) {
          return {
            status: new v(),
            ctx: {
              common: e.parent.common,
              data: e.data,
              parsedType: h(e.data),
              schemaErrorMap: this._def.errorMap,
              path: e.path,
              parent: e.parent,
            },
          };
        }
        _parseSync(e) {
          let t = this._parse(e);
          if (N(t)) throw Error("Synchronous parse encountered promise.");
          return t;
        }
        _parseAsync(e) {
          return Promise.resolve(this._parse(e));
        }
        parse(e, t) {
          let r = this.safeParse(e, t);
          if (r.success) return r.data;
          throw r.error;
        }
        safeParse(e, t) {
          var r;
          let i = {
              common: {
                issues: [],
                async: null != (r = null == t ? void 0 : t.async) && r,
                contextualErrorMap: null == t ? void 0 : t.errorMap,
              },
              path: (null == t ? void 0 : t.path) || [],
              schemaErrorMap: this._def.errorMap,
              parent: null,
              data: e,
              parsedType: h(e),
            },
            s = this._parseSync({ data: e, path: i.path, parent: i });
          return O(i, s);
        }
        async parseAsync(e, t) {
          let r = await this.safeParseAsync(e, t);
          if (r.success) return r.data;
          throw r.error;
        }
        async safeParseAsync(e, t) {
          let r = {
              common: {
                issues: [],
                contextualErrorMap: null == t ? void 0 : t.errorMap,
                async: !0,
              },
              path: (null == t ? void 0 : t.path) || [],
              schemaErrorMap: this._def.errorMap,
              parent: null,
              data: e,
              parsedType: h(e),
            },
            i = this._parse({ data: e, path: r.path, parent: r });
          return O(r, await (N(i) ? i : Promise.resolve(i)));
        }
        refine(e, t) {
          let r = (e) =>
            "string" == typeof t || void 0 === t
              ? { message: t }
              : "function" == typeof t
              ? t(e)
              : t;
          return this._refinement((t, i) => {
            let s = e(t),
              n = () => i.addIssue({ code: p.custom, ...r(t) });
            return "undefined" != typeof Promise && s instanceof Promise
              ? s.then((e) => !!e || (n(), !1))
              : !!s || (n(), !1);
          });
        }
        refinement(e, t) {
          return this._refinement(
            (r, i) =>
              !!e(r) || (i.addIssue("function" == typeof t ? t(r, i) : t), !1)
          );
        }
        _refinement(e) {
          return new eg({
            schema: this,
            typeName: o.ZodEffects,
            effect: { type: "refinement", refinement: e },
          });
        }
        superRefine(e) {
          return this._refinement(e);
        }
        optional() {
          return em.create(this, this._def);
        }
        nullable() {
          return ey.create(this, this._def);
        }
        nullish() {
          return this.nullable().optional();
        }
        array() {
          return X.create(this, this._def);
        }
        promise() {
          return ef.create(this, this._def);
        }
        or(e) {
          return ee.create([this, e], this._def);
        }
        and(e) {
          return ei.create(this, e, this._def);
        }
        transform(e) {
          return new eg({
            ...x(this._def),
            schema: this,
            typeName: o.ZodEffects,
            effect: { type: "transform", transform: e },
          });
        }
        default(e) {
          return new eb({
            ...x(this._def),
            innerType: this,
            defaultValue: "function" == typeof e ? e : () => e,
            typeName: o.ZodDefault,
          });
        }
        brand() {
          return new e_({
            typeName: o.ZodBranded,
            type: this,
            ...x(this._def),
          });
        }
        catch(e) {
          return new ew({
            ...x(this._def),
            innerType: this,
            catchValue: "function" == typeof e ? e : () => e,
            typeName: o.ZodCatch,
          });
        }
        describe(e) {
          return new this.constructor({ ...this._def, description: e });
        }
        pipe(e) {
          return eC.create(this, e);
        }
        readonly() {
          return eA.create(this);
        }
        isOptional() {
          return this.safeParse(void 0).success;
        }
        isNullable() {
          return this.safeParse(null).success;
        }
      }
      let R = /^c[^\s-]{8,}$/i,
        k = /^[a-z][a-z0-9]*$/,
        D = /^[0-9A-HJKMNP-TV-Z]{26}$/,
        U =
          /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
        L =
          /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
        M =
          /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/,
        j =
          /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
        $ = (e) => {
          if (e.precision)
            if (e.offset)
              return RegExp(
                `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
              );
            else
              return RegExp(
                `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`
              );
          if (0 === e.precision)
            if (e.offset)
              return RegExp(
                "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$"
              );
            else return RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$");
          return e.offset
            ? RegExp(
                "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$"
              )
            : RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
        };
      class B extends P {
        _parse(e) {
          let t;
          if (
            (this._def.coerce && (e.data = String(e.data)),
            this._getType(e) !== d.string)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: p.invalid_type,
                expected: d.string,
                received: t.parsedType,
              }),
              E
            );
          }
          let r = new v();
          for (let o of this._def.checks)
            if ("min" === o.kind)
              e.data.length < o.value &&
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: p.too_small,
                  minimum: o.value,
                  type: "string",
                  inclusive: !0,
                  exact: !1,
                  message: o.message,
                }),
                r.dirty());
            else if ("max" === o.kind)
              e.data.length > o.value &&
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: p.too_big,
                  maximum: o.value,
                  type: "string",
                  inclusive: !0,
                  exact: !1,
                  message: o.message,
                }),
                r.dirty());
            else if ("length" === o.kind) {
              let i = e.data.length > o.value,
                s = e.data.length < o.value;
              (i || s) &&
                ((t = this._getOrReturnCtx(e, t)),
                i
                  ? w(t, {
                      code: p.too_big,
                      maximum: o.value,
                      type: "string",
                      inclusive: !0,
                      exact: !0,
                      message: o.message,
                    })
                  : s &&
                    w(t, {
                      code: p.too_small,
                      minimum: o.value,
                      type: "string",
                      inclusive: !0,
                      exact: !0,
                      message: o.message,
                    }),
                r.dirty());
            } else if ("email" === o.kind)
              L.test(e.data) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  validation: "email",
                  code: p.invalid_string,
                  message: o.message,
                }),
                r.dirty());
            else if ("emoji" === o.kind)
              i ||
                (i = RegExp(
                  "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
                  "u"
                )),
                i.test(e.data) ||
                  (w((t = this._getOrReturnCtx(e, t)), {
                    validation: "emoji",
                    code: p.invalid_string,
                    message: o.message,
                  }),
                  r.dirty());
            else if ("uuid" === o.kind)
              U.test(e.data) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  validation: "uuid",
                  code: p.invalid_string,
                  message: o.message,
                }),
                r.dirty());
            else if ("cuid" === o.kind)
              R.test(e.data) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  validation: "cuid",
                  code: p.invalid_string,
                  message: o.message,
                }),
                r.dirty());
            else if ("cuid2" === o.kind)
              k.test(e.data) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  validation: "cuid2",
                  code: p.invalid_string,
                  message: o.message,
                }),
                r.dirty());
            else if ("ulid" === o.kind)
              D.test(e.data) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  validation: "ulid",
                  code: p.invalid_string,
                  message: o.message,
                }),
                r.dirty());
            else if ("url" === o.kind)
              try {
                new URL(e.data);
              } catch (i) {
                w((t = this._getOrReturnCtx(e, t)), {
                  validation: "url",
                  code: p.invalid_string,
                  message: o.message,
                }),
                  r.dirty();
              }
            else if ("regex" === o.kind)
              (o.regex.lastIndex = 0),
                o.regex.test(e.data) ||
                  (w((t = this._getOrReturnCtx(e, t)), {
                    validation: "regex",
                    code: p.invalid_string,
                    message: o.message,
                  }),
                  r.dirty());
            else if ("trim" === o.kind) e.data = e.data.trim();
            else if ("includes" === o.kind)
              e.data.includes(o.value, o.position) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: p.invalid_string,
                  validation: { includes: o.value, position: o.position },
                  message: o.message,
                }),
                r.dirty());
            else if ("toLowerCase" === o.kind) e.data = e.data.toLowerCase();
            else if ("toUpperCase" === o.kind) e.data = e.data.toUpperCase();
            else if ("startsWith" === o.kind)
              e.data.startsWith(o.value) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: p.invalid_string,
                  validation: { startsWith: o.value },
                  message: o.message,
                }),
                r.dirty());
            else if ("endsWith" === o.kind)
              e.data.endsWith(o.value) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: p.invalid_string,
                  validation: { endsWith: o.value },
                  message: o.message,
                }),
                r.dirty());
            else if ("datetime" === o.kind)
              $(o).test(e.data) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: p.invalid_string,
                  validation: "datetime",
                  message: o.message,
                }),
                r.dirty());
            else if ("ip" === o.kind) {
              var n, a;
              (n = e.data),
                !(
                  (("v4" === (a = o.version) || !a) && M.test(n)) ||
                  (("v6" === a || !a) && j.test(n))
                ) &&
                  1 &&
                  (w((t = this._getOrReturnCtx(e, t)), {
                    validation: "ip",
                    code: p.invalid_string,
                    message: o.message,
                  }),
                  r.dirty());
            } else s.assertNever(o);
          return { status: r.value, value: e.data };
        }
        _regex(e, t, r) {
          return this.refinement((t) => e.test(t), {
            validation: t,
            code: p.invalid_string,
            ...a.errToObj(r),
          });
        }
        _addCheck(e) {
          return new B({ ...this._def, checks: [...this._def.checks, e] });
        }
        email(e) {
          return this._addCheck({ kind: "email", ...a.errToObj(e) });
        }
        url(e) {
          return this._addCheck({ kind: "url", ...a.errToObj(e) });
        }
        emoji(e) {
          return this._addCheck({ kind: "emoji", ...a.errToObj(e) });
        }
        uuid(e) {
          return this._addCheck({ kind: "uuid", ...a.errToObj(e) });
        }
        cuid(e) {
          return this._addCheck({ kind: "cuid", ...a.errToObj(e) });
        }
        cuid2(e) {
          return this._addCheck({ kind: "cuid2", ...a.errToObj(e) });
        }
        ulid(e) {
          return this._addCheck({ kind: "ulid", ...a.errToObj(e) });
        }
        ip(e) {
          return this._addCheck({ kind: "ip", ...a.errToObj(e) });
        }
        datetime(e) {
          var t;
          return "string" == typeof e
            ? this._addCheck({
                kind: "datetime",
                precision: null,
                offset: !1,
                message: e,
              })
            : this._addCheck({
                kind: "datetime",
                precision:
                  void 0 === (null == e ? void 0 : e.precision)
                    ? null
                    : null == e
                    ? void 0
                    : e.precision,
                offset: null != (t = null == e ? void 0 : e.offset) && t,
                ...a.errToObj(null == e ? void 0 : e.message),
              });
        }
        regex(e, t) {
          return this._addCheck({ kind: "regex", regex: e, ...a.errToObj(t) });
        }
        includes(e, t) {
          return this._addCheck({
            kind: "includes",
            value: e,
            position: null == t ? void 0 : t.position,
            ...a.errToObj(null == t ? void 0 : t.message),
          });
        }
        startsWith(e, t) {
          return this._addCheck({
            kind: "startsWith",
            value: e,
            ...a.errToObj(t),
          });
        }
        endsWith(e, t) {
          return this._addCheck({
            kind: "endsWith",
            value: e,
            ...a.errToObj(t),
          });
        }
        min(e, t) {
          return this._addCheck({ kind: "min", value: e, ...a.errToObj(t) });
        }
        max(e, t) {
          return this._addCheck({ kind: "max", value: e, ...a.errToObj(t) });
        }
        length(e, t) {
          return this._addCheck({ kind: "length", value: e, ...a.errToObj(t) });
        }
        nonempty(e) {
          return this.min(1, a.errToObj(e));
        }
        trim() {
          return new B({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
          });
        }
        toLowerCase() {
          return new B({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }],
          });
        }
        toUpperCase() {
          return new B({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }],
          });
        }
        get isDatetime() {
          return !!this._def.checks.find((e) => "datetime" === e.kind);
        }
        get isEmail() {
          return !!this._def.checks.find((e) => "email" === e.kind);
        }
        get isURL() {
          return !!this._def.checks.find((e) => "url" === e.kind);
        }
        get isEmoji() {
          return !!this._def.checks.find((e) => "emoji" === e.kind);
        }
        get isUUID() {
          return !!this._def.checks.find((e) => "uuid" === e.kind);
        }
        get isCUID() {
          return !!this._def.checks.find((e) => "cuid" === e.kind);
        }
        get isCUID2() {
          return !!this._def.checks.find((e) => "cuid2" === e.kind);
        }
        get isULID() {
          return !!this._def.checks.find((e) => "ulid" === e.kind);
        }
        get isIP() {
          return !!this._def.checks.find((e) => "ip" === e.kind);
        }
        get minLength() {
          let e = null;
          for (let t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
          return e;
        }
        get maxLength() {
          let e = null;
          for (let t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
          return e;
        }
      }
      B.create = (e) => {
        var t;
        return new B({
          checks: [],
          typeName: o.ZodString,
          coerce: null != (t = null == e ? void 0 : e.coerce) && t,
          ...x(e),
        });
      };
      class F extends P {
        constructor() {
          super(...arguments),
            (this.min = this.gte),
            (this.max = this.lte),
            (this.step = this.multipleOf);
        }
        _parse(e) {
          let t;
          if (
            (this._def.coerce && (e.data = Number(e.data)),
            this._getType(e) !== d.number)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: p.invalid_type,
                expected: d.number,
                received: t.parsedType,
              }),
              E
            );
          }
          let r = new v();
          for (let i of this._def.checks)
            "int" === i.kind
              ? s.isInteger(e.data) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: p.invalid_type,
                  expected: "integer",
                  received: "float",
                  message: i.message,
                }),
                r.dirty())
              : "min" === i.kind
              ? (i.inclusive ? e.data < i.value : e.data <= i.value) &&
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: p.too_small,
                  minimum: i.value,
                  type: "number",
                  inclusive: i.inclusive,
                  exact: !1,
                  message: i.message,
                }),
                r.dirty())
              : "max" === i.kind
              ? (i.inclusive ? e.data > i.value : e.data >= i.value) &&
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: p.too_big,
                  maximum: i.value,
                  type: "number",
                  inclusive: i.inclusive,
                  exact: !1,
                  message: i.message,
                }),
                r.dirty())
              : "multipleOf" === i.kind
              ? 0 !==
                  (function (e, t) {
                    let r = (e.toString().split(".")[1] || "").length,
                      i = (t.toString().split(".")[1] || "").length,
                      s = r > i ? r : i;
                    return (
                      (parseInt(e.toFixed(s).replace(".", "")) %
                        parseInt(t.toFixed(s).replace(".", ""))) /
                      Math.pow(10, s)
                    );
                  })(e.data, i.value) &&
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: p.not_multiple_of,
                  multipleOf: i.value,
                  message: i.message,
                }),
                r.dirty())
              : "finite" === i.kind
              ? Number.isFinite(e.data) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: p.not_finite,
                  message: i.message,
                }),
                r.dirty())
              : s.assertNever(i);
          return { status: r.value, value: e.data };
        }
        gte(e, t) {
          return this.setLimit("min", e, !0, a.toString(t));
        }
        gt(e, t) {
          return this.setLimit("min", e, !1, a.toString(t));
        }
        lte(e, t) {
          return this.setLimit("max", e, !0, a.toString(t));
        }
        lt(e, t) {
          return this.setLimit("max", e, !1, a.toString(t));
        }
        setLimit(e, t, r, i) {
          return new F({
            ...this._def,
            checks: [
              ...this._def.checks,
              { kind: e, value: t, inclusive: r, message: a.toString(i) },
            ],
          });
        }
        _addCheck(e) {
          return new F({ ...this._def, checks: [...this._def.checks, e] });
        }
        int(e) {
          return this._addCheck({ kind: "int", message: a.toString(e) });
        }
        positive(e) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: a.toString(e),
          });
        }
        negative(e) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: a.toString(e),
          });
        }
        nonpositive(e) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: a.toString(e),
          });
        }
        nonnegative(e) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: a.toString(e),
          });
        }
        multipleOf(e, t) {
          return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: a.toString(t),
          });
        }
        finite(e) {
          return this._addCheck({ kind: "finite", message: a.toString(e) });
        }
        safe(e) {
          return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: a.toString(e),
          })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: a.toString(e),
          });
        }
        get minValue() {
          let e = null;
          for (let t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
          return e;
        }
        get maxValue() {
          let e = null;
          for (let t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
          return e;
        }
        get isInt() {
          return !!this._def.checks.find(
            (e) =>
              "int" === e.kind ||
              ("multipleOf" === e.kind && s.isInteger(e.value))
          );
        }
        get isFinite() {
          let e = null,
            t = null;
          for (let r of this._def.checks)
            if (
              "finite" === r.kind ||
              "int" === r.kind ||
              "multipleOf" === r.kind
            )
              return !0;
            else
              "min" === r.kind
                ? (null === t || r.value > t) && (t = r.value)
                : "max" === r.kind &&
                  (null === e || r.value < e) &&
                  (e = r.value);
          return Number.isFinite(t) && Number.isFinite(e);
        }
      }
      F.create = (e) =>
        new F({
          checks: [],
          typeName: o.ZodNumber,
          coerce: (null == e ? void 0 : e.coerce) || !1,
          ...x(e),
        });
      class W extends P {
        constructor() {
          super(...arguments), (this.min = this.gte), (this.max = this.lte);
        }
        _parse(e) {
          let t;
          if (
            (this._def.coerce && (e.data = BigInt(e.data)),
            this._getType(e) !== d.bigint)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: p.invalid_type,
                expected: d.bigint,
                received: t.parsedType,
              }),
              E
            );
          }
          let r = new v();
          for (let i of this._def.checks)
            "min" === i.kind
              ? (i.inclusive ? e.data < i.value : e.data <= i.value) &&
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: p.too_small,
                  type: "bigint",
                  minimum: i.value,
                  inclusive: i.inclusive,
                  message: i.message,
                }),
                r.dirty())
              : "max" === i.kind
              ? (i.inclusive ? e.data > i.value : e.data >= i.value) &&
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: p.too_big,
                  type: "bigint",
                  maximum: i.value,
                  inclusive: i.inclusive,
                  message: i.message,
                }),
                r.dirty())
              : "multipleOf" === i.kind
              ? e.data % i.value !== BigInt(0) &&
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: p.not_multiple_of,
                  multipleOf: i.value,
                  message: i.message,
                }),
                r.dirty())
              : s.assertNever(i);
          return { status: r.value, value: e.data };
        }
        gte(e, t) {
          return this.setLimit("min", e, !0, a.toString(t));
        }
        gt(e, t) {
          return this.setLimit("min", e, !1, a.toString(t));
        }
        lte(e, t) {
          return this.setLimit("max", e, !0, a.toString(t));
        }
        lt(e, t) {
          return this.setLimit("max", e, !1, a.toString(t));
        }
        setLimit(e, t, r, i) {
          return new W({
            ...this._def,
            checks: [
              ...this._def.checks,
              { kind: e, value: t, inclusive: r, message: a.toString(i) },
            ],
          });
        }
        _addCheck(e) {
          return new W({ ...this._def, checks: [...this._def.checks, e] });
        }
        positive(e) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: a.toString(e),
          });
        }
        negative(e) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: a.toString(e),
          });
        }
        nonpositive(e) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: a.toString(e),
          });
        }
        nonnegative(e) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: a.toString(e),
          });
        }
        multipleOf(e, t) {
          return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: a.toString(t),
          });
        }
        get minValue() {
          let e = null;
          for (let t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
          return e;
        }
        get maxValue() {
          let e = null;
          for (let t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
          return e;
        }
      }
      W.create = (e) => {
        var t;
        return new W({
          checks: [],
          typeName: o.ZodBigInt,
          coerce: null != (t = null == e ? void 0 : e.coerce) && t,
          ...x(e),
        });
      };
      class q extends P {
        _parse(e) {
          if (
            (this._def.coerce && (e.data = !!e.data),
            this._getType(e) !== d.boolean)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: p.invalid_type,
                expected: d.boolean,
                received: t.parsedType,
              }),
              E
            );
          }
          return C(e.data);
        }
      }
      q.create = (e) =>
        new q({
          typeName: o.ZodBoolean,
          coerce: (null == e ? void 0 : e.coerce) || !1,
          ...x(e),
        });
      class H extends P {
        _parse(e) {
          let t;
          if (
            (this._def.coerce && (e.data = new Date(e.data)),
            this._getType(e) !== d.date)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: p.invalid_type,
                expected: d.date,
                received: t.parsedType,
              }),
              E
            );
          }
          if (isNaN(e.data.getTime()))
            return w(this._getOrReturnCtx(e), { code: p.invalid_date }), E;
          let r = new v();
          for (let i of this._def.checks)
            "min" === i.kind
              ? e.data.getTime() < i.value &&
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: p.too_small,
                  message: i.message,
                  inclusive: !0,
                  exact: !1,
                  minimum: i.value,
                  type: "date",
                }),
                r.dirty())
              : "max" === i.kind
              ? e.data.getTime() > i.value &&
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: p.too_big,
                  message: i.message,
                  inclusive: !0,
                  exact: !1,
                  maximum: i.value,
                  type: "date",
                }),
                r.dirty())
              : s.assertNever(i);
          return { status: r.value, value: new Date(e.data.getTime()) };
        }
        _addCheck(e) {
          return new H({ ...this._def, checks: [...this._def.checks, e] });
        }
        min(e, t) {
          return this._addCheck({
            kind: "min",
            value: e.getTime(),
            message: a.toString(t),
          });
        }
        max(e, t) {
          return this._addCheck({
            kind: "max",
            value: e.getTime(),
            message: a.toString(t),
          });
        }
        get minDate() {
          let e = null;
          for (let t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
          return null != e ? new Date(e) : null;
        }
        get maxDate() {
          let e = null;
          for (let t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
          return null != e ? new Date(e) : null;
        }
      }
      H.create = (e) =>
        new H({
          checks: [],
          coerce: (null == e ? void 0 : e.coerce) || !1,
          typeName: o.ZodDate,
          ...x(e),
        });
      class z extends P {
        _parse(e) {
          if (this._getType(e) !== d.symbol) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: p.invalid_type,
                expected: d.symbol,
                received: t.parsedType,
              }),
              E
            );
          }
          return C(e.data);
        }
      }
      z.create = (e) => new z({ typeName: o.ZodSymbol, ...x(e) });
      class V extends P {
        _parse(e) {
          if (this._getType(e) !== d.undefined) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: p.invalid_type,
                expected: d.undefined,
                received: t.parsedType,
              }),
              E
            );
          }
          return C(e.data);
        }
      }
      V.create = (e) => new V({ typeName: o.ZodUndefined, ...x(e) });
      class K extends P {
        _parse(e) {
          if (this._getType(e) !== d.null) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: p.invalid_type,
                expected: d.null,
                received: t.parsedType,
              }),
              E
            );
          }
          return C(e.data);
        }
      }
      K.create = (e) => new K({ typeName: o.ZodNull, ...x(e) });
      class G extends P {
        constructor() {
          super(...arguments), (this._any = !0);
        }
        _parse(e) {
          return C(e.data);
        }
      }
      G.create = (e) => new G({ typeName: o.ZodAny, ...x(e) });
      class Y extends P {
        constructor() {
          super(...arguments), (this._unknown = !0);
        }
        _parse(e) {
          return C(e.data);
        }
      }
      Y.create = (e) => new Y({ typeName: o.ZodUnknown, ...x(e) });
      class Z extends P {
        _parse(e) {
          let t = this._getOrReturnCtx(e);
          return (
            w(t, {
              code: p.invalid_type,
              expected: d.never,
              received: t.parsedType,
            }),
            E
          );
        }
      }
      Z.create = (e) => new Z({ typeName: o.ZodNever, ...x(e) });
      class J extends P {
        _parse(e) {
          if (this._getType(e) !== d.undefined) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: p.invalid_type,
                expected: d.void,
                received: t.parsedType,
              }),
              E
            );
          }
          return C(e.data);
        }
      }
      J.create = (e) => new J({ typeName: o.ZodVoid, ...x(e) });
      class X extends P {
        _parse(e) {
          let { ctx: t, status: r } = this._processInputParams(e),
            i = this._def;
          if (t.parsedType !== d.array)
            return (
              w(t, {
                code: p.invalid_type,
                expected: d.array,
                received: t.parsedType,
              }),
              E
            );
          if (null !== i.exactLength) {
            let e = t.data.length > i.exactLength.value,
              s = t.data.length < i.exactLength.value;
            (e || s) &&
              (w(t, {
                code: e ? p.too_big : p.too_small,
                minimum: s ? i.exactLength.value : void 0,
                maximum: e ? i.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: i.exactLength.message,
              }),
              r.dirty());
          }
          if (
            (null !== i.minLength &&
              t.data.length < i.minLength.value &&
              (w(t, {
                code: p.too_small,
                minimum: i.minLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: i.minLength.message,
              }),
              r.dirty()),
            null !== i.maxLength &&
              t.data.length > i.maxLength.value &&
              (w(t, {
                code: p.too_big,
                maximum: i.maxLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: i.maxLength.message,
              }),
              r.dirty()),
            t.common.async)
          )
            return Promise.all(
              [...t.data].map((e, r) =>
                i.type._parseAsync(new T(t, e, t.path, r))
              )
            ).then((e) => v.mergeArray(r, e));
          let s = [...t.data].map((e, r) =>
            i.type._parseSync(new T(t, e, t.path, r))
          );
          return v.mergeArray(r, s);
        }
        get element() {
          return this._def.type;
        }
        min(e, t) {
          return new X({
            ...this._def,
            minLength: { value: e, message: a.toString(t) },
          });
        }
        max(e, t) {
          return new X({
            ...this._def,
            maxLength: { value: e, message: a.toString(t) },
          });
        }
        length(e, t) {
          return new X({
            ...this._def,
            exactLength: { value: e, message: a.toString(t) },
          });
        }
        nonempty(e) {
          return this.min(1, e);
        }
      }
      X.create = (e, t) =>
        new X({
          type: e,
          minLength: null,
          maxLength: null,
          exactLength: null,
          typeName: o.ZodArray,
          ...x(t),
        });
      class Q extends P {
        constructor() {
          super(...arguments),
            (this._cached = null),
            (this.nonstrict = this.passthrough),
            (this.augment = this.extend);
        }
        _getCached() {
          if (null !== this._cached) return this._cached;
          let e = this._def.shape(),
            t = s.objectKeys(e);
          return (this._cached = { shape: e, keys: t });
        }
        _parse(e) {
          if (this._getType(e) !== d.object) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: p.invalid_type,
                expected: d.object,
                received: t.parsedType,
              }),
              E
            );
          }
          let { status: t, ctx: r } = this._processInputParams(e),
            { shape: i, keys: s } = this._getCached(),
            n = [];
          if (
            !(
              this._def.catchall instanceof Z &&
              "strip" === this._def.unknownKeys
            )
          )
            for (let e in r.data) s.includes(e) || n.push(e);
          let a = [];
          for (let e of s) {
            let t = i[e],
              s = r.data[e];
            a.push({
              key: { status: "valid", value: e },
              value: t._parse(new T(r, s, r.path, e)),
              alwaysSet: e in r.data,
            });
          }
          if (this._def.catchall instanceof Z) {
            let e = this._def.unknownKeys;
            if ("passthrough" === e)
              for (let e of n)
                a.push({
                  key: { status: "valid", value: e },
                  value: { status: "valid", value: r.data[e] },
                });
            else if ("strict" === e)
              n.length > 0 &&
                (w(r, { code: p.unrecognized_keys, keys: n }), t.dirty());
            else if ("strip" === e);
            else
              throw Error(
                "Internal ZodObject error: invalid unknownKeys value."
              );
          } else {
            let e = this._def.catchall;
            for (let t of n) {
              let i = r.data[t];
              a.push({
                key: { status: "valid", value: t },
                value: e._parse(new T(r, i, r.path, t)),
                alwaysSet: t in r.data,
              });
            }
          }
          return r.common.async
            ? Promise.resolve()
                .then(async () => {
                  let e = [];
                  for (let t of a) {
                    let r = await t.key;
                    e.push({
                      key: r,
                      value: await t.value,
                      alwaysSet: t.alwaysSet,
                    });
                  }
                  return e;
                })
                .then((e) => v.mergeObjectSync(t, e))
            : v.mergeObjectSync(t, a);
        }
        get shape() {
          return this._def.shape();
        }
        strict(e) {
          return (
            a.errToObj,
            new Q({
              ...this._def,
              unknownKeys: "strict",
              ...(void 0 !== e
                ? {
                    errorMap: (t, r) => {
                      var i, s, n, o;
                      let c =
                        null !=
                        (n =
                          null == (s = (i = this._def).errorMap)
                            ? void 0
                            : s.call(i, t, r).message)
                          ? n
                          : r.defaultError;
                      return "unrecognized_keys" === t.code
                        ? {
                            message:
                              null != (o = a.errToObj(e).message) ? o : c,
                          }
                        : { message: c };
                    },
                  }
                : {}),
            })
          );
        }
        strip() {
          return new Q({ ...this._def, unknownKeys: "strip" });
        }
        passthrough() {
          return new Q({ ...this._def, unknownKeys: "passthrough" });
        }
        extend(e) {
          return new Q({
            ...this._def,
            shape: () => ({ ...this._def.shape(), ...e }),
          });
        }
        merge(e) {
          return new Q({
            unknownKeys: e._def.unknownKeys,
            catchall: e._def.catchall,
            shape: () => ({ ...this._def.shape(), ...e._def.shape() }),
            typeName: o.ZodObject,
          });
        }
        setKey(e, t) {
          return this.augment({ [e]: t });
        }
        catchall(e) {
          return new Q({ ...this._def, catchall: e });
        }
        pick(e) {
          let t = {};
          return (
            s.objectKeys(e).forEach((r) => {
              e[r] && this.shape[r] && (t[r] = this.shape[r]);
            }),
            new Q({ ...this._def, shape: () => t })
          );
        }
        omit(e) {
          let t = {};
          return (
            s.objectKeys(this.shape).forEach((r) => {
              e[r] || (t[r] = this.shape[r]);
            }),
            new Q({ ...this._def, shape: () => t })
          );
        }
        deepPartial() {
          return (function e(t) {
            if (t instanceof Q) {
              let r = {};
              for (let i in t.shape) {
                let s = t.shape[i];
                r[i] = em.create(e(s));
              }
              return new Q({ ...t._def, shape: () => r });
            }
            if (t instanceof X) return new X({ ...t._def, type: e(t.element) });
            if (t instanceof em) return em.create(e(t.unwrap()));
            if (t instanceof ey) return ey.create(e(t.unwrap()));
            if (t instanceof es) return es.create(t.items.map((t) => e(t)));
            else return t;
          })(this);
        }
        partial(e) {
          let t = {};
          return (
            s.objectKeys(this.shape).forEach((r) => {
              let i = this.shape[r];
              e && !e[r] ? (t[r] = i) : (t[r] = i.optional());
            }),
            new Q({ ...this._def, shape: () => t })
          );
        }
        required(e) {
          let t = {};
          return (
            s.objectKeys(this.shape).forEach((r) => {
              if (e && !e[r]) t[r] = this.shape[r];
              else {
                let e = this.shape[r];
                for (; e instanceof em; ) e = e._def.innerType;
                t[r] = e;
              }
            }),
            new Q({ ...this._def, shape: () => t })
          );
        }
        keyof() {
          return ed(s.objectKeys(this.shape));
        }
      }
      (Q.create = (e, t) =>
        new Q({
          shape: () => e,
          unknownKeys: "strip",
          catchall: Z.create(),
          typeName: o.ZodObject,
          ...x(t),
        })),
        (Q.strictCreate = (e, t) =>
          new Q({
            shape: () => e,
            unknownKeys: "strict",
            catchall: Z.create(),
            typeName: o.ZodObject,
            ...x(t),
          })),
        (Q.lazycreate = (e, t) =>
          new Q({
            shape: e,
            unknownKeys: "strip",
            catchall: Z.create(),
            typeName: o.ZodObject,
            ...x(t),
          }));
      class ee extends P {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            r = this._def.options;
          if (t.common.async)
            return Promise.all(
              r.map(async (e) => {
                let r = {
                  ...t,
                  common: { ...t.common, issues: [] },
                  parent: null,
                };
                return {
                  result: await e._parseAsync({
                    data: t.data,
                    path: t.path,
                    parent: r,
                  }),
                  ctx: r,
                };
              })
            ).then(function (e) {
              for (let t of e) if ("valid" === t.result.status) return t.result;
              for (let r of e)
                if ("dirty" === r.result.status)
                  return t.common.issues.push(...r.ctx.common.issues), r.result;
              let r = e.map((e) => new f(e.ctx.common.issues));
              return w(t, { code: p.invalid_union, unionErrors: r }), E;
            });
          {
            let e,
              i = [];
            for (let s of r) {
              let r = {
                  ...t,
                  common: { ...t.common, issues: [] },
                  parent: null,
                },
                n = s._parseSync({ data: t.data, path: t.path, parent: r });
              if ("valid" === n.status) return n;
              "dirty" !== n.status || e || (e = { result: n, ctx: r }),
                r.common.issues.length && i.push(r.common.issues);
            }
            if (e)
              return t.common.issues.push(...e.ctx.common.issues), e.result;
            let s = i.map((e) => new f(e));
            return w(t, { code: p.invalid_union, unionErrors: s }), E;
          }
        }
        get options() {
          return this._def.options;
        }
      }
      ee.create = (e, t) =>
        new ee({ options: e, typeName: o.ZodUnion, ...x(t) });
      let et = (e) => {
        if (e instanceof el) return et(e.schema);
        if (e instanceof eg) return et(e.innerType());
        if (e instanceof eu) return [e.value];
        if (e instanceof eh) return e.options;
        if (e instanceof ep) return Object.keys(e.enum);
        else if (e instanceof eb) return et(e._def.innerType);
        else if (e instanceof V) return [void 0];
        else if (e instanceof K) return [null];
        else return null;
      };
      class er extends P {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          if (t.parsedType !== d.object)
            return (
              w(t, {
                code: p.invalid_type,
                expected: d.object,
                received: t.parsedType,
              }),
              E
            );
          let r = this.discriminator,
            i = t.data[r],
            s = this.optionsMap.get(i);
          return s
            ? t.common.async
              ? s._parseAsync({ data: t.data, path: t.path, parent: t })
              : s._parseSync({ data: t.data, path: t.path, parent: t })
            : (w(t, {
                code: p.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [r],
              }),
              E);
        }
        get discriminator() {
          return this._def.discriminator;
        }
        get options() {
          return this._def.options;
        }
        get optionsMap() {
          return this._def.optionsMap;
        }
        static create(e, t, r) {
          let i = new Map();
          for (let r of t) {
            let t = et(r.shape[e]);
            if (!t)
              throw Error(
                `A discriminator value for key \`${e}\` could not be extracted from all schema options`
              );
            for (let s of t) {
              if (i.has(s))
                throw Error(
                  `Discriminator property ${String(
                    e
                  )} has duplicate value ${String(s)}`
                );
              i.set(s, r);
            }
          }
          return new er({
            typeName: o.ZodDiscriminatedUnion,
            discriminator: e,
            options: t,
            optionsMap: i,
            ...x(r),
          });
        }
      }
      class ei extends P {
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e),
            i = (e, i) => {
              if (A(e) || A(i)) return E;
              let n = (function e(t, r) {
                let i = h(t),
                  n = h(r);
                if (t === r) return { valid: !0, data: t };
                if (i === d.object && n === d.object) {
                  let i = s.objectKeys(r),
                    n = s.objectKeys(t).filter((e) => -1 !== i.indexOf(e)),
                    a = { ...t, ...r };
                  for (let i of n) {
                    let s = e(t[i], r[i]);
                    if (!s.valid) return { valid: !1 };
                    a[i] = s.data;
                  }
                  return { valid: !0, data: a };
                }
                if (i === d.array && n === d.array) {
                  if (t.length !== r.length) return { valid: !1 };
                  let i = [];
                  for (let s = 0; s < t.length; s++) {
                    let n = e(t[s], r[s]);
                    if (!n.valid) return { valid: !1 };
                    i.push(n.data);
                  }
                  return { valid: !0, data: i };
                }
                if (i === d.date && n === d.date && +t == +r)
                  return { valid: !0, data: t };
                return { valid: !1 };
              })(e.value, i.value);
              return n.valid
                ? ((I(e) || I(i)) && t.dirty(),
                  { status: t.value, value: n.data })
                : (w(r, { code: p.invalid_intersection_types }), E);
            };
          return r.common.async
            ? Promise.all([
                this._def.left._parseAsync({
                  data: r.data,
                  path: r.path,
                  parent: r,
                }),
                this._def.right._parseAsync({
                  data: r.data,
                  path: r.path,
                  parent: r,
                }),
              ]).then(([e, t]) => i(e, t))
            : i(
                this._def.left._parseSync({
                  data: r.data,
                  path: r.path,
                  parent: r,
                }),
                this._def.right._parseSync({
                  data: r.data,
                  path: r.path,
                  parent: r,
                })
              );
        }
      }
      ei.create = (e, t, r) =>
        new ei({ left: e, right: t, typeName: o.ZodIntersection, ...x(r) });
      class es extends P {
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.parsedType !== d.array)
            return (
              w(r, {
                code: p.invalid_type,
                expected: d.array,
                received: r.parsedType,
              }),
              E
            );
          if (r.data.length < this._def.items.length)
            return (
              w(r, {
                code: p.too_small,
                minimum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array",
              }),
              E
            );
          !this._def.rest &&
            r.data.length > this._def.items.length &&
            (w(r, {
              code: p.too_big,
              maximum: this._def.items.length,
              inclusive: !0,
              exact: !1,
              type: "array",
            }),
            t.dirty());
          let i = [...r.data]
            .map((e, t) => {
              let i = this._def.items[t] || this._def.rest;
              return i ? i._parse(new T(r, e, r.path, t)) : null;
            })
            .filter((e) => !!e);
          return r.common.async
            ? Promise.all(i).then((e) => v.mergeArray(t, e))
            : v.mergeArray(t, i);
        }
        get items() {
          return this._def.items;
        }
        rest(e) {
          return new es({ ...this._def, rest: e });
        }
      }
      es.create = (e, t) => {
        if (!Array.isArray(e))
          throw Error("You must pass an array of schemas to z.tuple([ ... ])");
        return new es({ items: e, typeName: o.ZodTuple, rest: null, ...x(t) });
      };
      class en extends P {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.parsedType !== d.object)
            return (
              w(r, {
                code: p.invalid_type,
                expected: d.object,
                received: r.parsedType,
              }),
              E
            );
          let i = [],
            s = this._def.keyType,
            n = this._def.valueType;
          for (let e in r.data)
            i.push({
              key: s._parse(new T(r, e, r.path, e)),
              value: n._parse(new T(r, r.data[e], r.path, e)),
            });
          return r.common.async
            ? v.mergeObjectAsync(t, i)
            : v.mergeObjectSync(t, i);
        }
        get element() {
          return this._def.valueType;
        }
        static create(e, t, r) {
          return new en(
            t instanceof P
              ? { keyType: e, valueType: t, typeName: o.ZodRecord, ...x(r) }
              : {
                  keyType: B.create(),
                  valueType: e,
                  typeName: o.ZodRecord,
                  ...x(t),
                }
          );
        }
      }
      class ea extends P {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.parsedType !== d.map)
            return (
              w(r, {
                code: p.invalid_type,
                expected: d.map,
                received: r.parsedType,
              }),
              E
            );
          let i = this._def.keyType,
            s = this._def.valueType,
            n = [...r.data.entries()].map(([e, t], n) => ({
              key: i._parse(new T(r, e, r.path, [n, "key"])),
              value: s._parse(new T(r, t, r.path, [n, "value"])),
            }));
          if (r.common.async) {
            let e = new Map();
            return Promise.resolve().then(async () => {
              for (let r of n) {
                let i = await r.key,
                  s = await r.value;
                if ("aborted" === i.status || "aborted" === s.status) return E;
                ("dirty" === i.status || "dirty" === s.status) && t.dirty(),
                  e.set(i.value, s.value);
              }
              return { status: t.value, value: e };
            });
          }
          {
            let e = new Map();
            for (let r of n) {
              let i = r.key,
                s = r.value;
              if ("aborted" === i.status || "aborted" === s.status) return E;
              ("dirty" === i.status || "dirty" === s.status) && t.dirty(),
                e.set(i.value, s.value);
            }
            return { status: t.value, value: e };
          }
        }
      }
      ea.create = (e, t, r) =>
        new ea({ valueType: t, keyType: e, typeName: o.ZodMap, ...x(r) });
      class eo extends P {
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.parsedType !== d.set)
            return (
              w(r, {
                code: p.invalid_type,
                expected: d.set,
                received: r.parsedType,
              }),
              E
            );
          let i = this._def;
          null !== i.minSize &&
            r.data.size < i.minSize.value &&
            (w(r, {
              code: p.too_small,
              minimum: i.minSize.value,
              type: "set",
              inclusive: !0,
              exact: !1,
              message: i.minSize.message,
            }),
            t.dirty()),
            null !== i.maxSize &&
              r.data.size > i.maxSize.value &&
              (w(r, {
                code: p.too_big,
                maximum: i.maxSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: i.maxSize.message,
              }),
              t.dirty());
          let s = this._def.valueType;
          function n(e) {
            let r = new Set();
            for (let i of e) {
              if ("aborted" === i.status) return E;
              "dirty" === i.status && t.dirty(), r.add(i.value);
            }
            return { status: t.value, value: r };
          }
          let a = [...r.data.values()].map((e, t) =>
            s._parse(new T(r, e, r.path, t))
          );
          return r.common.async ? Promise.all(a).then((e) => n(e)) : n(a);
        }
        min(e, t) {
          return new eo({
            ...this._def,
            minSize: { value: e, message: a.toString(t) },
          });
        }
        max(e, t) {
          return new eo({
            ...this._def,
            maxSize: { value: e, message: a.toString(t) },
          });
        }
        size(e, t) {
          return this.min(e, t).max(e, t);
        }
        nonempty(e) {
          return this.min(1, e);
        }
      }
      eo.create = (e, t) =>
        new eo({
          valueType: e,
          minSize: null,
          maxSize: null,
          typeName: o.ZodSet,
          ...x(t),
        });
      class ec extends P {
        constructor() {
          super(...arguments), (this.validate = this.implement);
        }
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          if (t.parsedType !== d.function)
            return (
              w(t, {
                code: p.invalid_type,
                expected: d.function,
                received: t.parsedType,
              }),
              E
            );
          function r(e, r) {
            return b({
              data: e,
              path: t.path,
              errorMaps: [
                t.common.contextualErrorMap,
                t.schemaErrorMap,
                y(),
                g,
              ].filter((e) => !!e),
              issueData: { code: p.invalid_arguments, argumentsError: r },
            });
          }
          function i(e, r) {
            return b({
              data: e,
              path: t.path,
              errorMaps: [
                t.common.contextualErrorMap,
                t.schemaErrorMap,
                y(),
                g,
              ].filter((e) => !!e),
              issueData: { code: p.invalid_return_type, returnTypeError: r },
            });
          }
          let s = { errorMap: t.common.contextualErrorMap },
            n = t.data;
          if (this._def.returns instanceof ef) {
            let e = this;
            return C(async function (...t) {
              let a = new f([]),
                o = await e._def.args.parseAsync(t, s).catch((e) => {
                  throw (a.addIssue(r(t, e)), a);
                }),
                c = await Reflect.apply(n, this, o);
              return await e._def.returns._def.type
                .parseAsync(c, s)
                .catch((e) => {
                  throw (a.addIssue(i(c, e)), a);
                });
            });
          }
          {
            let e = this;
            return C(function (...t) {
              let a = e._def.args.safeParse(t, s);
              if (!a.success) throw new f([r(t, a.error)]);
              let o = Reflect.apply(n, this, a.data),
                c = e._def.returns.safeParse(o, s);
              if (!c.success) throw new f([i(o, c.error)]);
              return c.data;
            });
          }
        }
        parameters() {
          return this._def.args;
        }
        returnType() {
          return this._def.returns;
        }
        args(...e) {
          return new ec({ ...this._def, args: es.create(e).rest(Y.create()) });
        }
        returns(e) {
          return new ec({ ...this._def, returns: e });
        }
        implement(e) {
          return this.parse(e);
        }
        strictImplement(e) {
          return this.parse(e);
        }
        static create(e, t, r) {
          return new ec({
            args: e || es.create([]).rest(Y.create()),
            returns: t || Y.create(),
            typeName: o.ZodFunction,
            ...x(r),
          });
        }
      }
      class el extends P {
        get schema() {
          return this._def.getter();
        }
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          return this._def
            .getter()
            ._parse({ data: t.data, path: t.path, parent: t });
        }
      }
      el.create = (e, t) => new el({ getter: e, typeName: o.ZodLazy, ...x(t) });
      class eu extends P {
        _parse(e) {
          if (e.data !== this._def.value) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                received: t.data,
                code: p.invalid_literal,
                expected: this._def.value,
              }),
              E
            );
          }
          return { status: "valid", value: e.data };
        }
        get value() {
          return this._def.value;
        }
      }
      function ed(e, t) {
        return new eh({ values: e, typeName: o.ZodEnum, ...x(t) });
      }
      eu.create = (e, t) =>
        new eu({ value: e, typeName: o.ZodLiteral, ...x(t) });
      class eh extends P {
        _parse(e) {
          if ("string" != typeof e.data) {
            let t = this._getOrReturnCtx(e),
              r = this._def.values;
            return (
              w(t, {
                expected: s.joinValues(r),
                received: t.parsedType,
                code: p.invalid_type,
              }),
              E
            );
          }
          if (-1 === this._def.values.indexOf(e.data)) {
            let t = this._getOrReturnCtx(e),
              r = this._def.values;
            return (
              w(t, {
                received: t.data,
                code: p.invalid_enum_value,
                options: r,
              }),
              E
            );
          }
          return C(e.data);
        }
        get options() {
          return this._def.values;
        }
        get enum() {
          let e = {};
          for (let t of this._def.values) e[t] = t;
          return e;
        }
        get Values() {
          let e = {};
          for (let t of this._def.values) e[t] = t;
          return e;
        }
        get Enum() {
          let e = {};
          for (let t of this._def.values) e[t] = t;
          return e;
        }
        extract(e) {
          return eh.create(e);
        }
        exclude(e) {
          return eh.create(this.options.filter((t) => !e.includes(t)));
        }
      }
      eh.create = ed;
      class ep extends P {
        _parse(e) {
          let t = s.getValidEnumValues(this._def.values),
            r = this._getOrReturnCtx(e);
          if (r.parsedType !== d.string && r.parsedType !== d.number) {
            let e = s.objectValues(t);
            return (
              w(r, {
                expected: s.joinValues(e),
                received: r.parsedType,
                code: p.invalid_type,
              }),
              E
            );
          }
          if (-1 === t.indexOf(e.data)) {
            let e = s.objectValues(t);
            return (
              w(r, {
                received: r.data,
                code: p.invalid_enum_value,
                options: e,
              }),
              E
            );
          }
          return C(e.data);
        }
        get enum() {
          return this._def.values;
        }
      }
      ep.create = (e, t) =>
        new ep({ values: e, typeName: o.ZodNativeEnum, ...x(t) });
      class ef extends P {
        unwrap() {
          return this._def.type;
        }
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          return t.parsedType !== d.promise && !1 === t.common.async
            ? (w(t, {
                code: p.invalid_type,
                expected: d.promise,
                received: t.parsedType,
              }),
              E)
            : C(
                (t.parsedType === d.promise
                  ? t.data
                  : Promise.resolve(t.data)
                ).then((e) =>
                  this._def.type.parseAsync(e, {
                    path: t.path,
                    errorMap: t.common.contextualErrorMap,
                  })
                )
              );
        }
      }
      ef.create = (e, t) =>
        new ef({ type: e, typeName: o.ZodPromise, ...x(t) });
      class eg extends P {
        innerType() {
          return this._def.schema;
        }
        sourceType() {
          return this._def.schema._def.typeName === o.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
        }
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e),
            i = this._def.effect || null,
            n = {
              addIssue: (e) => {
                w(r, e), e.fatal ? t.abort() : t.dirty();
              },
              get path() {
                return r.path;
              },
            };
          if (((n.addIssue = n.addIssue.bind(n)), "preprocess" === i.type)) {
            let e = i.transform(r.data, n);
            return r.common.issues.length
              ? { status: "dirty", value: r.data }
              : r.common.async
              ? Promise.resolve(e).then((e) =>
                  this._def.schema._parseAsync({
                    data: e,
                    path: r.path,
                    parent: r,
                  })
                )
              : this._def.schema._parseSync({
                  data: e,
                  path: r.path,
                  parent: r,
                });
          }
          if ("refinement" === i.type) {
            let e = (e) => {
              let t = i.refinement(e, n);
              if (r.common.async) return Promise.resolve(t);
              if (t instanceof Promise)
                throw Error(
                  "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
                );
              return e;
            };
            if (!1 !== r.common.async)
              return this._def.schema
                ._parseAsync({ data: r.data, path: r.path, parent: r })
                .then((r) =>
                  "aborted" === r.status
                    ? E
                    : ("dirty" === r.status && t.dirty(),
                      e(r.value).then(() => ({
                        status: t.value,
                        value: r.value,
                      })))
                );
            {
              let i = this._def.schema._parseSync({
                data: r.data,
                path: r.path,
                parent: r,
              });
              return "aborted" === i.status
                ? E
                : ("dirty" === i.status && t.dirty(),
                  e(i.value),
                  { status: t.value, value: i.value });
            }
          }
          if ("transform" === i.type)
            if (!1 !== r.common.async)
              return this._def.schema
                ._parseAsync({ data: r.data, path: r.path, parent: r })
                .then((e) =>
                  S(e)
                    ? Promise.resolve(i.transform(e.value, n)).then((e) => ({
                        status: t.value,
                        value: e,
                      }))
                    : e
                );
            else {
              let e = this._def.schema._parseSync({
                data: r.data,
                path: r.path,
                parent: r,
              });
              if (!S(e)) return e;
              let s = i.transform(e.value, n);
              if (s instanceof Promise)
                throw Error(
                  "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."
                );
              return { status: t.value, value: s };
            }
          s.assertNever(i);
        }
      }
      (eg.create = (e, t, r) =>
        new eg({ schema: e, typeName: o.ZodEffects, effect: t, ...x(r) })),
        (eg.createWithPreprocess = (e, t, r) =>
          new eg({
            schema: t,
            effect: { type: "preprocess", transform: e },
            typeName: o.ZodEffects,
            ...x(r),
          }));
      class em extends P {
        _parse(e) {
          return this._getType(e) === d.undefined
            ? C(void 0)
            : this._def.innerType._parse(e);
        }
        unwrap() {
          return this._def.innerType;
        }
      }
      em.create = (e, t) =>
        new em({ innerType: e, typeName: o.ZodOptional, ...x(t) });
      class ey extends P {
        _parse(e) {
          return this._getType(e) === d.null
            ? C(null)
            : this._def.innerType._parse(e);
        }
        unwrap() {
          return this._def.innerType;
        }
      }
      ey.create = (e, t) =>
        new ey({ innerType: e, typeName: o.ZodNullable, ...x(t) });
      class eb extends P {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            r = t.data;
          return (
            t.parsedType === d.undefined && (r = this._def.defaultValue()),
            this._def.innerType._parse({ data: r, path: t.path, parent: t })
          );
        }
        removeDefault() {
          return this._def.innerType;
        }
      }
      eb.create = (e, t) =>
        new eb({
          innerType: e,
          typeName: o.ZodDefault,
          defaultValue:
            "function" == typeof t.default ? t.default : () => t.default,
          ...x(t),
        });
      class ew extends P {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            r = { ...t, common: { ...t.common, issues: [] } },
            i = this._def.innerType._parse({
              data: r.data,
              path: r.path,
              parent: { ...r },
            });
          return N(i)
            ? i.then((e) => ({
                status: "valid",
                value:
                  "valid" === e.status
                    ? e.value
                    : this._def.catchValue({
                        get error() {
                          return new f(r.common.issues);
                        },
                        input: r.data,
                      }),
              }))
            : {
                status: "valid",
                value:
                  "valid" === i.status
                    ? i.value
                    : this._def.catchValue({
                        get error() {
                          return new f(r.common.issues);
                        },
                        input: r.data,
                      }),
              };
        }
        removeCatch() {
          return this._def.innerType;
        }
      }
      ew.create = (e, t) =>
        new ew({
          innerType: e,
          typeName: o.ZodCatch,
          catchValue: "function" == typeof t.catch ? t.catch : () => t.catch,
          ...x(t),
        });
      class ev extends P {
        _parse(e) {
          if (this._getType(e) !== d.nan) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: p.invalid_type,
                expected: d.nan,
                received: t.parsedType,
              }),
              E
            );
          }
          return { status: "valid", value: e.data };
        }
      }
      ev.create = (e) => new ev({ typeName: o.ZodNaN, ...x(e) });
      let eE = Symbol("zod_brand");
      class e_ extends P {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            r = t.data;
          return this._def.type._parse({ data: r, path: t.path, parent: t });
        }
        unwrap() {
          return this._def.type;
        }
      }
      class eC extends P {
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.common.async)
            return (async () => {
              let e = await this._def.in._parseAsync({
                data: r.data,
                path: r.path,
                parent: r,
              });
              return "aborted" === e.status
                ? E
                : "dirty" === e.status
                ? (t.dirty(), _(e.value))
                : this._def.out._parseAsync({
                    data: e.value,
                    path: r.path,
                    parent: r,
                  });
            })();
          {
            let e = this._def.in._parseSync({
              data: r.data,
              path: r.path,
              parent: r,
            });
            return "aborted" === e.status
              ? E
              : "dirty" === e.status
              ? (t.dirty(), { status: "dirty", value: e.value })
              : this._def.out._parseSync({
                  data: e.value,
                  path: r.path,
                  parent: r,
                });
          }
        }
        static create(e, t) {
          return new eC({ in: e, out: t, typeName: o.ZodPipeline });
        }
      }
      class eA extends P {
        _parse(e) {
          let t = this._def.innerType._parse(e);
          return S(t) && (t.value = Object.freeze(t.value)), t;
        }
      }
      eA.create = (e, t) =>
        new eA({ innerType: e, typeName: o.ZodReadonly, ...x(t) });
      let eI = (e, t = {}, r) =>
          e
            ? G.create().superRefine((i, s) => {
                var n, a;
                if (!e(i)) {
                  let e =
                      "function" == typeof t
                        ? t(i)
                        : "string" == typeof t
                        ? { message: t }
                        : t,
                    o = null == (a = null != (n = e.fatal) ? n : r) || a,
                    c = "string" == typeof e ? { message: e } : e;
                  s.addIssue({ code: "custom", ...c, fatal: o });
                }
              })
            : G.create(),
        eS = { object: Q.lazycreate };
      !(function (e) {
        (e.ZodString = "ZodString"),
          (e.ZodNumber = "ZodNumber"),
          (e.ZodNaN = "ZodNaN"),
          (e.ZodBigInt = "ZodBigInt"),
          (e.ZodBoolean = "ZodBoolean"),
          (e.ZodDate = "ZodDate"),
          (e.ZodSymbol = "ZodSymbol"),
          (e.ZodUndefined = "ZodUndefined"),
          (e.ZodNull = "ZodNull"),
          (e.ZodAny = "ZodAny"),
          (e.ZodUnknown = "ZodUnknown"),
          (e.ZodNever = "ZodNever"),
          (e.ZodVoid = "ZodVoid"),
          (e.ZodArray = "ZodArray"),
          (e.ZodObject = "ZodObject"),
          (e.ZodUnion = "ZodUnion"),
          (e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
          (e.ZodIntersection = "ZodIntersection"),
          (e.ZodTuple = "ZodTuple"),
          (e.ZodRecord = "ZodRecord"),
          (e.ZodMap = "ZodMap"),
          (e.ZodSet = "ZodSet"),
          (e.ZodFunction = "ZodFunction"),
          (e.ZodLazy = "ZodLazy"),
          (e.ZodLiteral = "ZodLiteral"),
          (e.ZodEnum = "ZodEnum"),
          (e.ZodEffects = "ZodEffects"),
          (e.ZodNativeEnum = "ZodNativeEnum"),
          (e.ZodOptional = "ZodOptional"),
          (e.ZodNullable = "ZodNullable"),
          (e.ZodDefault = "ZodDefault"),
          (e.ZodCatch = "ZodCatch"),
          (e.ZodPromise = "ZodPromise"),
          (e.ZodBranded = "ZodBranded"),
          (e.ZodPipeline = "ZodPipeline"),
          (e.ZodReadonly = "ZodReadonly");
      })(o || (o = {}));
      let eN = B.create,
        eT = F.create,
        eO = ev.create,
        ex = W.create,
        eP = q.create,
        eR = H.create,
        ek = z.create,
        eD = V.create,
        eU = K.create,
        eL = G.create,
        eM = Y.create,
        ej = Z.create,
        e$ = J.create,
        eB = X.create,
        eF = Q.create,
        eW = Q.strictCreate,
        eq = ee.create,
        eH = er.create,
        ez = ei.create,
        eV = es.create,
        eK = en.create,
        eG = ea.create,
        eY = eo.create,
        eZ = ec.create,
        eJ = el.create,
        eX = eu.create,
        eQ = eh.create,
        e0 = ep.create,
        e1 = ef.create,
        e2 = eg.create,
        e3 = em.create,
        e5 = ey.create,
        e8 = eg.createWithPreprocess,
        e6 = eC.create;
      var e4 = Object.freeze({
        __proto__: null,
        defaultErrorMap: g,
        setErrorMap: function (e) {
          m = e;
        },
        getErrorMap: y,
        makeIssue: b,
        EMPTY_PATH: [],
        addIssueToContext: w,
        ParseStatus: v,
        INVALID: E,
        DIRTY: _,
        OK: C,
        isAborted: A,
        isDirty: I,
        isValid: S,
        isAsync: N,
        get util() {
          return s;
        },
        get objectUtil() {
          return n;
        },
        ZodParsedType: d,
        getParsedType: h,
        ZodType: P,
        ZodString: B,
        ZodNumber: F,
        ZodBigInt: W,
        ZodBoolean: q,
        ZodDate: H,
        ZodSymbol: z,
        ZodUndefined: V,
        ZodNull: K,
        ZodAny: G,
        ZodUnknown: Y,
        ZodNever: Z,
        ZodVoid: J,
        ZodArray: X,
        ZodObject: Q,
        ZodUnion: ee,
        ZodDiscriminatedUnion: er,
        ZodIntersection: ei,
        ZodTuple: es,
        ZodRecord: en,
        ZodMap: ea,
        ZodSet: eo,
        ZodFunction: ec,
        ZodLazy: el,
        ZodLiteral: eu,
        ZodEnum: eh,
        ZodNativeEnum: ep,
        ZodPromise: ef,
        ZodEffects: eg,
        ZodTransformer: eg,
        ZodOptional: em,
        ZodNullable: ey,
        ZodDefault: eb,
        ZodCatch: ew,
        ZodNaN: ev,
        BRAND: eE,
        ZodBranded: e_,
        ZodPipeline: eC,
        ZodReadonly: eA,
        custom: eI,
        Schema: P,
        ZodSchema: P,
        late: eS,
        get ZodFirstPartyTypeKind() {
          return o;
        },
        coerce: {
          string: (e) => B.create({ ...e, coerce: !0 }),
          number: (e) => F.create({ ...e, coerce: !0 }),
          boolean: (e) => q.create({ ...e, coerce: !0 }),
          bigint: (e) => W.create({ ...e, coerce: !0 }),
          date: (e) => H.create({ ...e, coerce: !0 }),
        },
        any: eL,
        array: eB,
        bigint: ex,
        boolean: eP,
        date: eR,
        discriminatedUnion: eH,
        effect: e2,
        enum: eQ,
        function: eZ,
        instanceof: (e, t = { message: `Input not instance of ${e.name}` }) =>
          eI((t) => t instanceof e, t),
        intersection: ez,
        lazy: eJ,
        literal: eX,
        map: eG,
        nan: eO,
        nativeEnum: e0,
        never: ej,
        null: eU,
        nullable: e5,
        number: eT,
        object: eF,
        oboolean: () => eP().optional(),
        onumber: () => eT().optional(),
        optional: e3,
        ostring: () => eN().optional(),
        pipeline: e6,
        preprocess: e8,
        promise: e1,
        record: eK,
        set: eY,
        strictObject: eW,
        string: eN,
        symbol: ek,
        transformer: e2,
        tuple: eV,
        undefined: eD,
        union: eq,
        unknown: eM,
        void: e$,
        NEVER: E,
        ZodIssueCode: p,
        quotelessJson: (e) =>
          JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:"),
        ZodError: f,
      });
      let e9 = e4.object({ message: e4.string() });
      function e7(e) {
        return e4.literal(l.s1[e]);
      }
      e4.object({
        accessList: e4.array(e4.string()),
        blockHash: e4.string().nullable(),
        blockNumber: e4.string().nullable(),
        chainId: e4.string().or(e4.number()),
        from: e4.string(),
        gas: e4.string(),
        hash: e4.string(),
        input: e4.string().nullable(),
        maxFeePerGas: e4.string(),
        maxPriorityFeePerGas: e4.string(),
        nonce: e4.string(),
        r: e4.string(),
        s: e4.string(),
        to: e4.string(),
        transactionIndex: e4.string().nullable(),
        type: e4.string(),
        v: e4.string(),
        value: e4.string(),
      });
      let te = e4.object({ chainId: e4.string().or(e4.number()) }),
        tt = e4.object({ email: e4.string().email() }),
        tr = e4.object({ otp: e4.string() }),
        ti = e4.object({
          uri: e4.string(),
          preferredAccountType: e4.optional(e4.string()),
          chainId: e4.optional(e4.string().or(e4.number())),
        }),
        ts = e4.object({
          chainId: e4.optional(e4.string().or(e4.number())),
          preferredAccountType: e4.optional(e4.string()),
          socialUri: e4.optional(e4.string()),
        }),
        tn = e4.object({
          provider: e4.enum([
            "google",
            "github",
            "apple",
            "facebook",
            "x",
            "discord",
          ]),
        }),
        ta = e4.object({ email: e4.string().email() }),
        to = e4.object({ otp: e4.string() }),
        tc = e4.object({ otp: e4.string() }),
        tl = e4.object({
          themeMode: e4.optional(e4.enum(["light", "dark"])),
          themeVariables: e4.optional(
            e4.record(e4.string(), e4.string().or(e4.number()))
          ),
          w3mThemeVariables: e4.optional(e4.record(e4.string(), e4.string())),
        }),
        tu = e4.object({
          metadata: e4
            .object({
              name: e4.string(),
              description: e4.string(),
              url: e4.string(),
              icons: e4.array(e4.string()),
            })
            .optional(),
          sdkVersion: e4.string().optional(),
          sdkType: e4.string().optional(),
          projectId: e4.string(),
        }),
        td = e4.object({ type: e4.string() }),
        th = e4.object({
          action: e4.enum(["VERIFY_DEVICE", "VERIFY_OTP", "CONNECT"]),
        }),
        tp = e4.object({ url: e4.string() }),
        tf = e4.object({ userName: e4.string() }),
        tg = e4.object({
          email: e4.string().optional().nullable(),
          address: e4.string(),
          chainId: e4.string().or(e4.number()),
          accounts: e4
            .array(
              e4.object({
                address: e4.string(),
                type: e4.enum([
                  l.Vl.ACCOUNT_TYPES.EOA,
                  l.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                ]),
              })
            )
            .optional(),
          userName: e4.string().optional().nullable(),
          preferredAccountType: e4.optional(e4.string()),
        }),
        tm = e4.object({
          action: e4.enum(["VERIFY_PRIMARY_OTP", "VERIFY_SECONDARY_OTP"]),
        }),
        ty = e4.object({
          email: e4.string().email().optional().nullable(),
          address: e4.string(),
          chainId: e4.string().or(e4.number()),
          smartAccountDeployed: e4.optional(e4.boolean()),
          accounts: e4
            .array(
              e4.object({
                address: e4.string(),
                type: e4.enum([
                  l.Vl.ACCOUNT_TYPES.EOA,
                  l.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                ]),
              })
            )
            .optional(),
          preferredAccountType: e4.optional(e4.string()),
        }),
        tb = e4.object({ uri: e4.string() }),
        tw = e4.object({ isConnected: e4.boolean() }),
        tv = e4.object({ chainId: e4.string().or(e4.number()) }),
        tE = e4.object({ chainId: e4.string().or(e4.number()) }),
        t_ = e4.object({ newEmail: e4.string().email() }),
        tC = e4.object({ smartAccountEnabledNetworks: e4.array(e4.number()) });
      e4.object({ address: e4.string(), isDeployed: e4.boolean() });
      let tA = e4.object({ version: e4.string().optional() }),
        tI = e4.object({ type: e4.string(), address: e4.string() }),
        tS = e4.any(),
        tN = e4.object({ method: e4.literal("eth_accounts") }),
        tT = e4.object({ method: e4.literal("eth_blockNumber") }),
        tO = e4.object({
          method: e4.literal("eth_call"),
          params: e4.array(e4.any()),
        }),
        tx = e4.object({ method: e4.literal("eth_chainId") }),
        tP = e4.object({
          method: e4.literal("eth_estimateGas"),
          params: e4.array(e4.any()),
        }),
        tR = e4.object({
          method: e4.literal("eth_feeHistory"),
          params: e4.array(e4.any()),
        }),
        tk = e4.object({ method: e4.literal("eth_gasPrice") }),
        tD = e4.object({
          method: e4.literal("eth_getAccount"),
          params: e4.array(e4.any()),
        }),
        tU = e4.object({
          method: e4.literal("eth_getBalance"),
          params: e4.array(e4.any()),
        }),
        tL = e4.object({
          method: e4.literal("eth_getBlockByHash"),
          params: e4.array(e4.any()),
        }),
        tM = e4.object({
          method: e4.literal("eth_getBlockByNumber"),
          params: e4.array(e4.any()),
        }),
        tj = e4.object({
          method: e4.literal("eth_getBlockReceipts"),
          params: e4.array(e4.any()),
        }),
        t$ = e4.object({
          method: e4.literal("eth_getBlockTransactionCountByHash"),
          params: e4.array(e4.any()),
        }),
        tB = e4.object({
          method: e4.literal("eth_getBlockTransactionCountByNumber"),
          params: e4.array(e4.any()),
        }),
        tF = e4.object({
          method: e4.literal("eth_getCode"),
          params: e4.array(e4.any()),
        }),
        tW = e4.object({
          method: e4.literal("eth_getFilterChanges"),
          params: e4.array(e4.any()),
        }),
        tq = e4.object({
          method: e4.literal("eth_getFilterLogs"),
          params: e4.array(e4.any()),
        }),
        tH = e4.object({
          method: e4.literal("eth_getLogs"),
          params: e4.array(e4.any()),
        }),
        tz = e4.object({
          method: e4.literal("eth_getProof"),
          params: e4.array(e4.any()),
        }),
        tV = e4.object({
          method: e4.literal("eth_getStorageAt"),
          params: e4.array(e4.any()),
        }),
        tK = e4.object({
          method: e4.literal("eth_getTransactionByBlockHashAndIndex"),
          params: e4.array(e4.any()),
        }),
        tG = e4.object({
          method: e4.literal("eth_getTransactionByBlockNumberAndIndex"),
          params: e4.array(e4.any()),
        }),
        tY = e4.object({
          method: e4.literal("eth_getTransactionByHash"),
          params: e4.array(e4.any()),
        }),
        tZ = e4.object({
          method: e4.literal("eth_getTransactionCount"),
          params: e4.array(e4.any()),
        }),
        tJ = e4.object({
          method: e4.literal("eth_getTransactionReceipt"),
          params: e4.array(e4.any()),
        }),
        tX = e4.object({
          method: e4.literal("eth_getUncleCountByBlockHash"),
          params: e4.array(e4.any()),
        }),
        tQ = e4.object({
          method: e4.literal("eth_getUncleCountByBlockNumber"),
          params: e4.array(e4.any()),
        }),
        t0 = e4.object({ method: e4.literal("eth_maxPriorityFeePerGas") }),
        t1 = e4.object({ method: e4.literal("eth_newBlockFilter") }),
        t2 = e4.object({
          method: e4.literal("eth_newFilter"),
          params: e4.array(e4.any()),
        }),
        t3 = e4.object({
          method: e4.literal("eth_newPendingTransactionFilter"),
        }),
        t5 = e4.object({
          method: e4.literal("eth_sendRawTransaction"),
          params: e4.array(e4.any()),
        }),
        t8 = e4.object({
          method: e4.literal("eth_syncing"),
          params: e4.array(e4.any()),
        }),
        t6 = e4.object({
          method: e4.literal("eth_uninstallFilter"),
          params: e4.array(e4.any()),
        }),
        t4 = e4.object({
          method: e4.literal("personal_sign"),
          params: e4.array(e4.any()),
        }),
        t9 = e4.object({
          method: e4.literal("eth_signTypedData_v4"),
          params: e4.array(e4.any()),
        }),
        t7 = e4.object({
          method: e4.literal("eth_sendTransaction"),
          params: e4.array(e4.any()),
        }),
        re = e4.object({
          method: e4.literal("solana_signMessage"),
          params: e4.object({ message: e4.string(), pubkey: e4.string() }),
        }),
        rt = e4.object({
          method: e4.literal("solana_signTransaction"),
          params: e4.object({ transaction: e4.string() }),
        }),
        rr = e4.object({
          method: e4.literal("solana_signAllTransactions"),
          params: e4.object({ transactions: e4.array(e4.string()) }),
        }),
        ri = e4.object({
          method: e4.literal("solana_signAndSendTransaction"),
          params: e4.object({
            transaction: e4.string(),
            options: e4
              .object({
                skipPreflight: e4.boolean().optional(),
                preflightCommitment: e4
                  .enum([
                    "processed",
                    "confirmed",
                    "finalized",
                    "recent",
                    "single",
                    "singleGossip",
                    "root",
                    "max",
                  ])
                  .optional(),
                maxRetries: e4.number().optional(),
                minContextSlot: e4.number().optional(),
              })
              .optional(),
          }),
        }),
        rs = e4.object({
          method: e4.literal("wallet_sendCalls"),
          params: e4.array(
            e4.object({
              chainId: e4.string().or(e4.number()).optional(),
              from: e4.string().optional(),
              version: e4.string().optional(),
              capabilities: e4.any().optional(),
              calls: e4.array(
                e4.object({
                  to: e4.string().startsWith("0x"),
                  data: e4.string().startsWith("0x").optional(),
                  value: e4.string().optional(),
                })
              ),
            })
          ),
        }),
        rn = e4.object({
          method: e4.literal("wallet_getCallsStatus"),
          params: e4.array(e4.string()),
        }),
        ra = e4.object({ method: e4.literal("wallet_getCapabilities") }),
        ro = e4.object({
          method: e4.literal("wallet_grantPermissions"),
          params: e4.array(e4.any()),
        }),
        rc = e4.object({
          method: e4.literal("wallet_revokePermissions"),
          params: e4.any(),
        }),
        rl = e4.object({
          method: e4.literal("wallet_getAssets"),
          params: e4.any(),
        }),
        ru = e4.object({ token: e4.string() }),
        rd = e4.object({ id: e4.string().optional() }),
        rh = {
          appEvent: rd
            .extend({ type: e7("APP_SWITCH_NETWORK"), payload: te })
            .or(rd.extend({ type: e7("APP_CONNECT_EMAIL"), payload: tt }))
            .or(rd.extend({ type: e7("APP_CONNECT_DEVICE") }))
            .or(rd.extend({ type: e7("APP_CONNECT_OTP"), payload: tr }))
            .or(rd.extend({ type: e7("APP_CONNECT_SOCIAL"), payload: ti }))
            .or(rd.extend({ type: e7("APP_GET_FARCASTER_URI") }))
            .or(rd.extend({ type: e7("APP_CONNECT_FARCASTER") }))
            .or(
              rd.extend({ type: e7("APP_GET_USER"), payload: e4.optional(ts) })
            )
            .or(
              rd.extend({
                type: e7("APP_GET_SOCIAL_REDIRECT_URI"),
                payload: tn,
              })
            )
            .or(rd.extend({ type: e7("APP_SIGN_OUT") }))
            .or(
              rd.extend({
                type: e7("APP_IS_CONNECTED"),
                payload: e4.optional(ru),
              })
            )
            .or(rd.extend({ type: e7("APP_GET_CHAIN_ID") }))
            .or(
              rd.extend({ type: e7("APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS") })
            )
            .or(rd.extend({ type: e7("APP_INIT_SMART_ACCOUNT") }))
            .or(
              rd.extend({ type: e7("APP_SET_PREFERRED_ACCOUNT"), payload: td })
            )
            .or(
              rd.extend({
                type: e7("APP_RPC_REQUEST"),
                payload: t4
                  .or(rl)
                  .or(tN)
                  .or(tT)
                  .or(tO)
                  .or(tx)
                  .or(tP)
                  .or(tR)
                  .or(tk)
                  .or(tD)
                  .or(tU)
                  .or(tL)
                  .or(tM)
                  .or(tj)
                  .or(t$)
                  .or(tB)
                  .or(tF)
                  .or(tW)
                  .or(tq)
                  .or(tH)
                  .or(tz)
                  .or(tV)
                  .or(tK)
                  .or(tG)
                  .or(tY)
                  .or(tZ)
                  .or(tJ)
                  .or(tX)
                  .or(tQ)
                  .or(t0)
                  .or(t1)
                  .or(t2)
                  .or(t3)
                  .or(t5)
                  .or(t8)
                  .or(t6)
                  .or(t4)
                  .or(t9)
                  .or(t7)
                  .or(re)
                  .or(rt)
                  .or(rr)
                  .or(ri)
                  .or(rn)
                  .or(rs)
                  .or(ra)
                  .or(ro)
                  .or(rc),
              })
            )
            .or(rd.extend({ type: e7("APP_UPDATE_EMAIL"), payload: ta }))
            .or(
              rd.extend({
                type: e7("APP_UPDATE_EMAIL_PRIMARY_OTP"),
                payload: to,
              })
            )
            .or(
              rd.extend({
                type: e7("APP_UPDATE_EMAIL_SECONDARY_OTP"),
                payload: tc,
              })
            )
            .or(rd.extend({ type: e7("APP_SYNC_THEME"), payload: tl }))
            .or(rd.extend({ type: e7("APP_SYNC_DAPP_DATA"), payload: tu }))
            .or(rd.extend({ type: e7("APP_RELOAD") })),
          frameEvent: rd
            .extend({ type: e7("FRAME_SWITCH_NETWORK_ERROR"), payload: e9 })
            .or(
              rd.extend({
                type: e7("FRAME_SWITCH_NETWORK_SUCCESS"),
                payload: tE,
              })
            )
            .or(
              rd.extend({
                type: e7("FRAME_CONNECT_EMAIL_SUCCESS"),
                payload: th,
              })
            )
            .or(
              rd.extend({ type: e7("FRAME_CONNECT_EMAIL_ERROR"), payload: e9 })
            )
            .or(
              rd.extend({
                type: e7("FRAME_GET_FARCASTER_URI_SUCCESS"),
                payload: tp,
              })
            )
            .or(
              rd.extend({
                type: e7("FRAME_GET_FARCASTER_URI_ERROR"),
                payload: e9,
              })
            )
            .or(
              rd.extend({
                type: e7("FRAME_CONNECT_FARCASTER_SUCCESS"),
                payload: tf,
              })
            )
            .or(
              rd.extend({
                type: e7("FRAME_CONNECT_FARCASTER_ERROR"),
                payload: e9,
              })
            )
            .or(rd.extend({ type: e7("FRAME_CONNECT_OTP_ERROR"), payload: e9 }))
            .or(rd.extend({ type: e7("FRAME_CONNECT_OTP_SUCCESS") }))
            .or(
              rd.extend({ type: e7("FRAME_CONNECT_DEVICE_ERROR"), payload: e9 })
            )
            .or(rd.extend({ type: e7("FRAME_CONNECT_DEVICE_SUCCESS") }))
            .or(
              rd.extend({
                type: e7("FRAME_CONNECT_SOCIAL_SUCCESS"),
                payload: tg,
              })
            )
            .or(
              rd.extend({ type: e7("FRAME_CONNECT_SOCIAL_ERROR"), payload: e9 })
            )
            .or(rd.extend({ type: e7("FRAME_GET_USER_ERROR"), payload: e9 }))
            .or(rd.extend({ type: e7("FRAME_GET_USER_SUCCESS"), payload: ty }))
            .or(
              rd.extend({
                type: e7("FRAME_GET_SOCIAL_REDIRECT_URI_ERROR"),
                payload: e9,
              })
            )
            .or(
              rd.extend({
                type: e7("FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS"),
                payload: tb,
              })
            )
            .or(rd.extend({ type: e7("FRAME_SIGN_OUT_ERROR"), payload: e9 }))
            .or(rd.extend({ type: e7("FRAME_SIGN_OUT_SUCCESS") }))
            .or(
              rd.extend({ type: e7("FRAME_IS_CONNECTED_ERROR"), payload: e9 })
            )
            .or(
              rd.extend({ type: e7("FRAME_IS_CONNECTED_SUCCESS"), payload: tw })
            )
            .or(
              rd.extend({ type: e7("FRAME_GET_CHAIN_ID_ERROR"), payload: e9 })
            )
            .or(
              rd.extend({ type: e7("FRAME_GET_CHAIN_ID_SUCCESS"), payload: tv })
            )
            .or(rd.extend({ type: e7("FRAME_RPC_REQUEST_ERROR"), payload: e9 }))
            .or(
              rd.extend({ type: e7("FRAME_RPC_REQUEST_SUCCESS"), payload: tS })
            )
            .or(rd.extend({ type: e7("FRAME_SESSION_UPDATE"), payload: ru }))
            .or(
              rd.extend({ type: e7("FRAME_UPDATE_EMAIL_ERROR"), payload: e9 })
            )
            .or(
              rd.extend({ type: e7("FRAME_UPDATE_EMAIL_SUCCESS"), payload: tm })
            )
            .or(
              rd.extend({
                type: e7("FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR"),
                payload: e9,
              })
            )
            .or(
              rd.extend({ type: e7("FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS") })
            )
            .or(
              rd.extend({
                type: e7("FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR"),
                payload: e9,
              })
            )
            .or(
              rd.extend({
                type: e7("FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS"),
                payload: t_,
              })
            )
            .or(rd.extend({ type: e7("FRAME_SYNC_THEME_ERROR"), payload: e9 }))
            .or(rd.extend({ type: e7("FRAME_SYNC_THEME_SUCCESS") }))
            .or(
              rd.extend({ type: e7("FRAME_SYNC_DAPP_DATA_ERROR"), payload: e9 })
            )
            .or(rd.extend({ type: e7("FRAME_SYNC_DAPP_DATA_SUCCESS") }))
            .or(
              rd.extend({
                type: e7("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS"),
                payload: tC,
              })
            )
            .or(
              rd.extend({
                type: e7("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR"),
                payload: e9,
              })
            )
            .or(
              rd.extend({
                type: e7("FRAME_INIT_SMART_ACCOUNT_ERROR"),
                payload: e9,
              })
            )
            .or(
              rd.extend({
                type: e7("FRAME_SET_PREFERRED_ACCOUNT_SUCCESS"),
                payload: tI,
              })
            )
            .or(
              rd.extend({
                type: e7("FRAME_SET_PREFERRED_ACCOUNT_ERROR"),
                payload: e9,
              })
            )
            .or(rd.extend({ type: e7("FRAME_READY"), payload: tA }))
            .or(rd.extend({ type: e7("FRAME_RELOAD_ERROR"), payload: e9 }))
            .or(rd.extend({ type: e7("FRAME_RELOAD_SUCCESS") })),
        };
      function rp(e, t = {}) {
        return "string" == typeof t?.type && t?.type?.includes(e);
      }
      class rf {
        constructor({
          projectId: e,
          isAppClient: t = !1,
          chainId: r = "eip155:1",
          enableLogger: i = !0,
        }) {
          if (
            ((this.iframe = null),
            (this.iframeIsReady = !1),
            (this.rpcUrl = c.o.BLOCKCHAIN_API_RPC_URL),
            (this.initFrame = () => {
              let e = document.getElementById("w3m-iframe");
              this.iframe && !e && document.body.appendChild(this.iframe);
            }),
            (this.events = {
              registerFrameEventHandler: (e, t, r) => {
                function i({ data: r }) {
                  if (!rp(l.s1.FRAME_EVENT_KEY, r)) return;
                  let s = rh.frameEvent.parse(r);
                  s.id === e &&
                    (t(s), window.removeEventListener("message", i));
                }
                u.Q.isClient &&
                  (window.addEventListener("message", i),
                  r.addEventListener("abort", () => {
                    window.removeEventListener("message", i);
                  }));
              },
              onFrameEvent: (e) => {
                u.Q.isClient &&
                  window.addEventListener("message", ({ data: t }) => {
                    rp(l.s1.FRAME_EVENT_KEY, t) && e(rh.frameEvent.parse(t));
                  });
              },
              onAppEvent: (e) => {
                u.Q.isClient &&
                  window.addEventListener("message", ({ data: t }) => {
                    rp(l.s1.APP_EVENT_KEY, t) && e(rh.appEvent.parse(t));
                  });
              },
              postAppEvent: (e) => {
                if (u.Q.isClient) {
                  if (!this.iframe?.contentWindow)
                    throw Error("W3mFrame: iframe is not set");
                  rh.appEvent.parse(e),
                    this.iframe.contentWindow.postMessage(e, "*");
                }
              },
              postFrameEvent: (e) => {
                if (u.Q.isClient) {
                  if (!parent) throw Error("W3mFrame: parent is not set");
                  rh.frameEvent.parse(e), parent.postMessage(e, "*");
                }
              },
            }),
            (this.projectId = e),
            (this.frameLoadPromise = new Promise((e, t) => {
              this.frameLoadPromiseResolver = { resolve: e, reject: t };
            })),
            t &&
              ((this.frameLoadPromise = new Promise((e, t) => {
                this.frameLoadPromiseResolver = { resolve: e, reject: t };
              })),
              u.Q.isClient))
          ) {
            let t = document.createElement("iframe");
            (t.id = "w3m-iframe"),
              (t.src = `${l.hy}?projectId=${e}&chainId=${r}&version=${l.gS}&enableLogger=${i}`),
              (t.name = "w3m-secure-iframe"),
              (t.style.position = "fixed"),
              (t.style.zIndex = "999999"),
              (t.style.display = "none"),
              (t.style.border = "none"),
              (t.style.animationDelay = "0s, 50ms"),
              (t.style.borderBottomLeftRadius =
                "clamp(0px, var(--wui-border-radius-l), 44px)"),
              (t.style.borderBottomRightRadius =
                "clamp(0px, var(--wui-border-radius-l), 44px)"),
              (this.iframe = t),
              (this.iframe.onerror = () => {
                this.frameLoadPromiseResolver?.reject(
                  "Unable to load email login dependency"
                );
              }),
              this.events.onFrameEvent((e) => {
                "@w3m-frame/READY" === e.type &&
                  ((this.iframeIsReady = !0),
                  this.frameLoadPromiseResolver?.resolve(void 0));
              });
          }
        }
        get networks() {
          return Object.assign(
            {},
            ...[
              "eip155:1",
              "eip155:5",
              "eip155:11155111",
              "eip155:10",
              "eip155:420",
              "eip155:42161",
              "eip155:421613",
              "eip155:137",
              "eip155:80001",
              "eip155:42220",
              "eip155:1313161554",
              "eip155:1313161555",
              "eip155:56",
              "eip155:97",
              "eip155:43114",
              "eip155:43113",
              "eip155:324",
              "eip155:280",
              "eip155:100",
              "eip155:8453",
              "eip155:84531",
              "eip155:84532",
              "eip155:7777777",
              "eip155:999",
              "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
              "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
              "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
            ].map((e) => ({
              [e]: {
                rpcUrl: `${this.rpcUrl}/v1/?chainId=${e}&projectId=${this.projectId}`,
                chainId: e,
              },
            }))
          );
        }
      }
      var rg = r(19655);
      class rm {
        constructor(e) {
          let t = (0, rg.iP)({ level: l.OH }),
            { logger: r, chunkLoggerController: i } = (0, rg.D5)({ opts: t });
          (this.logger = (0, rg.U5)(r, this.constructor.name)),
            (this.chunkLoggerController = i),
            "undefined" != typeof window &&
              this.chunkLoggerController?.downloadLogsBlobInBrowser &&
              (window.downloadAppKitLogsBlob ||
                (window.downloadAppKitLogsBlob = {}),
              (window.downloadAppKitLogsBlob.sdk = () => {
                this.chunkLoggerController?.downloadLogsBlobInBrowser &&
                  this.chunkLoggerController.downloadLogsBlobInBrowser({
                    projectId: e,
                  });
              }));
        }
      }
      var ry = r(30596);
      class rb {
        constructor({
          projectId: e,
          chainId: t,
          enableLogger: r = !0,
          onTimeout: i,
          abortController: s,
        }) {
          (this.openRpcRequests = []),
            (this.isInitialized = !1),
            r && (this.w3mLogger = new rm(e)),
            (this.abortController = s),
            (this.w3mFrame = new rf({
              projectId: e,
              isAppClient: !0,
              chainId: t,
              enableLogger: r,
            })),
            (this.onTimeout = i),
            this.getLoginEmailUsed() && this.createFrame();
        }
        async createFrame() {
          this.w3mFrame.initFrame(),
            (this.initPromise = new Promise((e) => {
              this.w3mFrame.events.onFrameEvent((t) => {
                t.type === l.s1.FRAME_READY &&
                  setTimeout(() => {
                    e();
                  }, 500);
              });
            })),
            await this.initPromise,
            (this.isInitialized = !0),
            (this.initPromise = void 0);
        }
        async init() {
          if (!this.isInitialized) {
            if (this.initPromise) return void (await this.initPromise);
            await this.createFrame();
          }
        }
        getLoginEmailUsed() {
          return !!ry.o.get(l.s1.EMAIL_LOGIN_USED_KEY);
        }
        getEmail() {
          return ry.o.get(l.s1.EMAIL);
        }
        getUsername() {
          return ry.o.get(l.s1.SOCIAL_USERNAME);
        }
        async reload() {
          try {
            await this.appEvent({ type: l.s1.APP_RELOAD });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error reloading iframe"
              ),
              e)
            );
          }
        }
        async connectEmail(e) {
          try {
            u.Q.checkIfAllowedToTriggerEmail(), await this.init();
            let t = await this.appEvent({
              type: l.s1.APP_CONNECT_EMAIL,
              payload: e,
            });
            return this.setNewLastEmailLoginTime(), t;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error connecting email"
              ),
              e)
            );
          }
        }
        async connectDevice() {
          try {
            return this.appEvent({ type: l.s1.APP_CONNECT_DEVICE });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error connecting device"
              ),
              e)
            );
          }
        }
        async connectOtp(e) {
          try {
            return this.appEvent({ type: l.s1.APP_CONNECT_OTP, payload: e });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error connecting otp"
              ),
              e)
            );
          }
        }
        async isConnected() {
          try {
            if (!this.getLoginEmailUsed()) return { isConnected: !1 };
            let e = await this.appEvent({ type: l.s1.APP_IS_CONNECTED });
            return e?.isConnected || this.deleteAuthLoginCache(), e;
          } catch (e) {
            throw (
              (this.deleteAuthLoginCache(),
              this.w3mLogger?.logger.error(
                { error: e },
                "Error checking connection"
              ),
              e)
            );
          }
        }
        async getChainId() {
          try {
            let e = await this.appEvent({ type: l.s1.APP_GET_CHAIN_ID });
            return this.setLastUsedChainId(e.chainId), e;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error getting chain id"
              ),
              e)
            );
          }
        }
        async getSocialRedirectUri(e) {
          try {
            return (
              await this.init(),
              this.appEvent({
                type: l.s1.APP_GET_SOCIAL_REDIRECT_URI,
                payload: e,
              })
            );
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error getting social redirect uri"
              ),
              e)
            );
          }
        }
        async updateEmail(e) {
          try {
            let t = await this.appEvent({
              type: l.s1.APP_UPDATE_EMAIL,
              payload: e,
            });
            return this.setNewLastEmailLoginTime(), t;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error updating email"
              ),
              e)
            );
          }
        }
        async updateEmailPrimaryOtp(e) {
          try {
            return this.appEvent({
              type: l.s1.APP_UPDATE_EMAIL_PRIMARY_OTP,
              payload: e,
            });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error updating email primary otp"
              ),
              e)
            );
          }
        }
        async updateEmailSecondaryOtp(e) {
          try {
            let t = await this.appEvent({
              type: l.s1.APP_UPDATE_EMAIL_SECONDARY_OTP,
              payload: e,
            });
            return this.setLoginSuccess(t.newEmail), t;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error updating email secondary otp"
              ),
              e)
            );
          }
        }
        async syncTheme(e) {
          try {
            return this.appEvent({ type: l.s1.APP_SYNC_THEME, payload: e });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error syncing theme"
              ),
              e)
            );
          }
        }
        async syncDappData(e) {
          try {
            return this.appEvent({ type: l.s1.APP_SYNC_DAPP_DATA, payload: e });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error syncing dapp data"
              ),
              e)
            );
          }
        }
        async getSmartAccountEnabledNetworks() {
          try {
            let e = await this.appEvent({
              type: l.s1.APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS,
            });
            return (
              this.persistSmartAccountEnabledNetworks(
                e.smartAccountEnabledNetworks
              ),
              e
            );
          } catch (e) {
            throw (
              (this.persistSmartAccountEnabledNetworks([]),
              this.w3mLogger?.logger.error(
                { error: e },
                "Error getting smart account enabled networks"
              ),
              e)
            );
          }
        }
        async setPreferredAccount(e) {
          try {
            return this.appEvent({
              type: l.s1.APP_SET_PREFERRED_ACCOUNT,
              payload: { type: e },
            });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error setting preferred account"
              ),
              e)
            );
          }
        }
        async connect(e) {
          if (e?.socialUri)
            try {
              await this.init();
              let t = await this.appEvent({
                type: l.s1.APP_CONNECT_SOCIAL,
                payload: {
                  uri: e.socialUri,
                  preferredAccountType: e.preferredAccountType,
                  chainId: e.chainId,
                },
              });
              return (
                t.userName && this.setSocialLoginSuccess(t.userName),
                this.setLoginSuccess(t.email),
                this.setLastUsedChainId(t.chainId),
                (this.user = t),
                t
              );
            } catch (e) {
              throw (
                (this.w3mLogger?.logger.error(
                  { error: e },
                  "Error connecting social"
                ),
                e)
              );
            }
          try {
            let t = e?.chainId || this.getLastUsedChainId() || 1,
              r = await this.getUser({
                chainId: t,
                preferredAccountType: e?.preferredAccountType,
              });
            return (
              this.setLoginSuccess(r.email),
              this.setLastUsedChainId(r.chainId),
              (this.user = r),
              r
            );
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error({ error: e }, "Error connecting"),
              e)
            );
          }
        }
        async getUser(e) {
          try {
            await this.init();
            let t = e?.chainId || this.getLastUsedChainId() || 1,
              r = await this.appEvent({
                type: l.s1.APP_GET_USER,
                payload: { ...e, chainId: t },
              });
            return (this.user = r), r;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error({ error: e }, "Error connecting"),
              e)
            );
          }
        }
        async connectSocial(e) {
          try {
            await this.init();
            let t = await this.appEvent({
              type: l.s1.APP_CONNECT_SOCIAL,
              payload: { uri: e },
            });
            return t.userName && this.setSocialLoginSuccess(t.userName), t;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error connecting social"
              ),
              e)
            );
          }
        }
        async getFarcasterUri() {
          try {
            return (
              await this.init(),
              await this.appEvent({ type: l.s1.APP_GET_FARCASTER_URI })
            );
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error getting farcaster uri"
              ),
              e)
            );
          }
        }
        async connectFarcaster() {
          try {
            let e = await this.appEvent({ type: l.s1.APP_CONNECT_FARCASTER });
            return e.userName && this.setSocialLoginSuccess(e.userName), e;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error connecting farcaster"
              ),
              e)
            );
          }
        }
        async switchNetwork(e) {
          try {
            let t = await this.appEvent({
              type: l.s1.APP_SWITCH_NETWORK,
              payload: { chainId: e },
            });
            return this.setLastUsedChainId(t.chainId), t;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error switching network"
              ),
              e)
            );
          }
        }
        async disconnect() {
          try {
            return (
              this.deleteAuthLoginCache(),
              await new Promise(async (e) => {
                let t = setTimeout(() => {
                  e();
                }, 3e3);
                await this.appEvent({ type: l.s1.APP_SIGN_OUT }),
                  clearTimeout(t),
                  e();
              })
            );
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error disconnecting"
              ),
              e)
            );
          }
        }
        async request(e) {
          try {
            if (l.Vl.GET_CHAIN_ID === e.method)
              return this.getLastUsedChainId();
            this.rpcRequestHandler?.(e);
            let t = await this.appEvent({
              type: l.s1.APP_RPC_REQUEST,
              payload: e,
            });
            return this.rpcSuccessHandler?.(t, e), t;
          } catch (t) {
            throw (
              (this.rpcErrorHandler?.(t, e),
              this.w3mLogger?.logger.error({ error: t }, "Error requesting"),
              t)
            );
          }
        }
        onRpcRequest(e) {
          this.rpcRequestHandler = e;
        }
        onRpcSuccess(e) {
          this.rpcSuccessHandler = e;
        }
        onRpcError(e) {
          this.rpcErrorHandler = e;
        }
        onIsConnected(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === l.s1.FRAME_IS_CONNECTED_SUCCESS &&
              t.payload.isConnected &&
              e();
          });
        }
        onNotConnected(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === l.s1.FRAME_IS_CONNECTED_ERROR && e(),
              t.type !== l.s1.FRAME_IS_CONNECTED_SUCCESS ||
                t.payload.isConnected ||
                e();
          });
        }
        onConnect(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === l.s1.FRAME_GET_USER_SUCCESS && e(t.payload);
          });
        }
        onSocialConnected(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === l.s1.FRAME_CONNECT_SOCIAL_SUCCESS && e(t.payload);
          });
        }
        async getCapabilities() {
          try {
            return (
              (await this.request({ method: "wallet_getCapabilities" })) || {}
            );
          } catch {
            return {};
          }
        }
        onSetPreferredAccount(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === l.s1.FRAME_SET_PREFERRED_ACCOUNT_SUCCESS
              ? e(t.payload)
              : t.type === l.s1.FRAME_SET_PREFERRED_ACCOUNT_ERROR &&
                e({ type: l.Vl.ACCOUNT_TYPES.EOA });
          });
        }
        onGetSmartAccountEnabledNetworks(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === l.s1.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS
              ? e(t.payload.smartAccountEnabledNetworks)
              : t.type ===
                  l.s1.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR && e([]);
          });
        }
        getAvailableChainIds() {
          return Object.keys(this.w3mFrame.networks);
        }
        rejectRpcRequests() {
          try {
            this.openRpcRequests.forEach(
              ({ abortController: e, method: t }) => {
                l.Vl.SAFE_RPC_METHODS.includes(t) || e.abort();
              }
            ),
              (this.openRpcRequests = []);
          } catch (e) {
            this.w3mLogger?.logger.error(
              { error: e },
              "Error aborting RPC request"
            );
          }
        }
        async appEvent(e) {
          let t, r;
          function i(e) {
            return e.replace("@w3m-app/", "");
          }
          let s = [
              l.s1.APP_SYNC_DAPP_DATA,
              l.s1.APP_SYNC_THEME,
              l.s1.APP_SET_PREFERRED_ACCOUNT,
            ],
            n = i(e.type);
          return (
            this.w3mFrame.iframeIsReady ||
              s.includes(e.type) ||
              (r = setTimeout(() => {
                this.onTimeout?.("iframe_load_failed"),
                  this.abortController.abort();
              }, 2e4)),
            await this.w3mFrame.frameLoadPromise,
            clearTimeout(r),
            [
              l.s1.APP_CONNECT_EMAIL,
              l.s1.APP_CONNECT_DEVICE,
              l.s1.APP_CONNECT_OTP,
              l.s1.APP_CONNECT_SOCIAL,
              l.s1.APP_GET_SOCIAL_REDIRECT_URI,
            ]
              .map(i)
              .includes(n) &&
              (t = setTimeout(() => {
                this.onTimeout?.("iframe_request_timeout"),
                  this.abortController.abort();
              }, 3e4)),
            new Promise((i, s) => {
              let a = Math.random().toString(36).substring(7);
              this.w3mLogger?.logger.info?.(
                { event: e, id: a },
                "Sending app event"
              ),
                this.w3mFrame.events.postAppEvent({ ...e, id: a });
              let o = new AbortController();
              "RPC_REQUEST" === n &&
                (this.openRpcRequests = [
                  ...this.openRpcRequests,
                  { ...e.payload, abortController: o },
                ]),
                o.signal.addEventListener("abort", () => {
                  "RPC_REQUEST" === n
                    ? s(Error("Request was aborted"))
                    : "GET_FARCASTER_URI" !== n &&
                      s(Error("Something went wrong"));
                }),
                this.w3mFrame.events.registerFrameEventHandler(
                  a,
                  (e) => {
                    var o;
                    return (
                      (o = this.w3mLogger),
                      void (
                        e.id === a &&
                        (o?.logger.info?.(
                          { framEvent: e, id: a },
                          "Received frame response"
                        ),
                        e.type === `@w3m-frame/${n}_SUCCESS`
                          ? (t && clearTimeout(t),
                            r && clearTimeout(r),
                            "payload" in e && i(e.payload),
                            i(void 0))
                          : e.type === `@w3m-frame/${n}_ERROR` &&
                            (t && clearTimeout(t),
                            r && clearTimeout(r),
                            "payload" in e &&
                              s(
                                Error(e.payload?.message || "An error occurred")
                              ),
                            s(Error("An error occurred"))))
                      )
                    );
                  },
                  this.abortController.signal
                );
            })
          );
        }
        setNewLastEmailLoginTime() {
          ry.o.set(l.s1.LAST_EMAIL_LOGIN_TIME, Date.now().toString());
        }
        setSocialLoginSuccess(e) {
          ry.o.set(l.s1.SOCIAL_USERNAME, e);
        }
        setLoginSuccess(e) {
          e && ry.o.set(l.s1.EMAIL, e),
            ry.o.set(l.s1.EMAIL_LOGIN_USED_KEY, "true"),
            ry.o.delete(l.s1.LAST_EMAIL_LOGIN_TIME);
        }
        deleteAuthLoginCache() {
          ry.o.delete(l.s1.EMAIL_LOGIN_USED_KEY),
            ry.o.delete(l.s1.EMAIL),
            ry.o.delete(l.s1.LAST_USED_CHAIN_KEY),
            ry.o.delete(l.s1.SOCIAL_USERNAME);
        }
        setLastUsedChainId(e) {
          e && ry.o.set(l.s1.LAST_USED_CHAIN_KEY, String(e));
        }
        getLastUsedChainId() {
          let e = ry.o.get(l.s1.LAST_USED_CHAIN_KEY) ?? void 0,
            t = Number(e);
          return isNaN(t) ? e : t;
        }
        persistSmartAccountEnabledNetworks(e) {
          ry.o.set(l.s1.SMART_ACCOUNT_ENABLED_NETWORKS, e.join(","));
        }
      }
    },
    50836: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.ONE_YEAR =
          t.FOUR_WEEKS =
          t.THREE_WEEKS =
          t.TWO_WEEKS =
          t.ONE_WEEK =
          t.THIRTY_DAYS =
          t.SEVEN_DAYS =
          t.FIVE_DAYS =
          t.THREE_DAYS =
          t.ONE_DAY =
          t.TWENTY_FOUR_HOURS =
          t.TWELVE_HOURS =
          t.SIX_HOURS =
          t.THREE_HOURS =
          t.ONE_HOUR =
          t.SIXTY_MINUTES =
          t.THIRTY_MINUTES =
          t.TEN_MINUTES =
          t.FIVE_MINUTES =
          t.ONE_MINUTE =
          t.SIXTY_SECONDS =
          t.THIRTY_SECONDS =
          t.TEN_SECONDS =
          t.FIVE_SECONDS =
          t.ONE_SECOND =
            void 0),
        (t.ONE_SECOND = 1),
        (t.FIVE_SECONDS = 5),
        (t.TEN_SECONDS = 10),
        (t.THIRTY_SECONDS = 30),
        (t.SIXTY_SECONDS = 60),
        (t.ONE_MINUTE = t.SIXTY_SECONDS),
        (t.FIVE_MINUTES = 5 * t.ONE_MINUTE),
        (t.TEN_MINUTES = 10 * t.ONE_MINUTE),
        (t.THIRTY_MINUTES = 30 * t.ONE_MINUTE),
        (t.SIXTY_MINUTES = 60 * t.ONE_MINUTE),
        (t.ONE_HOUR = t.SIXTY_MINUTES),
        (t.THREE_HOURS = 3 * t.ONE_HOUR),
        (t.SIX_HOURS = 6 * t.ONE_HOUR),
        (t.TWELVE_HOURS = 12 * t.ONE_HOUR),
        (t.TWENTY_FOUR_HOURS = 24 * t.ONE_HOUR),
        (t.ONE_DAY = t.TWENTY_FOUR_HOURS),
        (t.THREE_DAYS = 3 * t.ONE_DAY),
        (t.FIVE_DAYS = 5 * t.ONE_DAY),
        (t.SEVEN_DAYS = 7 * t.ONE_DAY),
        (t.THIRTY_DAYS = 30 * t.ONE_DAY),
        (t.ONE_WEEK = t.SEVEN_DAYS),
        (t.TWO_WEEKS = 2 * t.ONE_WEEK),
        (t.THREE_WEEKS = 3 * t.ONE_WEEK),
        (t.FOUR_WEEKS = 4 * t.ONE_WEEK),
        (t.ONE_YEAR = 365 * t.ONE_DAY);
    },
    50920: (e, t, r) => {
      "use strict";
      r.d(t, { m: () => n });
      var i = r(25910),
        s = r(52020),
        n = new (class extends i.Q {
          #d;
          #t;
          #r;
          constructor() {
            super(),
              (this.#r = (e) => {
                if (!s.S$ && window.addEventListener) {
                  let t = () => e();
                  return (
                    window.addEventListener("visibilitychange", t, !1),
                    () => {
                      window.removeEventListener("visibilitychange", t);
                    }
                  );
                }
              });
          }
          onSubscribe() {
            this.#t || this.setEventListener(this.#r);
          }
          onUnsubscribe() {
            this.hasListeners() || (this.#t?.(), (this.#t = void 0));
          }
          setEventListener(e) {
            (this.#r = e),
              this.#t?.(),
              (this.#t = e((e) => {
                "boolean" == typeof e ? this.setFocused(e) : this.onFocus();
              }));
          }
          setFocused(e) {
            this.#d !== e && ((this.#d = e), this.onFocus());
          }
          onFocus() {
            let e = this.isFocused();
            this.listeners.forEach((t) => {
              t(e);
            });
          }
          isFocused() {
            return "boolean" == typeof this.#d
              ? this.#d
              : globalThis.document?.visibilityState !== "hidden";
          }
        })();
    },
    52020: (e, t, r) => {
      "use strict";
      r.d(t, {
        Cp: () => f,
        EN: () => p,
        Eh: () => l,
        F$: () => h,
        GU: () => I,
        MK: () => u,
        S$: () => i,
        ZM: () => A,
        ZZ: () => _,
        Zw: () => n,
        d2: () => c,
        f8: () => g,
        gn: () => a,
        hT: () => C,
        j3: () => o,
        lQ: () => s,
        nJ: () => d,
        pl: () => v,
        y9: () => E,
        yy: () => w,
      });
      var i = "undefined" == typeof window || "Deno" in globalThis;
      function s() {}
      function n(e, t) {
        return "function" == typeof e ? e(t) : e;
      }
      function a(e) {
        return "number" == typeof e && e >= 0 && e !== 1 / 0;
      }
      function o(e, t) {
        return Math.max(e + (t || 0) - Date.now(), 0);
      }
      function c(e, t) {
        return "function" == typeof e ? e(t) : e;
      }
      function l(e, t) {
        return "function" == typeof e ? e(t) : e;
      }
      function u(e, t) {
        let {
          type: r = "all",
          exact: i,
          fetchStatus: s,
          predicate: n,
          queryKey: a,
          stale: o,
        } = e;
        if (a) {
          if (i) {
            if (t.queryHash !== h(a, t.options)) return !1;
          } else if (!f(t.queryKey, a)) return !1;
        }
        if ("all" !== r) {
          let e = t.isActive();
          if (("active" === r && !e) || ("inactive" === r && e)) return !1;
        }
        return (
          ("boolean" != typeof o || t.isStale() === o) &&
          (!s || s === t.state.fetchStatus) &&
          (!n || !!n(t))
        );
      }
      function d(e, t) {
        let { exact: r, status: i, predicate: s, mutationKey: n } = e;
        if (n) {
          if (!t.options.mutationKey) return !1;
          if (r) {
            if (p(t.options.mutationKey) !== p(n)) return !1;
          } else if (!f(t.options.mutationKey, n)) return !1;
        }
        return (!i || t.state.status === i) && (!s || !!s(t));
      }
      function h(e, t) {
        return (t?.queryKeyHashFn || p)(e);
      }
      function p(e) {
        return JSON.stringify(e, (e, t) =>
          y(t)
            ? Object.keys(t)
                .sort()
                .reduce((e, r) => ((e[r] = t[r]), e), {})
            : t
        );
      }
      function f(e, t) {
        return (
          e === t ||
          (typeof e == typeof t &&
            !!e &&
            !!t &&
            "object" == typeof e &&
            "object" == typeof t &&
            Object.keys(t).every((r) => f(e[r], t[r])))
        );
      }
      function g(e, t) {
        if (!t || Object.keys(e).length !== Object.keys(t).length) return !1;
        for (let r in e) if (e[r] !== t[r]) return !1;
        return !0;
      }
      function m(e) {
        return Array.isArray(e) && e.length === Object.keys(e).length;
      }
      function y(e) {
        if (!b(e)) return !1;
        let t = e.constructor;
        if (void 0 === t) return !0;
        let r = t.prototype;
        return (
          !!b(r) &&
          !!r.hasOwnProperty("isPrototypeOf") &&
          Object.getPrototypeOf(e) === Object.prototype
        );
      }
      function b(e) {
        return "[object Object]" === Object.prototype.toString.call(e);
      }
      function w(e) {
        return new Promise((t) => {
          setTimeout(t, e);
        });
      }
      function v(e, t, r) {
        return "function" == typeof r.structuralSharing
          ? r.structuralSharing(e, t)
          : !1 !== r.structuralSharing
          ? (function e(t, r) {
              if (t === r) return t;
              let i = m(t) && m(r);
              if (i || (y(t) && y(r))) {
                let s = i ? t : Object.keys(t),
                  n = s.length,
                  a = i ? r : Object.keys(r),
                  o = a.length,
                  c = i ? [] : {},
                  l = 0;
                for (let n = 0; n < o; n++) {
                  let o = i ? n : a[n];
                  ((!i && s.includes(o)) || i) &&
                  void 0 === t[o] &&
                  void 0 === r[o]
                    ? ((c[o] = void 0), l++)
                    : ((c[o] = e(t[o], r[o])),
                      c[o] === t[o] && void 0 !== t[o] && l++);
                }
                return n === o && l === n ? t : c;
              }
              return r;
            })(e, t)
          : t;
      }
      function E(e, t, r = 0) {
        let i = [...e, t];
        return r && i.length > r ? i.slice(1) : i;
      }
      function _(e, t, r = 0) {
        let i = [t, ...e];
        return r && i.length > r ? i.slice(0, -1) : i;
      }
      var C = Symbol();
      function A(e, t) {
        return !e.queryFn && t?.initialPromise
          ? () => t.initialPromise
          : e.queryFn && e.queryFn !== C
          ? e.queryFn
          : () => Promise.reject(Error(`Missing queryFn: '${e.queryHash}'`));
      }
      function I(e, t) {
        return "function" == typeof e ? e(...t) : !!e;
      }
    },
    52515: (e, t, r) => {
      "use strict";
      r.d(t, {
        z8: () => i,
        tt: () => l,
        Zv: () => n.Z,
        EM: () => u.E,
        RF: () => s.RF,
        JX: () => s.JX,
        ds: () => s.ds,
      });
      let i = {
        interpolate(e, t, r) {
          if (2 !== e.length || 2 !== t.length)
            throw Error(
              "inputRange and outputRange must be an array of length 2"
            );
          let i = e[0] || 0,
            s = e[1] || 0,
            n = t[0] || 0,
            a = t[1] || 0;
          return r < i ? n : r > s ? a : ((a - n) / (s - i)) * (r - i) + n;
        },
      };
      var s = r(97265),
        n = r(59970),
        a = r(24259);
      let o = ["receive", "deposit", "borrow", "claim"],
        c = ["withdraw", "repay", "burn"],
        l = {
          getTransactionGroupTitle(e, t) {
            let r = a.r.getYear(),
              i = a.r.getMonthNameByIndex(t);
            return e === r ? i : `${i} ${e}`;
          },
          getTransactionImages(e) {
            let [t, r] = e,
              i = !!t && e?.every((e) => !!e.nft_info),
              s = e?.length > 1;
            return e?.length !== 2 || i
              ? s
                ? e.map((e) => this.getTransactionImage(e))
                : [this.getTransactionImage(t)]
              : [this.getTransactionImage(t), this.getTransactionImage(r)];
          },
          getTransactionImage: (e) => ({
            type: l.getTransactionTransferTokenType(e),
            url: l.getTransactionImageURL(e),
          }),
          getTransactionImageURL(e) {
            let t,
              r = !!e?.nft_info,
              i = !!e?.fungible_info;
            return (
              e && r
                ? (t = e?.nft_info?.content?.preview?.url)
                : e && i && (t = e?.fungible_info?.icon?.url),
              t
            );
          },
          getTransactionTransferTokenType: (e) =>
            e?.fungible_info ? "FUNGIBLE" : e?.nft_info ? "NFT" : void 0,
          getTransactionDescriptions(e) {
            let t = e?.metadata?.operationType,
              r = e?.transfers,
              i = e?.transfers?.length > 0,
              s = e?.transfers?.length > 1,
              a = i && r?.every((e) => !!e?.fungible_info),
              [l, u] = r,
              d = this.getTransferDescription(l),
              h = this.getTransferDescription(u);
            if (!i)
              return ("send" === t || "receive" === t) && a
                ? [
                    (d = n.Z.getTruncateString({
                      string: e?.metadata.sentFrom,
                      charsStart: 4,
                      charsEnd: 6,
                      truncate: "middle",
                    })),
                    n.Z.getTruncateString({
                      string: e?.metadata.sentTo,
                      charsStart: 4,
                      charsEnd: 6,
                      truncate: "middle",
                    }),
                  ]
                : [e.metadata.status];
            if (s) return r.map((e) => this.getTransferDescription(e));
            let p = "";
            return (
              o.includes(t) ? (p = "+") : c.includes(t) && (p = "-"),
              [(d = p.concat(d))]
            );
          },
          getTransferDescription(e) {
            let t = "";
            return (
              e &&
                (e?.nft_info
                  ? (t = e?.nft_info?.name || "-")
                  : e?.fungible_info &&
                    (t = this.getFungibleTransferDescription(e) || "-")),
              t
            );
          },
          getFungibleTransferDescription(e) {
            return e
              ? [
                  this.getQuantityFixedValue(e?.quantity.numeric),
                  e?.fungible_info?.symbol,
                ]
                  .join(" ")
                  .trim()
              : null;
          },
          getQuantityFixedValue: (e) => (e ? parseFloat(e).toFixed(3) : null),
        };
      var u = r(54166);
    },
    53031: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => l });
      var i = r(12115),
        s = r(48374),
        n = r(95782);
      let a = () => "wagmi@2.15.3";
      class o extends n.C {
        constructor() {
          super(...arguments),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "WagmiError",
            });
        }
        get docsBaseUrl() {
          return "https://wagmi.sh/react";
        }
        get version() {
          return a();
        }
      }
      class c extends o {
        constructor() {
          super("`useConfig` must be used within `WagmiProvider`.", {
            docsPath: "/api/WagmiProvider",
          }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "WagmiProviderNotFoundError",
            });
        }
      }
      function l() {
        var e;
        let t =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          r = null != (e = t.config) ? e : (0, i.useContext)(s.R);
        if (!r) throw new c();
        return r;
      }
    },
    54166: (e, t, r) => {
      "use strict";
      function i(e) {
        return function (t) {
          return "function" == typeof t
            ? (customElements.get(e) || customElements.define(e, t), t)
            : (function (e, t) {
                let { kind: r, elements: i } = t;
                return {
                  kind: r,
                  elements: i,
                  finisher(t) {
                    customElements.get(e) || customElements.define(e, t);
                  },
                };
              })(e, t);
        };
      }
      r.d(t, { E: () => i });
    },
    54252: (e, t, r) => {
      "use strict";
      r.d(t, { a: () => y });
      var i = r(43708),
        s = r(70799),
        n = r(60500),
        a = r(22492),
        o = r(63430),
        c = r(5582),
        l = r(92555),
        u = r(65819),
        d = r(90906),
        h = r(96641),
        p = r(19628),
        f = r(7478);
      let g = {
          eip155: void 0,
          solana: void 0,
          polkadot: void 0,
          bip122: void 0,
          cosmos: void 0,
        },
        m = (0, i.BX)({
          allConnectors: [],
          connectors: [],
          activeConnector: void 0,
          filterByNamespace: void 0,
          activeConnectorIds: { ...g },
          filterByNamespaceMap: {
            eip155: !0,
            solana: !0,
            polkadot: !0,
            bip122: !0,
            cosmos: !0,
          },
        }),
        y = (0, l.X)({
          state: m,
          subscribe: (e) =>
            (0, i.B1)(m, () => {
              e(m);
            }),
          subscribeKey: (e, t) => (0, s.u$)(m, e, t),
          initialize(e) {
            e.forEach((e) => {
              let t = c.i.getConnectedConnectorId(e);
              t && y.setConnectorId(t, e);
            });
          },
          setActiveConnector(e) {
            e && (m.activeConnector = (0, i.KR)(e));
          },
          setConnectors(e) {
            e.filter(
              (e) =>
                !m.allConnectors.some(
                  (t) =>
                    t.id === e.id &&
                    y.getConnectorName(t.name) === y.getConnectorName(e.name) &&
                    t.chain === e.chain
                )
            ).forEach((e) => {
              "MULTI_CHAIN" !== e.type && m.allConnectors.push((0, i.KR)(e));
            });
            let t = y.getEnabledNamespaces(),
              r = y.getEnabledConnectors(t);
            m.connectors = y.mergeMultiChainConnectors(r);
          },
          filterByNamespaces(e) {
            Object.keys(m.filterByNamespaceMap).forEach((e) => {
              m.filterByNamespaceMap[e] = !1;
            }),
              e.forEach((e) => {
                m.filterByNamespaceMap[e] = !0;
              }),
              y.updateConnectorsForEnabledNamespaces();
          },
          filterByNamespace(e, t) {
            (m.filterByNamespaceMap[e] = t),
              y.updateConnectorsForEnabledNamespaces();
          },
          updateConnectorsForEnabledNamespaces() {
            let e = y.getEnabledNamespaces(),
              t = y.getEnabledConnectors(e),
              r = y.areAllNamespacesEnabled();
            (m.connectors = y.mergeMultiChainConnectors(t)),
              r ? u.N.clearFilterByNamespaces() : u.N.filterByNamespaces(e);
          },
          getEnabledNamespaces: () =>
            Object.entries(m.filterByNamespaceMap)
              .filter(([e, t]) => t)
              .map(([e]) => e),
          getEnabledConnectors: (e) =>
            m.allConnectors.filter((t) => e.includes(t.chain)),
          areAllNamespacesEnabled: () =>
            Object.values(m.filterByNamespaceMap).every((e) => e),
          mergeMultiChainConnectors(e) {
            let t = y.generateConnectorMapByName(e),
              r = [];
            return (
              t.forEach((e) => {
                let t = e[0],
                  i = t?.id === n.o.CONNECTOR_ID.AUTH;
                e.length > 1 && t
                  ? r.push({
                      name: t.name,
                      imageUrl: t.imageUrl,
                      imageId: t.imageId,
                      connectors: [...e],
                      type: i ? "AUTH" : "MULTI_CHAIN",
                      chain: "eip155",
                      id: t?.id || "",
                    })
                  : t && r.push(t);
              }),
              r
            );
          },
          generateConnectorMapByName(e) {
            let t = new Map();
            return (
              e.forEach((e) => {
                let { name: r } = e,
                  i = y.getConnectorName(r);
                if (!i) return;
                let s = t.get(i) || [];
                s.find((t) => t.chain === e.chain) || s.push(e), t.set(i, s);
              }),
              t
            );
          },
          getConnectorName: (e) => (e && { "Trust Wallet": "Trust" }[e]) || e,
          getUniqueConnectorsByName(e) {
            let t = [];
            return (
              e.forEach((e) => {
                t.find((t) => t.chain === e.chain) || t.push(e);
              }),
              t
            );
          },
          addConnector(e) {
            if (e.id === n.o.CONNECTOR_ID.AUTH) {
              let t = (0, i.P9)(h.H.state),
                r = f.W.getSnapshot().themeMode,
                s = f.W.getSnapshot().themeVariables;
              e?.provider?.syncDappData?.({
                metadata: t.metadata,
                sdkVersion: t.sdkVersion,
                projectId: t.projectId,
                sdkType: t.sdkType,
              }),
                e?.provider?.syncTheme({
                  themeMode: r,
                  themeVariables: s,
                  w3mThemeVariables: (0, a.o)(s, r),
                }),
                y.setConnectors([e]);
            } else y.setConnectors([e]);
          },
          getAuthConnector(e) {
            let t = e || d.W.state.activeChain,
              r = m.connectors.find((e) => e.id === n.o.CONNECTOR_ID.AUTH);
            if (r)
              return r?.connectors?.length
                ? r.connectors.find((e) => e.chain === t)
                : r;
          },
          getAnnouncedConnectorRdns: () =>
            m.connectors
              .filter((e) => "ANNOUNCED" === e.type)
              .map((e) => e.info?.rdns),
          getConnectorById: (e) => m.allConnectors.find((t) => t.id === e),
          getConnector: (e, t) =>
            m.allConnectors
              .filter((e) => e.chain === d.W.state.activeChain)
              .find((r) => r.explorerId === e || r.info?.rdns === t),
          syncIfAuthConnector(e) {
            if ("ID_AUTH" !== e.id) return;
            let t = (0, i.P9)(h.H.state),
              r = f.W.getSnapshot().themeMode,
              s = f.W.getSnapshot().themeVariables;
            e?.provider?.syncDappData?.({
              metadata: t.metadata,
              sdkVersion: t.sdkVersion,
              sdkType: t.sdkType,
              projectId: t.projectId,
            }),
              e.provider.syncTheme({
                themeMode: r,
                themeVariables: s,
                w3mThemeVariables: (0, a.o)(s, r),
              });
          },
          getConnectorsByNamespace(e) {
            let t = m.allConnectors.filter((t) => t.chain === e);
            return y.mergeMultiChainConnectors(t);
          },
          selectWalletConnector(e) {
            let t = y.getConnector(e.id, e.rdns),
              r = d.W.state.activeChain;
            o.W.handleMobileDeeplinkRedirect(t?.explorerId || e.id, r),
              t
                ? p.I.push("ConnectingExternal", { connector: t })
                : p.I.push("ConnectingWalletConnect", { wallet: e });
          },
          getConnectors: (e) =>
            e
              ? y.getConnectorsByNamespace(e)
              : y.mergeMultiChainConnectors(m.allConnectors),
          setFilterByNamespace(e) {
            (m.filterByNamespace = e),
              (m.connectors = y.getConnectors(e)),
              u.N.setFilterByNamespace(e);
          },
          setConnectorId(e, t) {
            e &&
              ((m.activeConnectorIds = { ...m.activeConnectorIds, [t]: e }),
              c.i.setConnectedConnectorId(t, e));
          },
          removeConnectorId(e) {
            (m.activeConnectorIds = { ...m.activeConnectorIds, [e]: void 0 }),
              c.i.deleteConnectedConnectorId(e);
          },
          getConnectorId(e) {
            if (e) return m.activeConnectorIds[e];
          },
          isConnected: (e) =>
            e
              ? !!m.activeConnectorIds[e]
              : Object.values(m.activeConnectorIds).some((e) => !!e),
          resetConnectorIds() {
            m.activeConnectorIds = { ...g };
          },
        });
    },
    54315: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => d });
      var i = r(7441),
        s = r(90557),
        n = r(81379),
        a = r(67622);
      let o = new (r(65003).A)(8192);
      var c = r(42142),
        l = r(79183),
        u = r(65368);
      function d(
        {
          key: e,
          methods: t,
          name: r,
          request: d,
          retryCount: h = 3,
          retryDelay: p = 150,
          timeout: f,
          type: g,
        },
        m
      ) {
        return {
          config: {
            key: e,
            methods: t,
            name: r,
            request: d,
            retryCount: h,
            retryDelay: p,
            timeout: f,
            type: g,
          },
          request: (function (e, t = {}) {
            return async (r, u = {}) => {
              let {
                  dedupe: d = !1,
                  methods: h,
                  retryDelay: p = 150,
                  retryCount: f = 3,
                  uid: g,
                } = { ...t, ...u },
                { method: m } = r;
              if (
                h?.exclude?.includes(m) ||
                (h?.include && !h.include.includes(m))
              )
                throw new n.ab(Error("method not supported"), { method: m });
              let y = d ? (0, a.i3)(`${g}.${(0, l.A)(r)}`) : void 0;
              return (function (e, { enabled: t = !0, id: r }) {
                if (!t || !r) return e();
                if (o.get(r)) return o.get(r);
                let i = e().finally(() => o.delete(r));
                return o.set(r, i), i;
              })(
                () =>
                  (0, c.b)(
                    async () => {
                      try {
                        return await e(r);
                      } catch (e) {
                        switch (e.code) {
                          case n.XU.code:
                            throw new n.XU(e);
                          case n.CL.code:
                            throw new n.CL(e);
                          case n.Gi.code:
                            throw new n.Gi(e, { method: r.method });
                          case n.D5.code:
                            throw new n.D5(e);
                          case n.bq.code:
                            throw new n.bq(e);
                          case n.Di.code:
                            throw new n.Di(e);
                          case n.hA.code:
                            throw new n.hA(e);
                          case n.qZ.code:
                            throw new n.qZ(e);
                          case n.YW.code:
                            throw new n.YW(e);
                          case n.ab.code:
                            throw new n.ab(e, { method: r.method });
                          case n.s0.code:
                            throw new n.s0(e);
                          case n.xQ.code:
                            throw new n.xQ(e);
                          case n.vx.code:
                            throw new n.vx(e);
                          case n.sV.code:
                            throw new n.sV(e);
                          case n.Sf.code:
                            throw new n.Sf(e);
                          case n.RV.code:
                            throw new n.RV(e);
                          case n.xq.code:
                            throw new n.xq(e);
                          case n.ch.code:
                            throw new n.ch(e);
                          case n.L5.code:
                            throw new n.L5(e);
                          case n.WT.code:
                            throw new n.WT(e);
                          case n.hl.code:
                            throw new n.hl(e);
                          case n.cg.code:
                            throw new n.cg(e);
                          case n.uL.code:
                            throw new n.uL(e);
                          case n.G1.code:
                            throw new n.G1(e);
                          case n.jz.code:
                            throw new n.jz(e);
                          case 5e3:
                            throw new n.vx(e);
                          default:
                            if (e instanceof i.C) throw e;
                            throw new n.MI(e);
                        }
                      }
                    },
                    {
                      delay: ({ count: e, error: t }) => {
                        if (t && t instanceof s.Ci) {
                          let e = t?.headers?.get("Retry-After");
                          if (e?.match(/\d/)) return 1e3 * Number.parseInt(e);
                        }
                        return ~~(1 << e) * p;
                      },
                      retryCount: f,
                      shouldRetry: ({ error: e }) => {
                        var t;
                        return "code" in (t = e) && "number" == typeof t.code
                          ? -1 === t.code ||
                              t.code === n.s0.code ||
                              t.code === n.bq.code
                          : !(t instanceof s.Ci) ||
                              !t.status ||
                              403 === t.status ||
                              408 === t.status ||
                              413 === t.status ||
                              429 === t.status ||
                              500 === t.status ||
                              502 === t.status ||
                              503 === t.status ||
                              504 === t.status ||
                              !1;
                      },
                    }
                  ),
                { enabled: d, id: y }
              );
            };
          })(d, { methods: t, retryCount: h, retryDelay: p, uid: (0, u.L)() }),
          value: m,
        };
      }
    },
    54335: (e, t, r) => {
      "use strict";
      function i(e, { dir: t = "left" } = {}) {
        let r = "string" == typeof e ? e.replace("0x", "") : e,
          s = 0;
        for (let e = 0; e < r.length - 1; e++)
          if ("0" === r["left" === t ? e : r.length - e - 1].toString()) s++;
          else break;
        return ((r = "left" === t ? r.slice(s) : r.slice(0, r.length - s)),
        "string" == typeof e)
          ? (1 === r.length && "right" === t && (r = `${r}0`),
            `0x${r.length % 2 == 1 ? `0${r}` : r}`)
          : r;
      }
      r.d(t, { B: () => i });
    },
    55252: (e, t, r) => {
      "use strict";
      function i() {
        return (
          (null === r.g || void 0 === r.g ? void 0 : r.g.crypto) ||
          (null === r.g || void 0 === r.g ? void 0 : r.g.msCrypto) ||
          {}
        );
      }
      function s() {
        let e = i();
        return e.subtle || e.webkitSubtle;
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.isBrowserCryptoAvailable =
          t.getSubtleCrypto =
          t.getBrowerCrypto =
            void 0),
        (t.getBrowerCrypto = i),
        (t.getSubtleCrypto = s),
        (t.isBrowserCryptoAvailable = function () {
          return !!i() && !!s();
        });
    },
    55458: (e, t, r) => {
      "use strict";
      r.d(t, { IP: () => a, T8: () => s, Ud: () => n, Ws: () => i });
      let i = {
        WALLET_ID: "@appkit/wallet_id",
        WALLET_NAME: "@appkit/wallet_name",
        SOLANA_WALLET: "@appkit/solana_wallet",
        SOLANA_CAIP_CHAIN: "@appkit/solana_caip_chain",
        ACTIVE_CAIP_NETWORK_ID: "@appkit/active_caip_network_id",
        CONNECTED_SOCIAL: "@appkit/connected_social",
        CONNECTED_SOCIAL_USERNAME: "@appkit-wallet/SOCIAL_USERNAME",
        RECENT_WALLETS: "@appkit/recent_wallets",
        DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE",
        ACTIVE_NAMESPACE: "@appkit/active_namespace",
        CONNECTED_NAMESPACES: "@appkit/connected_namespaces",
        CONNECTION_STATUS: "@appkit/connection_status",
        SIWX_AUTH_TOKEN: "@appkit/siwx-auth-token",
        SIWX_NONCE_TOKEN: "@appkit/siwx-nonce-token",
        TELEGRAM_SOCIAL_PROVIDER: "@appkit/social_provider",
        NATIVE_BALANCE_CACHE: "@appkit/native_balance_cache",
        PORTFOLIO_CACHE: "@appkit/portfolio_cache",
        ENS_CACHE: "@appkit/ens_cache",
        IDENTITY_CACHE: "@appkit/identity_cache",
        PREFERRED_ACCOUNT_TYPES: "@appkit/preferred_account_types",
        CONNECTIONS: "@appkit/connections",
      };
      function s(e) {
        if (!e) throw Error("Namespace is required for CONNECTED_CONNECTOR_ID");
        return `@appkit/${e}:connected_connector_id`;
      }
      let n = {
        setItem(e, t) {
          a() && void 0 !== t && localStorage.setItem(e, t);
        },
        getItem(e) {
          if (a()) return localStorage.getItem(e) || void 0;
        },
        removeItem(e) {
          a() && localStorage.removeItem(e);
        },
        clear() {
          a() && localStorage.clear();
        },
      };
      function a() {
        return (
          "undefined" != typeof window && "undefined" != typeof localStorage
        );
      }
    },
    57719: (e, t) => {
      "use strict";
      (t.byteLength = function (e) {
        var t = c(e),
          r = t[0],
          i = t[1];
        return ((r + i) * 3) / 4 - i;
      }),
        (t.toByteArray = function (e) {
          var t,
            r,
            n = c(e),
            a = n[0],
            o = n[1],
            l = new s(((a + o) * 3) / 4 - o),
            u = 0,
            d = o > 0 ? a - 4 : a;
          for (r = 0; r < d; r += 4)
            (t =
              (i[e.charCodeAt(r)] << 18) |
              (i[e.charCodeAt(r + 1)] << 12) |
              (i[e.charCodeAt(r + 2)] << 6) |
              i[e.charCodeAt(r + 3)]),
              (l[u++] = (t >> 16) & 255),
              (l[u++] = (t >> 8) & 255),
              (l[u++] = 255 & t);
          return (
            2 === o &&
              ((t = (i[e.charCodeAt(r)] << 2) | (i[e.charCodeAt(r + 1)] >> 4)),
              (l[u++] = 255 & t)),
            1 === o &&
              ((t =
                (i[e.charCodeAt(r)] << 10) |
                (i[e.charCodeAt(r + 1)] << 4) |
                (i[e.charCodeAt(r + 2)] >> 2)),
              (l[u++] = (t >> 8) & 255),
              (l[u++] = 255 & t)),
            l
          );
        }),
        (t.fromByteArray = function (e) {
          for (
            var t, i = e.length, s = i % 3, n = [], a = 0, o = i - s;
            a < o;
            a += 16383
          )
            n.push(
              (function (e, t, i) {
                for (var s, n = [], a = t; a < i; a += 3)
                  (s =
                    ((e[a] << 16) & 0xff0000) +
                    ((e[a + 1] << 8) & 65280) +
                    (255 & e[a + 2])),
                    n.push(
                      r[(s >> 18) & 63] +
                        r[(s >> 12) & 63] +
                        r[(s >> 6) & 63] +
                        r[63 & s]
                    );
                return n.join("");
              })(e, a, a + 16383 > o ? o : a + 16383)
            );
          return (
            1 === s
              ? n.push(r[(t = e[i - 1]) >> 2] + r[(t << 4) & 63] + "==")
              : 2 === s &&
                n.push(
                  r[(t = (e[i - 2] << 8) + e[i - 1]) >> 10] +
                    r[(t >> 4) & 63] +
                    r[(t << 2) & 63] +
                    "="
                ),
            n.join("")
          );
        });
      for (
        var r = [],
          i = [],
          s = "undefined" != typeof Uint8Array ? Uint8Array : Array,
          n =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          a = 0,
          o = n.length;
        a < o;
        ++a
      )
        (r[a] = n[a]), (i[n.charCodeAt(a)] = a);
      function c(e) {
        var t = e.length;
        if (t % 4 > 0)
          throw Error("Invalid string. Length must be a multiple of 4");
        var r = e.indexOf("=");
        -1 === r && (r = t);
        var i = r === t ? 0 : 4 - (r % 4);
        return [r, i];
      }
      (i[45] = 62), (i[95] = 63);
    },
    57948: (e, t, r) => {
      "use strict";
      r.d(t, { k: () => s });
      var i = r(52020),
        s = class {
          #h;
          destroy() {
            this.clearGcTimeout();
          }
          scheduleGc() {
            this.clearGcTimeout(),
              (0, i.gn)(this.gcTime) &&
                (this.#h = setTimeout(() => {
                  this.optionalRemove();
                }, this.gcTime));
          }
          updateGcTime(e) {
            this.gcTime = Math.max(this.gcTime || 0, e ?? (i.S$ ? 1 / 0 : 3e5));
          }
          clearGcTimeout() {
            this.#h && (clearTimeout(this.#h), (this.#h = void 0));
          }
        };
    },
    58980: (e, t, r) => {
      "use strict";
      r.d(t, { Fl: () => n, NV: () => a, ii: () => s });
      var i = r(7441);
      class s extends i.C {
        constructor({ offset: e, position: t, size: r }) {
          super(
            `Slice ${
              "start" === t ? "starting" : "ending"
            } at offset "${e}" is out-of-bounds (size: ${r}).`,
            { name: "SliceOffsetOutOfBoundsError" }
          );
        }
      }
      class n extends i.C {
        constructor({ size: e, targetSize: t, type: r }) {
          super(
            `${r.charAt(0).toUpperCase()}${r
              .slice(1)
              .toLowerCase()} size (${e}) exceeds padding size (${t}).`,
            { name: "SizeExceedsPaddingSizeError" }
          );
        }
      }
      class a extends i.C {
        constructor({ size: e, targetSize: t, type: r }) {
          super(
            `${r.charAt(0).toUpperCase()}${r
              .slice(1)
              .toLowerCase()} is expected to be ${t} ${r} long, but is ${e} ${r} long.`,
            { name: "InvalidBytesLengthError" }
          );
        }
      }
    },
    59694: (e, t, r) => {
      "use strict";
      r.d(t, { Ay: () => th, i7: () => tp });
      var i = function () {
        return (i =
          Object.assign ||
          function (e) {
            for (var t, r = 1, i = arguments.length; r < i; r++)
              for (var s in (t = arguments[r]))
                Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
            return e;
          }).apply(this, arguments);
      };
      Object.create;
      function s(e, t, r) {
        if (r || 2 == arguments.length)
          for (var i, s = 0, n = t.length; s < n; s++)
            (!i && s in t) ||
              (i || (i = Array.prototype.slice.call(t, 0, s)), (i[s] = t[s]));
        return e.concat(i || Array.prototype.slice.call(t));
      }
      Object.create, "function" == typeof SuppressedError && SuppressedError;
      var n = r(12115),
        a = r(1072),
        o = r.n(a),
        c = "-ms-",
        l = "-moz-",
        u = "-webkit-",
        d = "comm",
        h = "rule",
        p = "decl",
        f = "@keyframes",
        g = Math.abs,
        m = String.fromCharCode,
        y = Object.assign;
      function b(e, t) {
        return (e = t.exec(e)) ? e[0] : e;
      }
      function w(e, t, r) {
        return e.replace(t, r);
      }
      function v(e, t, r) {
        return e.indexOf(t, r);
      }
      function E(e, t) {
        return 0 | e.charCodeAt(t);
      }
      function _(e, t, r) {
        return e.slice(t, r);
      }
      function C(e) {
        return e.length;
      }
      function A(e, t) {
        return t.push(e), e;
      }
      function I(e, t) {
        return e.filter(function (e) {
          return !b(e, t);
        });
      }
      var S = 1,
        N = 1,
        T = 0,
        O = 0,
        x = 0,
        P = "";
      function R(e, t, r, i, s, n, a, o) {
        return {
          value: e,
          root: t,
          parent: r,
          type: i,
          props: s,
          children: n,
          line: S,
          column: N,
          length: a,
          return: "",
          siblings: o,
        };
      }
      function k(e, t) {
        return y(
          R("", null, null, "", null, null, 0, e.siblings),
          e,
          { length: -e.length },
          t
        );
      }
      function D(e) {
        for (; e.root; ) e = k(e.root, { children: [e] });
        A(e, e.siblings);
      }
      function U() {
        return (x = O < T ? E(P, O++) : 0), N++, 10 === x && ((N = 1), S++), x;
      }
      function L() {
        return E(P, O);
      }
      function M(e) {
        switch (e) {
          case 0:
          case 9:
          case 10:
          case 13:
          case 32:
            return 5;
          case 33:
          case 43:
          case 44:
          case 47:
          case 62:
          case 64:
          case 126:
          case 59:
          case 123:
          case 125:
            return 4;
          case 58:
            return 3;
          case 34:
          case 39:
          case 40:
          case 91:
            return 2;
          case 41:
          case 93:
            return 1;
        }
        return 0;
      }
      function j(e) {
        var t, r;
        return ((t = O - 1),
        (r = (function e(t) {
          for (; U(); )
            switch (x) {
              case t:
                return O;
              case 34:
              case 39:
                34 !== t && 39 !== t && e(x);
                break;
              case 40:
                41 === t && e(t);
                break;
              case 92:
                U();
            }
          return O;
        })(91 === e ? e + 2 : 40 === e ? e + 1 : e)),
        _(P, t, r)).trim();
      }
      function $(e, t) {
        for (var r = "", i = 0; i < e.length; i++) r += t(e[i], i, e, t) || "";
        return r;
      }
      function B(e, t, r, i) {
        switch (e.type) {
          case "@layer":
            if (e.children.length) break;
          case "@import":
          case p:
            return (e.return = e.return || e.value);
          case d:
            return "";
          case f:
            return (e.return = e.value + "{" + $(e.children, i) + "}");
          case h:
            if (!C((e.value = e.props.join(",")))) return "";
        }
        return C((r = $(e.children, i)))
          ? (e.return = e.value + "{" + r + "}")
          : "";
      }
      function F(e, t, r, i) {
        if (e.length > -1 && !e.return)
          switch (e.type) {
            case p:
              e.return = (function e(t, r, i) {
                var s;
                switch (
                  ((s = r),
                  45 ^ E(t, 0)
                    ? (((((((s << 2) ^ E(t, 0)) << 2) ^ E(t, 1)) << 2) ^
                        E(t, 2)) <<
                        2) ^
                      E(t, 3)
                    : 0)
                ) {
                  case 5103:
                    return u + "print-" + t + t;
                  case 5737:
                  case 4201:
                  case 3177:
                  case 3433:
                  case 1641:
                  case 4457:
                  case 2921:
                  case 5572:
                  case 6356:
                  case 5844:
                  case 3191:
                  case 6645:
                  case 3005:
                  case 6391:
                  case 5879:
                  case 5623:
                  case 6135:
                  case 4599:
                  case 4855:
                  case 4215:
                  case 6389:
                  case 5109:
                  case 5365:
                  case 5621:
                  case 3829:
                    return u + t + t;
                  case 4789:
                    return l + t + t;
                  case 5349:
                  case 4246:
                  case 4810:
                  case 6968:
                  case 2756:
                    return u + t + l + t + c + t + t;
                  case 5936:
                    switch (E(t, r + 11)) {
                      case 114:
                        return u + t + c + w(t, /[svh]\w+-[tblr]{2}/, "tb") + t;
                      case 108:
                        return (
                          u + t + c + w(t, /[svh]\w+-[tblr]{2}/, "tb-rl") + t
                        );
                      case 45:
                        return u + t + c + w(t, /[svh]\w+-[tblr]{2}/, "lr") + t;
                    }
                  case 6828:
                  case 4268:
                  case 2903:
                    return u + t + c + t + t;
                  case 6165:
                    return u + t + c + "flex-" + t + t;
                  case 5187:
                    return (
                      u +
                      t +
                      w(t, /(\w+).+(:[^]+)/, u + "box-$1$2" + c + "flex-$1$2") +
                      t
                    );
                  case 5443:
                    return (
                      u +
                      t +
                      c +
                      "flex-item-" +
                      w(t, /flex-|-self/g, "") +
                      (b(t, /flex-|baseline/)
                        ? ""
                        : c + "grid-row-" + w(t, /flex-|-self/g, "")) +
                      t
                    );
                  case 4675:
                    return (
                      u +
                      t +
                      c +
                      "flex-line-pack" +
                      w(t, /align-content|flex-|-self/g, "") +
                      t
                    );
                  case 5548:
                    return u + t + c + w(t, "shrink", "negative") + t;
                  case 5292:
                    return u + t + c + w(t, "basis", "preferred-size") + t;
                  case 6060:
                    return (
                      u +
                      "box-" +
                      w(t, "-grow", "") +
                      u +
                      t +
                      c +
                      w(t, "grow", "positive") +
                      t
                    );
                  case 4554:
                    return u + w(t, /([^-])(transform)/g, "$1" + u + "$2") + t;
                  case 6187:
                    return (
                      w(
                        w(
                          w(t, /(zoom-|grab)/, u + "$1"),
                          /(image-set)/,
                          u + "$1"
                        ),
                        t,
                        ""
                      ) + t
                    );
                  case 5495:
                  case 3959:
                    return w(t, /(image-set\([^]*)/, u + "$1$`$1");
                  case 4968:
                    return (
                      w(
                        w(
                          t,
                          /(.+:)(flex-)?(.*)/,
                          u + "box-pack:$3" + c + "flex-pack:$3"
                        ),
                        /s.+-b[^;]+/,
                        "justify"
                      ) +
                      u +
                      t +
                      t
                    );
                  case 4200:
                    if (!b(t, /flex-|baseline/))
                      return c + "grid-column-align" + _(t, r) + t;
                    break;
                  case 2592:
                  case 3360:
                    return c + w(t, "template-", "") + t;
                  case 4384:
                  case 3616:
                    if (
                      i &&
                      i.some(function (e, t) {
                        return (r = t), b(e.props, /grid-\w+-end/);
                      })
                    )
                      return ~v(t + (i = i[r].value), "span", 0)
                        ? t
                        : c +
                            w(t, "-start", "") +
                            t +
                            c +
                            "grid-row-span:" +
                            (~v(i, "span", 0)
                              ? b(i, /\d+/)
                              : b(i, /\d+/) - b(t, /\d+/)) +
                            ";";
                    return c + w(t, "-start", "") + t;
                  case 4896:
                  case 4128:
                    return i &&
                      i.some(function (e) {
                        return b(e.props, /grid-\w+-start/);
                      })
                      ? t
                      : c + w(w(t, "-end", "-span"), "span ", "") + t;
                  case 4095:
                  case 3583:
                  case 4068:
                  case 2532:
                    return w(t, /(.+)-inline(.+)/, u + "$1$2") + t;
                  case 8116:
                  case 7059:
                  case 5753:
                  case 5535:
                  case 5445:
                  case 5701:
                  case 4933:
                  case 4677:
                  case 5533:
                  case 5789:
                  case 5021:
                  case 4765:
                    if (C(t) - 1 - r > 6)
                      switch (E(t, r + 1)) {
                        case 109:
                          if (45 !== E(t, r + 4)) break;
                        case 102:
                          return (
                            w(
                              t,
                              /(.+:)(.+)-([^]+)/,
                              "$1" +
                                u +
                                "$2-$3$1" +
                                l +
                                (108 == E(t, r + 3) ? "$3" : "$2-$3")
                            ) + t
                          );
                        case 115:
                          return ~v(t, "stretch", 0)
                            ? e(w(t, "stretch", "fill-available"), r, i) + t
                            : t;
                      }
                    break;
                  case 5152:
                  case 5920:
                    return w(
                      t,
                      /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/,
                      function (e, r, i, s, n, a, o) {
                        return (
                          c +
                          r +
                          ":" +
                          i +
                          o +
                          (s ? c + r + "-span:" + (n ? a : a - i) + o : "") +
                          t
                        );
                      }
                    );
                  case 4949:
                    if (121 === E(t, r + 6)) return w(t, ":", ":" + u) + t;
                    break;
                  case 6444:
                    switch (E(t, 45 === E(t, 14) ? 18 : 11)) {
                      case 120:
                        return (
                          w(
                            t,
                            /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/,
                            "$1" +
                              u +
                              (45 === E(t, 14) ? "inline-" : "") +
                              "box$3$1" +
                              u +
                              "$2$3$1" +
                              c +
                              "$2box$3"
                          ) + t
                        );
                      case 100:
                        return w(t, ":", ":" + c) + t;
                    }
                    break;
                  case 5719:
                  case 2647:
                  case 2135:
                  case 3927:
                  case 2391:
                    return w(t, "scroll-", "scroll-snap-") + t;
                }
                return t;
              })(e.value, e.length, r);
              return;
            case f:
              return $([k(e, { value: w(e.value, "@", "@" + u) })], i);
            case h:
              if (e.length) {
                var s, n;
                return (
                  (s = r = e.props),
                  (n = function (t) {
                    switch (b(t, (i = /(::plac\w+|:read-\w+)/))) {
                      case ":read-only":
                      case ":read-write":
                        D(
                          k(e, { props: [w(t, /:(read-\w+)/, ":" + l + "$1")] })
                        ),
                          D(k(e, { props: [t] })),
                          y(e, { props: I(r, i) });
                        break;
                      case "::placeholder":
                        D(
                          k(e, {
                            props: [w(t, /:(plac\w+)/, ":" + u + "input-$1")],
                          })
                        ),
                          D(
                            k(e, {
                              props: [w(t, /:(plac\w+)/, ":" + l + "$1")],
                            })
                          ),
                          D(
                            k(e, {
                              props: [w(t, /:(plac\w+)/, c + "input-$1")],
                            })
                          ),
                          D(k(e, { props: [t] })),
                          y(e, { props: I(r, i) });
                    }
                    return "";
                  }),
                  s.map(n).join("")
                );
              }
          }
      }
      function W(e, t, r, i, s, n, a, o, c, l, u, d) {
        for (
          var p = s - 1,
            f = 0 === s ? n : [""],
            m = f.length,
            y = 0,
            b = 0,
            v = 0;
          y < i;
          ++y
        )
          for (
            var E = 0, C = _(e, p + 1, (p = g((b = a[y])))), A = e;
            E < m;
            ++E
          )
            (A = (b > 0 ? f[E] + " " + C : w(C, /&\f/g, f[E])).trim()) &&
              (c[v++] = A);
        return R(e, t, r, 0 === s ? h : o, c, l, u, d);
      }
      function q(e, t, r, i, s) {
        return R(e, t, r, p, _(e, 0, i), _(e, i + 1, -1), i, s);
      }
      var H = {
          animationIterationCount: 1,
          aspectRatio: 1,
          borderImageOutset: 1,
          borderImageSlice: 1,
          borderImageWidth: 1,
          boxFlex: 1,
          boxFlexGroup: 1,
          boxOrdinalGroup: 1,
          columnCount: 1,
          columns: 1,
          flex: 1,
          flexGrow: 1,
          flexPositive: 1,
          flexShrink: 1,
          flexNegative: 1,
          flexOrder: 1,
          gridRow: 1,
          gridRowEnd: 1,
          gridRowSpan: 1,
          gridRowStart: 1,
          gridColumn: 1,
          gridColumnEnd: 1,
          gridColumnSpan: 1,
          gridColumnStart: 1,
          msGridRow: 1,
          msGridRowSpan: 1,
          msGridColumn: 1,
          msGridColumnSpan: 1,
          fontWeight: 1,
          lineHeight: 1,
          opacity: 1,
          order: 1,
          orphans: 1,
          tabSize: 1,
          widows: 1,
          zIndex: 1,
          zoom: 1,
          WebkitLineClamp: 1,
          fillOpacity: 1,
          floodOpacity: 1,
          stopOpacity: 1,
          strokeDasharray: 1,
          strokeDashoffset: 1,
          strokeMiterlimit: 1,
          strokeOpacity: 1,
          strokeWidth: 1,
        },
        z = r(49509),
        V =
          (void 0 !== z &&
            void 0 !== z.env &&
            (z.env.REACT_APP_SC_ATTR || z.env.SC_ATTR)) ||
          "data-styled",
        K = "active",
        G = "data-styled-version",
        Y = "6.1.18",
        Z = "/*!sc*/\n",
        J = "undefined" != typeof window && "undefined" != typeof document,
        X = !!("boolean" == typeof SC_DISABLE_SPEEDY
          ? SC_DISABLE_SPEEDY
          : void 0 !== z &&
            void 0 !== z.env &&
            void 0 !== z.env.REACT_APP_SC_DISABLE_SPEEDY &&
            "" !== z.env.REACT_APP_SC_DISABLE_SPEEDY
          ? "false" !== z.env.REACT_APP_SC_DISABLE_SPEEDY &&
            z.env.REACT_APP_SC_DISABLE_SPEEDY
          : void 0 !== z &&
            void 0 !== z.env &&
            void 0 !== z.env.SC_DISABLE_SPEEDY &&
            "" !== z.env.SC_DISABLE_SPEEDY &&
            "false" !== z.env.SC_DISABLE_SPEEDY &&
            z.env.SC_DISABLE_SPEEDY),
        Q = Object.freeze([]),
        ee = Object.freeze({}),
        et = new Set([
          "a",
          "abbr",
          "address",
          "area",
          "article",
          "aside",
          "audio",
          "b",
          "base",
          "bdi",
          "bdo",
          "big",
          "blockquote",
          "body",
          "br",
          "button",
          "canvas",
          "caption",
          "cite",
          "code",
          "col",
          "colgroup",
          "data",
          "datalist",
          "dd",
          "del",
          "details",
          "dfn",
          "dialog",
          "div",
          "dl",
          "dt",
          "em",
          "embed",
          "fieldset",
          "figcaption",
          "figure",
          "footer",
          "form",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "header",
          "hgroup",
          "hr",
          "html",
          "i",
          "iframe",
          "img",
          "input",
          "ins",
          "kbd",
          "keygen",
          "label",
          "legend",
          "li",
          "link",
          "main",
          "map",
          "mark",
          "menu",
          "menuitem",
          "meta",
          "meter",
          "nav",
          "noscript",
          "object",
          "ol",
          "optgroup",
          "option",
          "output",
          "p",
          "param",
          "picture",
          "pre",
          "progress",
          "q",
          "rp",
          "rt",
          "ruby",
          "s",
          "samp",
          "script",
          "section",
          "select",
          "small",
          "source",
          "span",
          "strong",
          "style",
          "sub",
          "summary",
          "sup",
          "table",
          "tbody",
          "td",
          "textarea",
          "tfoot",
          "th",
          "thead",
          "time",
          "tr",
          "track",
          "u",
          "ul",
          "use",
          "var",
          "video",
          "wbr",
          "circle",
          "clipPath",
          "defs",
          "ellipse",
          "foreignObject",
          "g",
          "image",
          "line",
          "linearGradient",
          "marker",
          "mask",
          "path",
          "pattern",
          "polygon",
          "polyline",
          "radialGradient",
          "rect",
          "stop",
          "svg",
          "text",
          "tspan",
        ]),
        er = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,
        ei = /(^-|-$)/g;
      function es(e) {
        return e.replace(er, "-").replace(ei, "");
      }
      var en = /(a)(d)/gi,
        ea = function (e) {
          return String.fromCharCode(e + (e > 25 ? 39 : 97));
        };
      function eo(e) {
        var t,
          r = "";
        for (t = Math.abs(e); t > 52; t = (t / 52) | 0) r = ea(t % 52) + r;
        return (ea(t % 52) + r).replace(en, "$1-$2");
      }
      var ec,
        el = function (e, t) {
          for (var r = t.length; r; ) e = (33 * e) ^ t.charCodeAt(--r);
          return e;
        },
        eu = function (e) {
          return el(5381, e);
        };
      function ed(e) {
        return eo(eu(e) >>> 0);
      }
      function eh(e) {
        return "string" == typeof e;
      }
      var ep = "function" == typeof Symbol && Symbol.for,
        ef = ep ? Symbol.for("react.memo") : 60115,
        eg = ep ? Symbol.for("react.forward_ref") : 60112,
        em = {
          childContextTypes: !0,
          contextType: !0,
          contextTypes: !0,
          defaultProps: !0,
          displayName: !0,
          getDefaultProps: !0,
          getDerivedStateFromError: !0,
          getDerivedStateFromProps: !0,
          mixins: !0,
          propTypes: !0,
          type: !0,
        },
        ey = {
          name: !0,
          length: !0,
          prototype: !0,
          caller: !0,
          callee: !0,
          arguments: !0,
          arity: !0,
        },
        eb = {
          $$typeof: !0,
          compare: !0,
          defaultProps: !0,
          displayName: !0,
          propTypes: !0,
          type: !0,
        },
        ew =
          (((ec = {})[eg] = {
            $$typeof: !0,
            render: !0,
            defaultProps: !0,
            displayName: !0,
            propTypes: !0,
          }),
          (ec[ef] = eb),
          ec);
      function ev(e) {
        return ("type" in e && e.type.$$typeof) === ef
          ? eb
          : "$$typeof" in e
          ? ew[e.$$typeof]
          : em;
      }
      var eE = Object.defineProperty,
        e_ = Object.getOwnPropertyNames,
        eC = Object.getOwnPropertySymbols,
        eA = Object.getOwnPropertyDescriptor,
        eI = Object.getPrototypeOf,
        eS = Object.prototype;
      function eN(e) {
        return "function" == typeof e;
      }
      function eT(e) {
        return "object" == typeof e && "styledComponentId" in e;
      }
      function eO(e, t) {
        return e && t ? "".concat(e, " ").concat(t) : e || t || "";
      }
      function ex(e, t) {
        if (0 === e.length) return "";
        for (var r = e[0], i = 1; i < e.length; i++) r += t ? t + e[i] : e[i];
        return r;
      }
      function eP(e) {
        return (
          null !== e &&
          "object" == typeof e &&
          e.constructor.name === Object.name &&
          !("props" in e && e.$$typeof)
        );
      }
      function eR(e, t) {
        Object.defineProperty(e, "toString", { value: t });
      }
      function ek(e) {
        for (var t = [], r = 1; r < arguments.length; r++)
          t[r - 1] = arguments[r];
        return Error(
          "An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#"
            .concat(e, " for more information.")
            .concat(t.length > 0 ? " Args: ".concat(t.join(", ")) : "")
        );
      }
      var eD = (function () {
          function e(e) {
            (this.groupSizes = new Uint32Array(512)),
              (this.length = 512),
              (this.tag = e);
          }
          return (
            (e.prototype.indexOfGroup = function (e) {
              for (var t = 0, r = 0; r < e; r++) t += this.groupSizes[r];
              return t;
            }),
            (e.prototype.insertRules = function (e, t) {
              if (e >= this.groupSizes.length) {
                for (var r = this.groupSizes, i = r.length, s = i; e >= s; )
                  if ((s <<= 1) < 0) throw ek(16, "".concat(e));
                (this.groupSizes = new Uint32Array(s)),
                  this.groupSizes.set(r),
                  (this.length = s);
                for (var n = i; n < s; n++) this.groupSizes[n] = 0;
              }
              for (
                var a = this.indexOfGroup(e + 1), o = ((n = 0), t.length);
                n < o;
                n++
              )
                this.tag.insertRule(a, t[n]) && (this.groupSizes[e]++, a++);
            }),
            (e.prototype.clearGroup = function (e) {
              if (e < this.length) {
                var t = this.groupSizes[e],
                  r = this.indexOfGroup(e),
                  i = r + t;
                this.groupSizes[e] = 0;
                for (var s = r; s < i; s++) this.tag.deleteRule(r);
              }
            }),
            (e.prototype.getGroup = function (e) {
              var t = "";
              if (e >= this.length || 0 === this.groupSizes[e]) return t;
              for (
                var r = this.groupSizes[e],
                  i = this.indexOfGroup(e),
                  s = i + r,
                  n = i;
                n < s;
                n++
              )
                t += "".concat(this.tag.getRule(n)).concat(Z);
              return t;
            }),
            e
          );
        })(),
        eU = new Map(),
        eL = new Map(),
        eM = 1,
        ej = function (e) {
          if (eU.has(e)) return eU.get(e);
          for (; eL.has(eM); ) eM++;
          var t = eM++;
          return eU.set(e, t), eL.set(t, e), t;
        },
        e$ = function (e, t) {
          (eM = t + 1), eU.set(e, t), eL.set(t, e);
        },
        eB = "style[".concat(V, "][").concat(G, '="').concat(Y, '"]'),
        eF = new RegExp(
          "^".concat(V, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')
        ),
        eW = function (e, t, r) {
          for (var i, s = r.split(","), n = 0, a = s.length; n < a; n++)
            (i = s[n]) && e.registerName(t, i);
        },
        eq = function (e, t) {
          for (
            var r,
              i = (null != (r = t.textContent) ? r : "").split(Z),
              s = [],
              n = 0,
              a = i.length;
            n < a;
            n++
          ) {
            var o = i[n].trim();
            if (o) {
              var c = o.match(eF);
              if (c) {
                var l = 0 | parseInt(c[1], 10),
                  u = c[2];
                0 !== l &&
                  (e$(u, l), eW(e, u, c[3]), e.getTag().insertRules(l, s)),
                  (s.length = 0);
              } else s.push(o);
            }
          }
        },
        eH = function (e) {
          for (
            var t = document.querySelectorAll(eB), r = 0, i = t.length;
            r < i;
            r++
          ) {
            var s = t[r];
            s &&
              s.getAttribute(V) !== K &&
              (eq(e, s), s.parentNode && s.parentNode.removeChild(s));
          }
        },
        ez = function (e) {
          var t,
            i = document.head,
            s = e || i,
            n = document.createElement("style"),
            a = (t = Array.from(s.querySelectorAll("style[".concat(V, "]"))))[
              t.length - 1
            ],
            o = void 0 !== a ? a.nextSibling : null;
          n.setAttribute(V, K), n.setAttribute(G, Y);
          var c = r.nc;
          return c && n.setAttribute("nonce", c), s.insertBefore(n, o), n;
        },
        eV = (function () {
          function e(e) {
            (this.element = ez(e)),
              this.element.appendChild(document.createTextNode("")),
              (this.sheet = (function (e) {
                if (e.sheet) return e.sheet;
                for (
                  var t = document.styleSheets, r = 0, i = t.length;
                  r < i;
                  r++
                ) {
                  var s = t[r];
                  if (s.ownerNode === e) return s;
                }
                throw ek(17);
              })(this.element)),
              (this.length = 0);
          }
          return (
            (e.prototype.insertRule = function (e, t) {
              try {
                return this.sheet.insertRule(t, e), this.length++, !0;
              } catch (e) {
                return !1;
              }
            }),
            (e.prototype.deleteRule = function (e) {
              this.sheet.deleteRule(e), this.length--;
            }),
            (e.prototype.getRule = function (e) {
              var t = this.sheet.cssRules[e];
              return t && t.cssText ? t.cssText : "";
            }),
            e
          );
        })(),
        eK = (function () {
          function e(e) {
            (this.element = ez(e)),
              (this.nodes = this.element.childNodes),
              (this.length = 0);
          }
          return (
            (e.prototype.insertRule = function (e, t) {
              if (e <= this.length && e >= 0) {
                var r = document.createTextNode(t);
                return (
                  this.element.insertBefore(r, this.nodes[e] || null),
                  this.length++,
                  !0
                );
              }
              return !1;
            }),
            (e.prototype.deleteRule = function (e) {
              this.element.removeChild(this.nodes[e]), this.length--;
            }),
            (e.prototype.getRule = function (e) {
              return e < this.length ? this.nodes[e].textContent : "";
            }),
            e
          );
        })(),
        eG = (function () {
          function e(e) {
            (this.rules = []), (this.length = 0);
          }
          return (
            (e.prototype.insertRule = function (e, t) {
              return (
                e <= this.length &&
                (this.rules.splice(e, 0, t), this.length++, !0)
              );
            }),
            (e.prototype.deleteRule = function (e) {
              this.rules.splice(e, 1), this.length--;
            }),
            (e.prototype.getRule = function (e) {
              return e < this.length ? this.rules[e] : "";
            }),
            e
          );
        })(),
        eY = J,
        eZ = { isServer: !J, useCSSOMInjection: !X },
        eJ = (function () {
          function e(e, t, r) {
            void 0 === e && (e = ee), void 0 === t && (t = {});
            var s = this;
            (this.options = i(i({}, eZ), e)),
              (this.gs = t),
              (this.names = new Map(r)),
              (this.server = !!e.isServer),
              !this.server && J && eY && ((eY = !1), eH(this)),
              eR(this, function () {
                for (
                  var e = s.getTag(), t = e.length, r = "", i = 0;
                  i < t;
                  i++
                )
                  !(function (t) {
                    var i = eL.get(t);
                    if (void 0 === i) return;
                    var n = s.names.get(i),
                      a = e.getGroup(t);
                    if (void 0 !== n && n.size && 0 !== a.length) {
                      var o = ""
                          .concat(V, ".g")
                          .concat(t, '[id="')
                          .concat(i, '"]'),
                        c = "";
                      void 0 !== n &&
                        n.forEach(function (e) {
                          e.length > 0 && (c += "".concat(e, ","));
                        }),
                        (r += ""
                          .concat(a)
                          .concat(o, '{content:"')
                          .concat(c, '"}')
                          .concat(Z));
                    }
                  })(i);
                return r;
              });
          }
          return (
            (e.registerId = function (e) {
              return ej(e);
            }),
            (e.prototype.rehydrate = function () {
              !this.server && J && eH(this);
            }),
            (e.prototype.reconstructWithOptions = function (t, r) {
              return (
                void 0 === r && (r = !0),
                new e(
                  i(i({}, this.options), t),
                  this.gs,
                  (r && this.names) || void 0
                )
              );
            }),
            (e.prototype.allocateGSInstance = function (e) {
              return (this.gs[e] = (this.gs[e] || 0) + 1);
            }),
            (e.prototype.getTag = function () {
              var e, t, r;
              return (
                this.tag ||
                (this.tag =
                  ((t = (e = this.options).useCSSOMInjection),
                  (r = e.target),
                  new eD(e.isServer ? new eG(r) : t ? new eV(r) : new eK(r))))
              );
            }),
            (e.prototype.hasNameForId = function (e, t) {
              return this.names.has(e) && this.names.get(e).has(t);
            }),
            (e.prototype.registerName = function (e, t) {
              if ((ej(e), this.names.has(e))) this.names.get(e).add(t);
              else {
                var r = new Set();
                r.add(t), this.names.set(e, r);
              }
            }),
            (e.prototype.insertRules = function (e, t, r) {
              this.registerName(e, t), this.getTag().insertRules(ej(e), r);
            }),
            (e.prototype.clearNames = function (e) {
              this.names.has(e) && this.names.get(e).clear();
            }),
            (e.prototype.clearRules = function (e) {
              this.getTag().clearGroup(ej(e)), this.clearNames(e);
            }),
            (e.prototype.clearTag = function () {
              this.tag = void 0;
            }),
            e
          );
        })(),
        eX = /&/g,
        eQ = /^\s*\/\/.*$/gm;
      function e0(e) {
        var t,
          r,
          i,
          s = void 0 === e ? ee : e,
          n = s.options,
          a = void 0 === n ? ee : n,
          o = s.plugins,
          c = void 0 === o ? Q : o,
          l = function (e, i, s) {
            return s.startsWith(r) &&
              s.endsWith(r) &&
              s.replaceAll(r, "").length > 0
              ? ".".concat(t)
              : e;
          },
          u = c.slice();
        u.push(function (e) {
          e.type === h &&
            e.value.includes("&") &&
            (e.props[0] = e.props[0].replace(eX, r).replace(i, l));
        }),
          a.prefix && u.push(F),
          u.push(B);
        var p = function (e, s, n, o) {
          void 0 === s && (s = ""),
            void 0 === n && (n = ""),
            void 0 === o && (o = "&"),
            (t = o),
            (r = s),
            (i = RegExp("\\".concat(r, "\\b"), "g"));
          var c,
            l,
            h,
            p,
            f,
            y,
            b = e.replace(eQ, ""),
            I =
              ((f = (function e(t, r, i, s, n, a, o, c, l) {
                for (
                  var u,
                    h,
                    p,
                    f,
                    y = 0,
                    b = 0,
                    I = o,
                    T = 0,
                    k = 0,
                    D = 0,
                    $ = 1,
                    B = 1,
                    F = 1,
                    H = 0,
                    z = "",
                    V = n,
                    K = a,
                    G = s,
                    Y = z;
                  B;

                )
                  switch (((D = H), (H = U()))) {
                    case 40:
                      if (108 != D && 58 == E(Y, I - 1)) {
                        -1 !=
                          v(
                            (Y += w(j(H), "&", "&\f")),
                            "&\f",
                            g(y ? c[y - 1] : 0)
                          ) && (F = -1);
                        break;
                      }
                    case 34:
                    case 39:
                    case 91:
                      Y += j(H);
                      break;
                    case 9:
                    case 10:
                    case 13:
                    case 32:
                      Y += (function (e) {
                        for (; (x = L()); )
                          if (x < 33) U();
                          else break;
                        return M(e) > 2 || M(x) > 3 ? "" : " ";
                      })(D);
                      break;
                    case 92:
                      Y += (function (e, t) {
                        for (
                          var r;
                          --t &&
                          U() &&
                          !(x < 48) &&
                          !(x > 102) &&
                          (!(x > 57) || !(x < 65)) &&
                          (!(x > 70) || !(x < 97));

                        );
                        return (
                          (r = O + (t < 6 && 32 == L() && 32 == U())),
                          _(P, e, r)
                        );
                      })(O - 1, 7);
                      continue;
                    case 47:
                      switch (L()) {
                        case 42:
                        case 47:
                          A(
                            ((u = (function (e, t) {
                              for (; U(); )
                                if (e + x === 57) break;
                                else if (e + x === 84 && 47 === L()) break;
                              return (
                                "/*" +
                                _(P, t, O - 1) +
                                "*" +
                                m(47 === e ? e : U())
                              );
                            })(U(), O)),
                            (h = r),
                            (p = i),
                            (f = l),
                            R(u, h, p, d, m(x), _(u, 2, -2), 0, f)),
                            l
                          );
                          break;
                        default:
                          Y += "/";
                      }
                      break;
                    case 123 * $:
                      c[y++] = C(Y) * F;
                    case 125 * $:
                    case 59:
                    case 0:
                      switch (H) {
                        case 0:
                        case 125:
                          B = 0;
                        case 59 + b:
                          -1 == F && (Y = w(Y, /\f/g, "")),
                            k > 0 &&
                              C(Y) - I &&
                              A(
                                k > 32
                                  ? q(Y + ";", s, i, I - 1, l)
                                  : q(w(Y, " ", "") + ";", s, i, I - 2, l),
                                l
                              );
                          break;
                        case 59:
                          Y += ";";
                        default:
                          if (
                            (A(
                              (G = W(
                                Y,
                                r,
                                i,
                                y,
                                b,
                                n,
                                c,
                                z,
                                (V = []),
                                (K = []),
                                I,
                                a
                              )),
                              a
                            ),
                            123 === H)
                          )
                            if (0 === b) e(Y, r, G, G, V, a, I, c, K);
                            else
                              switch (99 === T && 110 === E(Y, 3) ? 100 : T) {
                                case 100:
                                case 108:
                                case 109:
                                case 115:
                                  e(
                                    t,
                                    G,
                                    G,
                                    s &&
                                      A(
                                        W(
                                          t,
                                          G,
                                          G,
                                          0,
                                          0,
                                          n,
                                          c,
                                          z,
                                          n,
                                          (V = []),
                                          I,
                                          K
                                        ),
                                        K
                                      ),
                                    n,
                                    K,
                                    I,
                                    c,
                                    s ? V : K
                                  );
                                  break;
                                default:
                                  e(Y, G, G, G, [""], K, 0, c, K);
                              }
                      }
                      (y = b = k = 0), ($ = F = 1), (z = Y = ""), (I = o);
                      break;
                    case 58:
                      (I = 1 + C(Y)), (k = D);
                    default:
                      if ($ < 1) {
                        if (123 == H) --$;
                        else if (
                          125 == H &&
                          0 == $++ &&
                          125 ==
                            ((x = O > 0 ? E(P, --O) : 0),
                            N--,
                            10 === x && ((N = 1), S--),
                            x)
                        )
                          continue;
                      }
                      switch (((Y += m(H)), H * $)) {
                        case 38:
                          F = b > 0 ? 1 : ((Y += "\f"), -1);
                          break;
                        case 44:
                          (c[y++] = (C(Y) - 1) * F), (F = 1);
                          break;
                        case 64:
                          45 === L() && (Y += j(U())),
                            (T = L()),
                            (b = I =
                              C(
                                (z = Y +=
                                  (function (e) {
                                    for (; !M(L()); ) U();
                                    return _(P, e, O);
                                  })(O))
                              )),
                            H++;
                          break;
                        case 45:
                          45 === D && 2 == C(Y) && ($ = 0);
                      }
                  }
                return a;
              })(
                "",
                null,
                null,
                null,
                [""],
                ((h = p =
                  n || s
                    ? "".concat(n, " ").concat(s, " { ").concat(b, " }")
                    : b),
                (S = N = 1),
                (T = C((P = h))),
                (O = 0),
                (p = [])),
                0,
                [0],
                p
              )),
              (P = ""),
              f);
          a.namespace &&
            (I = (function e(t, r) {
              return t.map(function (t) {
                return (
                  "rule" === t.type &&
                    ((t.value = "".concat(r, " ").concat(t.value)),
                    (t.value = t.value.replaceAll(",", ",".concat(r, " "))),
                    (t.props = t.props.map(function (e) {
                      return "".concat(r, " ").concat(e);
                    }))),
                  Array.isArray(t.children) &&
                    "@keyframes" !== t.type &&
                    (t.children = e(t.children, r)),
                  t
                );
              });
            })(I, a.namespace));
          var k = [];
          return (
            $(
              I,
              ((l = (c = u.concat(
                ((y = function (e) {
                  return k.push(e);
                }),
                function (e) {
                  !e.root && (e = e.return) && y(e);
                })
              )).length),
              function (e, t, r, i) {
                for (var s = "", n = 0; n < l; n++) s += c[n](e, t, r, i) || "";
                return s;
              })
            ),
            k
          );
        };
        return (
          (p.hash = c.length
            ? c
                .reduce(function (e, t) {
                  return t.name || ek(15), el(e, t.name);
                }, 5381)
                .toString()
            : ""),
          p
        );
      }
      var e1 = new eJ(),
        e2 = e0(),
        e3 = n.createContext({
          shouldForwardProp: void 0,
          styleSheet: e1,
          stylis: e2,
        }),
        e5 = (e3.Consumer, n.createContext(void 0));
      function e8() {
        return (0, n.useContext)(e3);
      }
      function e6(e) {
        var t = (0, n.useState)(e.stylisPlugins),
          r = t[0],
          i = t[1],
          s = e8().styleSheet,
          a = (0, n.useMemo)(
            function () {
              var t = s;
              return (
                e.sheet
                  ? (t = e.sheet)
                  : e.target &&
                    (t = t.reconstructWithOptions({ target: e.target }, !1)),
                e.disableCSSOMInjection &&
                  (t = t.reconstructWithOptions({ useCSSOMInjection: !1 })),
                t
              );
            },
            [e.disableCSSOMInjection, e.sheet, e.target, s]
          ),
          c = (0, n.useMemo)(
            function () {
              return e0({
                options: {
                  namespace: e.namespace,
                  prefix: e.enableVendorPrefixes,
                },
                plugins: r,
              });
            },
            [e.enableVendorPrefixes, e.namespace, r]
          );
        (0, n.useEffect)(
          function () {
            o()(r, e.stylisPlugins) || i(e.stylisPlugins);
          },
          [e.stylisPlugins]
        );
        var l = (0, n.useMemo)(
          function () {
            return {
              shouldForwardProp: e.shouldForwardProp,
              styleSheet: a,
              stylis: c,
            };
          },
          [e.shouldForwardProp, a, c]
        );
        return n.createElement(
          e3.Provider,
          { value: l },
          n.createElement(e5.Provider, { value: c }, e.children)
        );
      }
      var e4 = (function () {
        function e(e, t) {
          var r = this;
          (this.inject = function (e, t) {
            void 0 === t && (t = e2);
            var i = r.name + t.hash;
            e.hasNameForId(r.id, i) ||
              e.insertRules(r.id, i, t(r.rules, i, "@keyframes"));
          }),
            (this.name = e),
            (this.id = "sc-keyframes-".concat(e)),
            (this.rules = t),
            eR(this, function () {
              throw ek(12, String(r.name));
            });
        }
        return (
          (e.prototype.getName = function (e) {
            return void 0 === e && (e = e2), this.name + e.hash;
          }),
          e
        );
      })();
      function e9(e) {
        for (var t = "", r = 0; r < e.length; r++) {
          var i = e[r];
          if (1 === r && "-" === i && "-" === e[0]) return e;
          i >= "A" && i <= "Z" ? (t += "-" + i.toLowerCase()) : (t += i);
        }
        return t.startsWith("ms-") ? "-" + t : t;
      }
      var e7 = function (e) {
          return null == e || !1 === e || "" === e;
        },
        te = function (e) {
          var t = [];
          for (var r in e) {
            var i = e[r];
            e.hasOwnProperty(r) &&
              !e7(i) &&
              ((Array.isArray(i) && i.isCss) || eN(i)
                ? t.push("".concat(e9(r), ":"), i, ";")
                : eP(i)
                ? t.push.apply(
                    t,
                    s(s(["".concat(r, " {")], te(i), !1), ["}"], !1)
                  )
                : t.push(
                    ""
                      .concat(e9(r), ": ")
                      .concat(
                        null == i || "boolean" == typeof i || "" === i
                          ? ""
                          : "number" != typeof i ||
                            0 === i ||
                            r in H ||
                            r.startsWith("--")
                          ? String(i).trim()
                          : "".concat(i, "px"),
                        ";"
                      )
                  ));
          }
          return t;
        };
      function tt(e, t, r, i) {
        if (e7(e)) return [];
        if (eT(e)) return [".".concat(e.styledComponentId)];
        if (eN(e))
          return !eN(e) || (e.prototype && e.prototype.isReactComponent) || !t
            ? [e]
            : tt(e(t), t, r, i);
        return e instanceof e4
          ? r
            ? (e.inject(r, i), [e.getName(i)])
            : [e]
          : eP(e)
          ? te(e)
          : Array.isArray(e)
          ? Array.prototype.concat.apply(
              Q,
              e.map(function (e) {
                return tt(e, t, r, i);
              })
            )
          : [e.toString()];
      }
      function tr(e) {
        for (var t = 0; t < e.length; t += 1) {
          var r = e[t];
          if (eN(r) && !eT(r)) return !1;
        }
        return !0;
      }
      var ti = eu(Y),
        ts = (function () {
          function e(e, t, r) {
            (this.rules = e),
              (this.staticRulesId = ""),
              (this.isStatic = (void 0 === r || r.isStatic) && tr(e)),
              (this.componentId = t),
              (this.baseHash = el(ti, t)),
              (this.baseStyle = r),
              eJ.registerId(t);
          }
          return (
            (e.prototype.generateAndInjectStyles = function (e, t, r) {
              var i = this.baseStyle
                ? this.baseStyle.generateAndInjectStyles(e, t, r)
                : "";
              if (this.isStatic && !r.hash)
                if (
                  this.staticRulesId &&
                  t.hasNameForId(this.componentId, this.staticRulesId)
                )
                  i = eO(i, this.staticRulesId);
                else {
                  var s = ex(tt(this.rules, e, t, r)),
                    n = eo(el(this.baseHash, s) >>> 0);
                  if (!t.hasNameForId(this.componentId, n)) {
                    var a = r(s, ".".concat(n), void 0, this.componentId);
                    t.insertRules(this.componentId, n, a);
                  }
                  (i = eO(i, n)), (this.staticRulesId = n);
                }
              else {
                for (
                  var o = el(this.baseHash, r.hash), c = "", l = 0;
                  l < this.rules.length;
                  l++
                ) {
                  var u = this.rules[l];
                  if ("string" == typeof u) c += u;
                  else if (u) {
                    var d = ex(tt(u, e, t, r));
                    (o = el(o, d + l)), (c += d);
                  }
                }
                if (c) {
                  var h = eo(o >>> 0);
                  t.hasNameForId(this.componentId, h) ||
                    t.insertRules(
                      this.componentId,
                      h,
                      r(c, ".".concat(h), void 0, this.componentId)
                    ),
                    (i = eO(i, h));
                }
              }
              return i;
            }),
            e
          );
        })(),
        tn = n.createContext(void 0);
      tn.Consumer;
      var ta = {};
      function to(e, t, r) {
        var s,
          a,
          o,
          c,
          l,
          u = eT(e),
          d = !eh(e),
          h = t.attrs,
          p = void 0 === h ? Q : h,
          f = t.componentId,
          g =
            void 0 === f
              ? ((a = t.displayName),
                (o = t.parentComponentId),
                (ta[(c = "string" != typeof a ? "sc" : es(a))] =
                  (ta[c] || 0) + 1),
                (l = "".concat(c, "-").concat(eo(eu(Y + c + ta[c]) >>> 0))),
                o ? "".concat(o, "-").concat(l) : l)
              : f,
          m = t.displayName,
          y =
            void 0 === m
              ? eh(e)
                ? "styled.".concat(e)
                : "Styled(".concat(
                    (s = e).displayName || s.name || "Component",
                    ")"
                  )
              : m,
          b =
            t.displayName && t.componentId
              ? "".concat(es(t.displayName), "-").concat(t.componentId)
              : t.componentId || g,
          w = u && e.attrs ? e.attrs.concat(p).filter(Boolean) : p,
          v = t.shouldForwardProp;
        if (u && e.shouldForwardProp) {
          var E = e.shouldForwardProp;
          if (t.shouldForwardProp) {
            var _ = t.shouldForwardProp;
            v = function (e, t) {
              return E(e, t) && _(e, t);
            };
          } else v = E;
        }
        var C = new ts(r, b, u ? e.componentStyle : void 0);
        function A(e, t) {
          return (function (e, t, r) {
            var s,
              a,
              o,
              c,
              l = e.attrs,
              u = e.componentStyle,
              d = e.defaultProps,
              h = e.foldedComponentIds,
              p = e.styledComponentId,
              f = e.target,
              g = n.useContext(tn),
              m = e8(),
              y = e.shouldForwardProp || m.shouldForwardProp,
              b =
                ((s = t),
                (a = g),
                void 0 === (o = d) && (o = ee),
                (s.theme !== o.theme && s.theme) || a || o.theme || ee),
              w = (function (e, t, r) {
                for (
                  var s,
                    n = i(i({}, t), { className: void 0, theme: r }),
                    a = 0;
                  a < e.length;
                  a += 1
                ) {
                  var o = eN((s = e[a])) ? s(n) : s;
                  for (var c in o)
                    n[c] =
                      "className" === c
                        ? eO(n[c], o[c])
                        : "style" === c
                        ? i(i({}, n[c]), o[c])
                        : o[c];
                }
                return (
                  t.className && (n.className = eO(n.className, t.className)), n
                );
              })(l, t, b),
              v = w.as || f,
              E = {};
            for (var _ in w)
              void 0 === w[_] ||
                "$" === _[0] ||
                "as" === _ ||
                ("theme" === _ && w.theme === b) ||
                ("forwardedAs" === _
                  ? (E.as = w.forwardedAs)
                  : (y && !y(_, v)) || (E[_] = w[_]));
            var C =
                ((c = e8()),
                u.generateAndInjectStyles(w, c.styleSheet, c.stylis)),
              A = eO(h, p);
            return (
              C && (A += " " + C),
              w.className && (A += " " + w.className),
              (E[eh(v) && !et.has(v) ? "class" : "className"] = A),
              r && (E.ref = r),
              (0, n.createElement)(v, E)
            );
          })(I, e, t);
        }
        A.displayName = y;
        var I = n.forwardRef(A);
        return (
          (I.attrs = w),
          (I.componentStyle = C),
          (I.displayName = y),
          (I.shouldForwardProp = v),
          (I.foldedComponentIds = u
            ? eO(e.foldedComponentIds, e.styledComponentId)
            : ""),
          (I.styledComponentId = b),
          (I.target = u ? e.target : e),
          Object.defineProperty(I, "defaultProps", {
            get: function () {
              return this._foldedDefaultProps;
            },
            set: function (t) {
              this._foldedDefaultProps = u
                ? (function (e) {
                    for (var t = [], r = 1; r < arguments.length; r++)
                      t[r - 1] = arguments[r];
                    for (var i = 0; i < t.length; i++)
                      !(function e(t, r, i) {
                        if (
                          (void 0 === i && (i = !1),
                          !i && !eP(t) && !Array.isArray(t))
                        )
                          return r;
                        if (Array.isArray(r))
                          for (var s = 0; s < r.length; s++)
                            t[s] = e(t[s], r[s]);
                        else if (eP(r)) for (var s in r) t[s] = e(t[s], r[s]);
                        return t;
                      })(e, t[i], !0);
                    return e;
                  })({}, e.defaultProps, t)
                : t;
            },
          }),
          eR(I, function () {
            return ".".concat(I.styledComponentId);
          }),
          d &&
            (function e(t, r, i) {
              if ("string" != typeof r) {
                if (eS) {
                  var s = eI(r);
                  s && s !== eS && e(t, s, i);
                }
                var n = e_(r);
                eC && (n = n.concat(eC(r)));
                for (var a = ev(t), o = ev(r), c = 0; c < n.length; ++c) {
                  var l = n[c];
                  if (
                    !(l in ey || (i && i[l]) || (o && l in o) || (a && l in a))
                  ) {
                    var u = eA(r, l);
                    try {
                      eE(t, l, u);
                    } catch (e) {}
                  }
                }
              }
              return t;
            })(I, e, {
              attrs: !0,
              componentStyle: !0,
              displayName: !0,
              foldedComponentIds: !0,
              shouldForwardProp: !0,
              styledComponentId: !0,
              target: !0,
            }),
          I
        );
      }
      function tc(e, t) {
        for (var r = [e[0]], i = 0, s = t.length; i < s; i += 1)
          r.push(t[i], e[i + 1]);
        return r;
      }
      var tl = function (e) {
        return Object.assign(e, { isCss: !0 });
      };
      function tu(e) {
        for (var t = [], r = 1; r < arguments.length; r++)
          t[r - 1] = arguments[r];
        return eN(e) || eP(e)
          ? tl(tt(tc(Q, s([e], t, !0))))
          : 0 === t.length && 1 === e.length && "string" == typeof e[0]
          ? tt(e)
          : tl(tt(tc(e, t)));
      }
      var td = function (e) {
          return (function e(t, r, n) {
            if ((void 0 === n && (n = ee), !r)) throw ek(1, r);
            var a = function (e) {
              for (var i = [], a = 1; a < arguments.length; a++)
                i[a - 1] = arguments[a];
              return t(r, n, tu.apply(void 0, s([e], i, !1)));
            };
            return (
              (a.attrs = function (s) {
                return e(
                  t,
                  r,
                  i(i({}, n), {
                    attrs: Array.prototype.concat(n.attrs, s).filter(Boolean),
                  })
                );
              }),
              (a.withConfig = function (s) {
                return e(t, r, i(i({}, n), s));
              }),
              a
            );
          })(to, e);
        },
        th = td;
      function tp(e) {
        for (var t = [], r = 1; r < arguments.length; r++)
          t[r - 1] = arguments[r];
        var i = ex(tu.apply(void 0, s([e], t, !1)));
        return new e4(eo(eu(i) >>> 0), i);
      }
      et.forEach(function (e) {
        th[e] = td(e);
      }),
        (function () {
          function e(e, t) {
            (this.rules = e),
              (this.componentId = t),
              (this.isStatic = tr(e)),
              eJ.registerId(this.componentId + 1);
          }
          (e.prototype.createStyles = function (e, t, r, i) {
            var s = i(ex(tt(this.rules, t, r, i)), ""),
              n = this.componentId + e;
            r.insertRules(n, n, s);
          }),
            (e.prototype.removeStyles = function (e, t) {
              t.clearRules(this.componentId + e);
            }),
            (e.prototype.renderStyles = function (e, t, r, i) {
              e > 2 && eJ.registerId(this.componentId + e),
                this.removeStyles(e, r),
                this.createStyles(e, t, r, i);
            });
        })(),
        !(function () {
          function e() {
            var e = this;
            (this._emitSheetCSS = function () {
              var t = e.instance.toString();
              if (!t) return "";
              var i = r.nc,
                s = ex(
                  [
                    i && 'nonce="'.concat(i, '"'),
                    "".concat(V, '="true"'),
                    "".concat(G, '="').concat(Y, '"'),
                  ].filter(Boolean),
                  " "
                );
              return "<style ".concat(s, ">").concat(t, "</style>");
            }),
              (this.getStyleTags = function () {
                if (e.sealed) throw ek(2);
                return e._emitSheetCSS();
              }),
              (this.getStyleElement = function () {
                if (e.sealed) throw ek(2);
                var t,
                  s = e.instance.toString();
                if (!s) return [];
                var a =
                    (((t = {})[V] = ""),
                    (t[G] = Y),
                    (t.dangerouslySetInnerHTML = { __html: s }),
                    t),
                  o = r.nc;
                return (
                  o && (a.nonce = o),
                  [n.createElement("style", i({}, a, { key: "sc-0-0" }))]
                );
              }),
              (this.seal = function () {
                e.sealed = !0;
              }),
              (this.instance = new eJ({ isServer: !0 })),
              (this.sealed = !1);
          }
          (e.prototype.collectStyles = function (e) {
            if (this.sealed) throw ek(2);
            return n.createElement(e6, { sheet: this.instance }, e);
          }),
            (e.prototype.interleaveWithNodeStream = function (e) {
              throw ek(3);
            });
        })();
    },
    59970: (e, t, r) => {
      "use strict";
      r.d(t, { Z: () => i });
      let i = {
        getSpacingStyles: (e, t) =>
          Array.isArray(e)
            ? e[t]
              ? `var(--wui-spacing-${e[t]})`
              : void 0
            : "string" == typeof e
            ? `var(--wui-spacing-${e})`
            : void 0,
        getFormattedDate: (e) =>
          new Intl.DateTimeFormat("en-US", {
            month: "short",
            day: "numeric",
          }).format(e),
        getHostName(e) {
          try {
            return new URL(e).hostname;
          } catch (e) {
            return "";
          }
        },
        getTruncateString: ({
          string: e,
          charsStart: t,
          charsEnd: r,
          truncate: i,
        }) =>
          e.length <= t + r
            ? e
            : "end" === i
            ? `${e.substring(0, t)}...`
            : "start" === i
            ? `...${e.substring(e.length - r)}`
            : `${e.substring(0, Math.floor(t))}...${e.substring(
                e.length - Math.floor(r)
              )}`,
        generateAvatarColors(e) {
          let t = e
              .toLowerCase()
              .replace(/^0x/iu, "")
              .replace(/[^a-f0-9]/gu, "")
              .substring(0, 6)
              .padEnd(6, "0"),
            r = this.hexToRgb(t),
            i = getComputedStyle(document.documentElement).getPropertyValue(
              "--w3m-border-radius-master"
            ),
            s = 100 - 3 * Number(i?.replace("px", "")),
            n = `${s}% ${s}% at 65% 40%`,
            a = [];
          for (let e = 0; e < 5; e += 1) {
            let t = this.tintColor(r, 0.15 * e);
            a.push(`rgb(${t[0]}, ${t[1]}, ${t[2]})`);
          }
          return `
    --local-color-1: ${a[0]};
    --local-color-2: ${a[1]};
    --local-color-3: ${a[2]};
    --local-color-4: ${a[3]};
    --local-color-5: ${a[4]};
    --local-radial-circle: ${n}
   `;
        },
        hexToRgb(e) {
          let t = parseInt(e, 16);
          return [(t >> 16) & 255, (t >> 8) & 255, 255 & t];
        },
        tintColor(e, t) {
          let [r, i, s] = e;
          return [
            Math.round(r + (255 - r) * t),
            Math.round(i + (255 - i) * t),
            Math.round(s + (255 - s) * t),
          ];
        },
        isNumber: (e) => /^[0-9]+$/u.test(e),
        getColorTheme: (e) =>
          e
            ? e
            : "undefined" != typeof window && window.matchMedia
            ? window.matchMedia("(prefers-color-scheme: dark)")?.matches
              ? "dark"
              : "light"
            : "dark",
        splitBalance(e) {
          let t = e.split(".");
          return 2 === t.length ? [t[0], t[1]] : ["0", "00"];
        },
        roundNumber: (e, t, r) =>
          e.toString().length >= t ? Number(e).toFixed(r) : e,
        formatNumberToLocalString: (e, t = 2) =>
          void 0 === e
            ? "0.00"
            : "number" == typeof e
            ? e.toLocaleString("en-US", {
                maximumFractionDigits: t,
                minimumFractionDigits: t,
              })
            : parseFloat(e).toLocaleString("en-US", {
                maximumFractionDigits: t,
                minimumFractionDigits: t,
              }),
      };
    },
    60500: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => s });
      var i = r(49509);
      let s = {
        WC_NAME_SUFFIX: ".reown.id",
        WC_NAME_SUFFIX_LEGACY: ".wcn.id",
        BLOCKCHAIN_API_RPC_URL: "https://rpc.walletconnect.org",
        PULSE_API_URL: "https://pulse.walletconnect.org",
        W3M_API_URL: "https://api.web3modal.org",
        CONNECTOR_ID: {
          WALLET_CONNECT: "walletConnect",
          INJECTED: "injected",
          WALLET_STANDARD: "announced",
          COINBASE: "coinbaseWallet",
          COINBASE_SDK: "coinbaseWalletSDK",
          SAFE: "safe",
          LEDGER: "ledger",
          OKX: "okx",
          EIP6963: "eip6963",
          AUTH: "ID_AUTH",
        },
        CONNECTOR_NAMES: { AUTH: "Auth" },
        AUTH_CONNECTOR_SUPPORTED_CHAINS: ["eip155", "solana"],
        LIMITS: { PENDING_TRANSACTIONS: 99 },
        CHAIN: {
          EVM: "eip155",
          SOLANA: "solana",
          POLKADOT: "polkadot",
          BITCOIN: "bip122",
        },
        CHAIN_NAME_MAP: {
          eip155: "EVM Networks",
          solana: "Solana",
          polkadot: "Polkadot",
          bip122: "Bitcoin",
          cosmos: "Cosmos",
        },
        ADAPTER_TYPES: {
          BITCOIN: "bitcoin",
          SOLANA: "solana",
          WAGMI: "wagmi",
          ETHERS: "ethers",
          ETHERS5: "ethers5",
        },
        USDT_CONTRACT_ADDRESSES: [
          "0xdac17f958d2ee523a2206206994597c13d831ec7",
          "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
          "0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7",
          "0x919C1c267BC06a7039e03fcc2eF738525769109c",
          "0x48065fbBE25f71C9282ddf5e1cD6D6A887483D5e",
          "0x55d398326f99059fF775485246999027B3197955",
          "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
        ],
        HTTP_STATUS_CODES: { SERVICE_UNAVAILABLE: 503, FORBIDDEN: 403 },
        UNSUPPORTED_NETWORK_NAME: "Unknown Network",
        SECURE_SITE_SDK_ORIGIN:
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_SECURE_SITE_ORIGIN
            : void 0) || "https://secure.walletconnect.org",
      };
    },
    62739: (e, t, r) => {
      "use strict";
      function i() {
        let e = () => void 0,
          t = () => void 0;
        return {
          promise: new Promise((r, i) => {
            (e = r), (t = i);
          }),
          resolve: e,
          reject: t,
        };
      }
      r.d(t, { Y: () => i });
    },
    62862: (e, t, r) => {
      "use strict";
      r.d(t, { v: () => s });
      var i = r(50548);
      class s {
        constructor() {}
        static getInstance({
          projectId: e,
          chainId: t,
          enableLogger: r,
          onTimeout: n,
          abortController: a,
        }) {
          return (
            s.instance ||
              (s.instance = new i.Y({
                projectId: e,
                chainId: t,
                enableLogger: r,
                onTimeout: n,
                abortController: a,
              })),
            s.instance
          );
        }
      }
    },
    63430: (e, t, r) => {
      "use strict";
      r.d(t, { O: () => s, W: () => n });
      var i = r(60500);
      let s = {
          PHANTOM: {
            id: "a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393",
            url: "https://phantom.app",
          },
          SOLFLARE: {
            id: "1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79",
            url: "https://solflare.com",
          },
          COINBASE: {
            id: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
            url: "https://go.cb-w.com",
          },
        },
        n = {
          handleMobileDeeplinkRedirect(e, t) {
            let r = window.location.href,
              n = encodeURIComponent(r);
            if (e === s.PHANTOM.id && !("phantom" in window)) {
              let e = r.startsWith("https") ? "https" : "http",
                t = r.split("/")[2],
                i = encodeURIComponent(`${e}://${t}`);
              window.location.href = `${s.PHANTOM.url}/ul/browse/${n}?ref=${i}`;
            }
            e !== s.SOLFLARE.id ||
              "solflare" in window ||
              (window.location.href = `${s.SOLFLARE.url}/ul/v1/browse/${n}?ref=${n}`),
              t !== i.o.CHAIN.SOLANA ||
                e !== s.COINBASE.id ||
                "coinbaseSolana" in window ||
                (window.location.href = `${s.COINBASE.url}/dapp?cb_url=${n}`);
          },
        };
    },
    64541: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.ONE_THOUSAND = t.ONE_HUNDRED = void 0),
        (t.ONE_HUNDRED = 100),
        (t.ONE_THOUSAND = 1e3);
    },
    64575: (e, t, r) => {
      "use strict";
      let i, s;
      r.d(t, { sX: () => c, JS: () => o });
      var n = r(35558),
        a = r(82922);
      function o() {
        if (!i)
          throw Error(
            'Please call "createAppKit" before using "useAppKit" hook'
          );
        return {
          open: async function (e) {
            await i?.open(e);
          },
          close: async function () {
            await i?.close();
          },
        };
      }
      function c(e) {
        !s &&
          (i = s =
            new a._({
              ...e,
              sdkVersion: n.w.generateSdkVersion(
                e.adapters ?? [],
                "react",
                "1.7.8"
              ),
            }));
        return s;
      }
      r(12115), r(27882);
    },
    64587: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      let i = r(86313);
      i.__exportStar(r(64541), t), i.__exportStar(r(50836), t);
    },
    64997: (e, t, r) => {
      "use strict";
      function i(e) {
        let t = e.state.current,
          r = e.state.connections.get(t),
          i = r?.accounts,
          s = i?.[0],
          n = e.chains.find((e) => e.id === r?.chainId),
          a = e.state.status;
        switch (a) {
          case "connected":
            return {
              address: s,
              addresses: i,
              chain: n,
              chainId: r?.chainId,
              connector: r?.connector,
              isConnected: !0,
              isConnecting: !1,
              isDisconnected: !1,
              isReconnecting: !1,
              status: a,
            };
          case "reconnecting":
            return {
              address: s,
              addresses: i,
              chain: n,
              chainId: r?.chainId,
              connector: r?.connector,
              isConnected: !!s,
              isConnecting: !1,
              isDisconnected: !1,
              isReconnecting: !0,
              status: a,
            };
          case "connecting":
            return {
              address: s,
              addresses: i,
              chain: n,
              chainId: r?.chainId,
              connector: r?.connector,
              isConnected: !1,
              isConnecting: !0,
              isDisconnected: !1,
              isReconnecting: !1,
              status: a,
            };
          case "disconnected":
            return {
              address: void 0,
              addresses: void 0,
              chain: void 0,
              chainId: void 0,
              connector: void 0,
              isConnected: !1,
              isConnecting: !1,
              isDisconnected: !0,
              isReconnecting: !1,
              status: a,
            };
        }
      }
      r.d(t, { s: () => i });
    },
    65003: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => i });
      class i extends Map {
        constructor(e) {
          super(),
            Object.defineProperty(this, "maxSize", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.maxSize = e);
        }
        get(e) {
          let t = super.get(e);
          return (
            super.has(e) && void 0 !== t && (this.delete(e), super.set(e, t)), t
          );
        }
        set(e, t) {
          if ((super.set(e, t), this.maxSize && this.size > this.maxSize)) {
            let e = this.keys().next().value;
            e && this.delete(e);
          }
          return this;
        }
      }
    },
    65368: (e, t, r) => {
      "use strict";
      let i;
      r.d(t, { L: () => n });
      let s = 256;
      function n(e = 11) {
        if (!i || s + e > 512) {
          (i = ""), (s = 0);
          for (let e = 0; e < 256; e++)
            i += ((256 + 256 * Math.random()) | 0).toString(16).substring(1);
        }
        return i.substring(s, s++ + e);
      }
    },
    65819: (e, t, r) => {
      "use strict";
      r.d(t, { N: () => b });
      var i = r(43708),
        s = r(70799),
        n = r(34735),
        a = r(35558),
        o = r(43359),
        c = r(63430),
        l = r(5582),
        u = r(74623),
        d = r(90906),
        h = r(54252),
        p = r(32836),
        f = r(96641);
      let g = a.w.getApiUrl(),
        m = new o.Z({ baseUrl: g, clientId: null }),
        y = (0, i.BX)({
          promises: {},
          page: 1,
          count: 0,
          featured: [],
          allFeatured: [],
          recommended: [],
          allRecommended: [],
          wallets: [],
          filteredWallets: [],
          search: [],
          isAnalyticsEnabled: !1,
          excludedWallets: [],
          isFetchingRecommendedWallets: !1,
        }),
        b = {
          state: y,
          subscribeKey: (e, t) => (0, s.u$)(y, e, t),
          _getSdkProperties() {
            let { projectId: e, sdkType: t, sdkVersion: r } = f.H.state;
            return {
              projectId: e,
              st: t || "appkit",
              sv: r || "html-wagmi-4.2.2",
            };
          },
          _filterOutExtensions: (e) =>
            f.H.state.isUniversalProvider
              ? e.filter(
                  (e) => !!(e.mobile_link || e.desktop_link || e.webapp_link)
                )
              : e,
          async _fetchWalletImage(e) {
            let t = `${m.baseUrl}/getWalletImage/${e}`,
              r = await m.getBlob({ path: t, params: b._getSdkProperties() });
            u.j.setWalletImage(e, URL.createObjectURL(r));
          },
          async _fetchNetworkImage(e) {
            let t = `${m.baseUrl}/public/getAssetImage/${e}`,
              r = await m.getBlob({ path: t, params: b._getSdkProperties() });
            u.j.setNetworkImage(e, URL.createObjectURL(r));
          },
          async _fetchConnectorImage(e) {
            let t = `${m.baseUrl}/public/getAssetImage/${e}`,
              r = await m.getBlob({ path: t, params: b._getSdkProperties() });
            u.j.setConnectorImage(e, URL.createObjectURL(r));
          },
          async _fetchCurrencyImage(e) {
            let t = `${m.baseUrl}/public/getCurrencyImage/${e}`,
              r = await m.getBlob({ path: t, params: b._getSdkProperties() });
            u.j.setCurrencyImage(e, URL.createObjectURL(r));
          },
          async _fetchTokenImage(e) {
            let t = `${m.baseUrl}/public/getTokenImage/${e}`,
              r = await m.getBlob({ path: t, params: b._getSdkProperties() });
            u.j.setTokenImage(e, URL.createObjectURL(r));
          },
          _filterWalletsByPlatform: (e) =>
            a.w.isMobile()
              ? e?.filter(
                  (e) =>
                    !!e.mobile_link ||
                    e.id === c.O.COINBASE.id ||
                    ("solana" === d.W.state.activeChain &&
                      (e.id === c.O.SOLFLARE.id || e.id === c.O.PHANTOM.id))
                )
              : e,
          fetchProjectConfig: async () =>
            (
              await m.get({
                path: "/appkit/v1/config",
                params: b._getSdkProperties(),
              })
            ).features,
          async fetchAllowedOrigins() {
            try {
              let { allowedOrigins: e } = await m.get({
                path: "/projects/v1/origins",
                params: b._getSdkProperties(),
              });
              return e;
            } catch (e) {
              return [];
            }
          },
          async fetchNetworkImages() {
            let e = d.W.getAllRequestedCaipNetworks(),
              t = e
                ?.map(({ assets: e }) => e?.imageId)
                .filter(Boolean)
                .filter((e) => !n.$.getNetworkImageById(e));
            t &&
              (await Promise.allSettled(t.map((e) => b._fetchNetworkImage(e))));
          },
          async fetchConnectorImages() {
            let { connectors: e } = h.a.state,
              t = e.map(({ imageId: e }) => e).filter(Boolean);
            await Promise.allSettled(t.map((e) => b._fetchConnectorImage(e)));
          },
          async fetchCurrencyImages(e = []) {
            await Promise.allSettled(e.map((e) => b._fetchCurrencyImage(e)));
          },
          async fetchTokenImages(e = []) {
            await Promise.allSettled(e.map((e) => b._fetchTokenImage(e)));
          },
          async fetchWallets(e) {
            let t = e.exclude ?? [];
            b._getSdkProperties().sv.startsWith("html-core-") &&
              t.push(...Object.values(c.O).map((e) => e.id));
            let r = await m.get({
              path: "/getWallets",
              params: {
                ...b._getSdkProperties(),
                ...e,
                page: String(e.page),
                entries: String(e.entries),
                include: e.include?.join(","),
                exclude: t.join(","),
              },
            });
            return {
              data: b._filterWalletsByPlatform(r?.data) || [],
              count: r?.count,
            };
          },
          async fetchFeaturedWallets() {
            let { featuredWalletIds: e } = f.H.state;
            if (e?.length) {
              let t = {
                  ...b._getSdkProperties(),
                  page: 1,
                  entries: e?.length ?? 4,
                  include: e,
                },
                { data: r } = await b.fetchWallets(t),
                i = [...r].sort((t, r) => e.indexOf(t.id) - e.indexOf(r.id)),
                s = i.map((e) => e.image_id).filter(Boolean);
              await Promise.allSettled(s.map((e) => b._fetchWalletImage(e))),
                (y.featured = i),
                (y.allFeatured = i);
            }
          },
          async fetchRecommendedWallets() {
            try {
              y.isFetchingRecommendedWallets = !0;
              let {
                  includeWalletIds: e,
                  excludeWalletIds: t,
                  featuredWalletIds: r,
                } = f.H.state,
                i = [...(t ?? []), ...(r ?? [])].filter(Boolean),
                s = d.W.getRequestedCaipNetworkIds().join(","),
                { data: n, count: a } = await b.fetchWallets({
                  page: 1,
                  entries: 4,
                  include: e,
                  exclude: i,
                  chains: s,
                }),
                o = l.i.getRecentWallets(),
                c = n.map((e) => e.image_id).filter(Boolean),
                u = o.map((e) => e.image_id).filter(Boolean);
              await Promise.allSettled(
                [...c, ...u].map((e) => b._fetchWalletImage(e))
              ),
                (y.recommended = n),
                (y.allRecommended = n),
                (y.count = a ?? 0);
            } catch {
            } finally {
              y.isFetchingRecommendedWallets = !1;
            }
          },
          async fetchWalletsByPage({ page: e }) {
            let {
                includeWalletIds: t,
                excludeWalletIds: r,
                featuredWalletIds: i,
              } = f.H.state,
              s = d.W.getRequestedCaipNetworkIds().join(","),
              n = [
                ...y.recommended.map(({ id: e }) => e),
                ...(r ?? []),
                ...(i ?? []),
              ].filter(Boolean),
              { data: o, count: c } = await b.fetchWallets({
                page: e,
                entries: 40,
                include: t,
                exclude: n,
                chains: s,
              }),
              l = o
                .slice(0, 20)
                .map((e) => e.image_id)
                .filter(Boolean);
            await Promise.allSettled(l.map((e) => b._fetchWalletImage(e))),
              (y.wallets = a.w
                .uniqueBy([...y.wallets, ...b._filterOutExtensions(o)], "id")
                .filter((e) => e.chains?.some((e) => s.includes(e)))),
              (y.count = c > y.count ? c : y.count),
              (y.page = e);
          },
          async initializeExcludedWallets({ ids: e }) {
            let t = { page: 1, entries: e.length, include: e },
              { data: r } = await b.fetchWallets(t);
            r &&
              r.forEach((e) => {
                y.excludedWallets.push({ rdns: e.rdns, name: e.name });
              });
          },
          async searchWallet({ search: e, badge: t }) {
            let { includeWalletIds: r, excludeWalletIds: i } = f.H.state,
              s = d.W.getRequestedCaipNetworkIds().join(",");
            y.search = [];
            let n = {
                page: 1,
                entries: 100,
                search: e?.trim(),
                badge_type: t,
                include: r,
                exclude: i,
                chains: s,
              },
              { data: o } = await b.fetchWallets(n);
            p.E.sendEvent({
              type: "track",
              event: "SEARCH_WALLET",
              properties: { badge: t ?? "", search: e ?? "" },
            });
            let c = o.map((e) => e.image_id).filter(Boolean);
            await Promise.allSettled([
              ...c.map((e) => b._fetchWalletImage(e)),
              a.w.wait(300),
            ]),
              (y.search = b._filterOutExtensions(o));
          },
          initPromise(e, t) {
            let r = y.promises[e];
            return r || (y.promises[e] = t());
          },
          prefetch: ({
            fetchConnectorImages: e = !0,
            fetchFeaturedWallets: t = !0,
            fetchRecommendedWallets: r = !0,
            fetchNetworkImages: i = !0,
          } = {}) =>
            Promise.allSettled(
              [
                e && b.initPromise("connectorImages", b.fetchConnectorImages),
                t && b.initPromise("featuredWallets", b.fetchFeaturedWallets),
                r &&
                  b.initPromise(
                    "recommendedWallets",
                    b.fetchRecommendedWallets
                  ),
                i && b.initPromise("networkImages", b.fetchNetworkImages),
              ].filter(Boolean)
            ),
          prefetchAnalyticsConfig() {
            f.H.state.features?.analytics && b.fetchAnalyticsConfig();
          },
          async fetchAnalyticsConfig() {
            try {
              let { isAnalyticsEnabled: e } = await m.get({
                path: "/getAnalyticsConfig",
                params: b._getSdkProperties(),
              });
              f.H.setFeatures({ analytics: e });
            } catch (e) {
              f.H.setFeatures({ analytics: !1 });
            }
          },
          filterByNamespaces(e) {
            if (!e?.length) {
              (y.featured = y.allFeatured), (y.recommended = y.allRecommended);
              return;
            }
            let t = d.W.getRequestedCaipNetworkIds().join(",");
            (y.featured = y.allFeatured.filter((e) =>
              e.chains?.some((e) => t.includes(e))
            )),
              (y.recommended = y.allRecommended.filter((e) =>
                e.chains?.some((e) => t.includes(e))
              )),
              (y.filteredWallets = y.wallets.filter((e) =>
                e.chains?.some((e) => t.includes(e))
              ));
          },
          clearFilterByNamespaces() {
            y.filteredWallets = [];
          },
          setFilterByNamespace(e) {
            if (!e) {
              (y.featured = y.allFeatured), (y.recommended = y.allRecommended);
              return;
            }
            let t = d.W.getRequestedCaipNetworkIds().join(",");
            (y.featured = y.allFeatured.filter((e) =>
              e.chains?.some((e) => t.includes(e))
            )),
              (y.recommended = y.allRecommended.filter((e) =>
                e.chains?.some((e) => t.includes(e))
              )),
              (y.filteredWallets = y.wallets.filter((e) =>
                e.chains?.some((e) => t.includes(e))
              ));
          },
        };
    },
    65962: (e, t, r) => {
      "use strict";
      r.d(t, { v: () => o });
      let i = [
          {
            type: "function",
            name: "transfer",
            stateMutability: "nonpayable",
            inputs: [
              { name: "_to", type: "address" },
              { name: "_value", type: "uint256" },
            ],
            outputs: [{ name: "", type: "bool" }],
          },
          {
            type: "function",
            name: "transferFrom",
            stateMutability: "nonpayable",
            inputs: [
              { name: "_from", type: "address" },
              { name: "_to", type: "address" },
              { name: "_value", type: "uint256" },
            ],
            outputs: [{ name: "", type: "bool" }],
          },
        ],
        s = [
          {
            type: "function",
            name: "approve",
            stateMutability: "nonpayable",
            inputs: [
              { name: "spender", type: "address" },
              { name: "amount", type: "uint256" },
            ],
            outputs: [{ type: "bool" }],
          },
        ],
        n = [
          {
            type: "function",
            name: "transfer",
            stateMutability: "nonpayable",
            inputs: [
              { name: "recipient", type: "address" },
              { name: "amount", type: "uint256" },
            ],
            outputs: [],
          },
          {
            type: "function",
            name: "transferFrom",
            stateMutability: "nonpayable",
            inputs: [
              { name: "sender", type: "address" },
              { name: "recipient", type: "address" },
              { name: "amount", type: "uint256" },
            ],
            outputs: [{ name: "", type: "bool" }],
          },
        ];
      var a = r(60500);
      let o = {
        getERC20Abi: (e) => (a.o.USDT_CONTRACT_ADDRESSES.includes(e) ? n : i),
        getSwapAbi: () => s,
      };
    },
    67622: (e, t, r) => {
      "use strict";
      r.d(t, {
        $P: () => c,
        My: () => l,
        cK: () => u,
        i3: () => h,
        nj: () => o,
      });
      var i = r(94201),
        s = r(36984),
        n = r(27493);
      let a = Array.from({ length: 256 }, (e, t) =>
        t.toString(16).padStart(2, "0")
      );
      function o(e, t = {}) {
        return "number" == typeof e || "bigint" == typeof e
          ? u(e, t)
          : "string" == typeof e
          ? h(e, t)
          : "boolean" == typeof e
          ? c(e, t)
          : l(e, t);
      }
      function c(e, t = {}) {
        let r = `0x${Number(e)}`;
        return "number" == typeof t.size
          ? ((0, n.Sl)(r, { size: t.size }), (0, s.eV)(r, { size: t.size }))
          : r;
      }
      function l(e, t = {}) {
        let r = "";
        for (let t = 0; t < e.length; t++) r += a[e[t]];
        let i = `0x${r}`;
        return "number" == typeof t.size
          ? ((0, n.Sl)(i, { size: t.size }),
            (0, s.eV)(i, { dir: "right", size: t.size }))
          : i;
      }
      function u(e, t = {}) {
        let r,
          { signed: n, size: a } = t,
          o = BigInt(e);
        a
          ? (r = n
              ? (1n << (8n * BigInt(a) - 1n)) - 1n
              : 2n ** (8n * BigInt(a)) - 1n)
          : "number" == typeof e && (r = BigInt(Number.MAX_SAFE_INTEGER));
        let c = "bigint" == typeof r && n ? -r - 1n : 0;
        if ((r && o > r) || o < c) {
          let t = "bigint" == typeof e ? "n" : "";
          throw new i.Ty({
            max: r ? `${r}${t}` : void 0,
            min: `${c}${t}`,
            signed: n,
            size: a,
            value: `${e}${t}`,
          });
        }
        let l = `0x${(n && o < 0
          ? (1n << BigInt(8 * a)) + BigInt(o)
          : o
        ).toString(16)}`;
        return a ? (0, s.eV)(l, { size: a }) : l;
      }
      let d = new TextEncoder();
      function h(e, t = {}) {
        return l(d.encode(e), t);
      }
    },
    68319: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => w });
      var i = r(43708),
        s = r(70799),
        n = r(18227),
        a = r(65962),
        o = r(45312),
        c = r(76610),
        l = r(35558),
        u = r(75376),
        d = r(92555),
        h = r(11076),
        p = r(90906),
        f = r(6193),
        g = r(32836),
        m = r(19628),
        y = r(5517);
      let b = (0, i.BX)({ tokenBalances: [], loading: !1 }),
        w = (0, d.X)({
          state: b,
          subscribe: (e) => (0, i.B1)(b, () => e(b)),
          subscribeKey: (e, t) => (0, s.u$)(b, e, t),
          setToken(e) {
            e && (b.token = (0, i.KR)(e));
          },
          setTokenAmount(e) {
            b.sendTokenAmount = e;
          },
          setReceiverAddress(e) {
            b.receiverAddress = e;
          },
          setReceiverProfileImageUrl(e) {
            b.receiverProfileImageUrl = e;
          },
          setReceiverProfileName(e) {
            b.receiverProfileName = e;
          },
          setNetworkBalanceInUsd(e) {
            b.networkBalanceInUSD = e;
          },
          setLoading(e) {
            b.loading = e;
          },
          async sendToken() {
            try {
              switch (
                (w.setLoading(!0), p.W.state.activeCaipNetwork?.chainNamespace)
              ) {
                case "eip155":
                  await w.sendEvmToken();
                  return;
                case "solana":
                  await w.sendSolanaToken();
                  return;
                default:
                  throw Error("Unsupported chain");
              }
            } finally {
              w.setLoading(!1);
            }
          },
          async sendEvmToken() {
            let e = p.W.state.activeChain,
              t = h.U.state.preferredAccountTypes?.[e];
            if (!w.state.sendTokenAmount || !w.state.receiverAddress)
              throw Error("An amount and receiver address are required");
            if (!w.state.token) throw Error("A token is required");
            w.state.token?.address
              ? (g.E.sendEvent({
                  type: "track",
                  event: "SEND_INITIATED",
                  properties: {
                    isSmartAccount: t === o.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                    token: w.state.token.address,
                    amount: w.state.sendTokenAmount,
                    network: p.W.state.activeCaipNetwork?.caipNetworkId || "",
                  },
                }),
                await w.sendERC20Token({
                  receiverAddress: w.state.receiverAddress,
                  tokenAddress: w.state.token.address,
                  sendTokenAmount: w.state.sendTokenAmount,
                  decimals: w.state.token.quantity.decimals,
                }))
              : (g.E.sendEvent({
                  type: "track",
                  event: "SEND_INITIATED",
                  properties: {
                    isSmartAccount: t === o.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                    token: w.state.token.symbol || "",
                    amount: w.state.sendTokenAmount,
                    network: p.W.state.activeCaipNetwork?.caipNetworkId || "",
                  },
                }),
                await w.sendNativeToken({
                  receiverAddress: w.state.receiverAddress,
                  sendTokenAmount: w.state.sendTokenAmount,
                  decimals: w.state.token.quantity.decimals,
                }));
          },
          async fetchTokenBalance(e) {
            b.loading = !0;
            let t = p.W.state.activeCaipNetwork?.caipNetworkId,
              r = p.W.state.activeCaipNetwork?.chainNamespace,
              i = p.W.state.activeCaipAddress,
              s = i ? l.w.getPlainAddress(i) : void 0;
            if (
              b.lastRetry &&
              !l.w.isAllowedRetry(b.lastRetry, 30 * c.oU.ONE_SEC_MS)
            )
              return (b.loading = !1), [];
            try {
              if (s && t && r) {
                let e = await u.t.getMyTokensWithBalance();
                return (b.tokenBalances = e), (b.lastRetry = void 0), e;
              }
            } catch (t) {
              (b.lastRetry = Date.now()),
                e?.(t),
                y.P.showError("Token Balance Unavailable");
            } finally {
              b.loading = !1;
            }
            return [];
          },
          fetchNetworkBalance() {
            if (0 === b.tokenBalances.length) return;
            let e = u.t.mapBalancesToSwapTokens(b.tokenBalances);
            if (!e) return;
            let t = e.find(
              (e) => e.address === p.W.getActiveNetworkTokenAddress()
            );
            t &&
              (b.networkBalanceInUSD = t
                ? n.S.multiply(t.quantity.numeric, t.price).toString()
                : "0");
          },
          async sendNativeToken(e) {
            m.I.pushTransactionStack({});
            let t = e.receiverAddress,
              r = h.U.state.address,
              i = f.x.parseUnits(
                e.sendTokenAmount.toString(),
                Number(e.decimals)
              );
            await f.x.sendTransaction({
              chainNamespace: "eip155",
              to: t,
              address: r,
              data: "0x",
              value: i ?? BigInt(0),
            }),
              g.E.sendEvent({
                type: "track",
                event: "SEND_SUCCESS",
                properties: {
                  isSmartAccount:
                    h.U.state.preferredAccountTypes?.eip155 ===
                    o.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                  token: w.state.token?.symbol || "",
                  amount: e.sendTokenAmount,
                  network: p.W.state.activeCaipNetwork?.caipNetworkId || "",
                },
              }),
              f.x._getClient()?.updateBalance("eip155"),
              w.resetSend();
          },
          async sendERC20Token(e) {
            m.I.pushTransactionStack({
              onSuccess() {
                m.I.replace("Account");
              },
            });
            let t = f.x.parseUnits(
              e.sendTokenAmount.toString(),
              Number(e.decimals)
            );
            if (
              h.U.state.address &&
              e.sendTokenAmount &&
              e.receiverAddress &&
              e.tokenAddress
            ) {
              let r = l.w.getPlainAddress(e.tokenAddress);
              await f.x.writeContract({
                fromAddress: h.U.state.address,
                tokenAddress: r,
                args: [e.receiverAddress, t ?? BigInt(0)],
                method: "transfer",
                abi: a.v.getERC20Abi(r),
                chainNamespace: "eip155",
              }),
                w.resetSend();
            }
          },
          async sendSolanaToken() {
            if (!w.state.sendTokenAmount || !w.state.receiverAddress)
              throw Error("An amount and receiver address are required");
            m.I.pushTransactionStack({
              onSuccess() {
                m.I.replace("Account");
              },
            }),
              await f.x.sendTransaction({
                chainNamespace: "solana",
                to: w.state.receiverAddress,
                value: w.state.sendTokenAmount,
              }),
              f.x._getClient()?.updateBalance("solana"),
              w.resetSend();
          },
          resetSend() {
            (b.token = void 0),
              (b.sendTokenAmount = void 0),
              (b.receiverAddress = void 0),
              (b.receiverProfileImageUrl = void 0),
              (b.receiverProfileName = void 0),
              (b.loading = !1),
              (b.tokenBalances = []);
          },
        });
    },
    68928: (e) => {
      "use strict";
      function t(e) {
        try {
          return JSON.stringify(e);
        } catch (e) {
          return '"[Circular]"';
        }
      }
      e.exports = function (e, r, i) {
        var s = (i && i.stringify) || t;
        if ("object" == typeof e && null !== e) {
          var n = r.length + 1;
          if (1 === n) return e;
          var a = Array(n);
          a[0] = s(e);
          for (var o = 1; o < n; o++) a[o] = s(r[o]);
          return a.join(" ");
        }
        if ("string" != typeof e) return e;
        var c = r.length;
        if (0 === c) return e;
        for (
          var l = "", u = 0, d = -1, h = (e && e.length) || 0, p = 0;
          p < h;

        ) {
          if (37 === e.charCodeAt(p) && p + 1 < h) {
            switch (((d = d > -1 ? d : 0), e.charCodeAt(p + 1))) {
              case 100:
              case 102:
                if (u >= c || null == r[u]) break;
                d < p && (l += e.slice(d, p)),
                  (l += Number(r[u])),
                  (d = p + 2),
                  p++;
                break;
              case 105:
                if (u >= c || null == r[u]) break;
                d < p && (l += e.slice(d, p)),
                  (l += Math.floor(Number(r[u]))),
                  (d = p + 2),
                  p++;
                break;
              case 79:
              case 111:
              case 106:
                if (u >= c || void 0 === r[u]) break;
                d < p && (l += e.slice(d, p));
                var f = typeof r[u];
                if ("string" === f) {
                  (l += "'" + r[u] + "'"), (d = p + 2), p++;
                  break;
                }
                if ("function" === f) {
                  (l += r[u].name || "<anonymous>"), (d = p + 2), p++;
                  break;
                }
                (l += s(r[u])), (d = p + 2), p++;
                break;
              case 115:
                if (u >= c) break;
                d < p && (l += e.slice(d, p)),
                  (l += String(r[u])),
                  (d = p + 2),
                  p++;
                break;
              case 37:
                d < p && (l += e.slice(d, p)),
                  (l += "%"),
                  (d = p + 2),
                  p++,
                  u--;
            }
            ++u;
          }
          ++p;
        }
        return -1 === d ? e : (d < h && (l += e.slice(d)), l);
      };
    },
    70799: (e, t, r) => {
      "use strict";
      let i;
      r.d(t, { u$: () => n, zC: () => o });
      var s = r(43708);
      function n(e, t, r, i) {
        let n = e[t];
        return (0, s.B1)(
          e,
          () => {
            let i = e[t];
            Object.is(n, i) || r((n = i));
          },
          i
        );
      }
      Symbol();
      let a = (e) => "object" == typeof e && null !== e;
      function o(e) {
        let t = (0, s.BX)({
          data: Array.from(e || []),
          has(e) {
            return this.data.some((t) => t[0] === e);
          },
          set(e, t) {
            let r = this.data.find((t) => t[0] === e);
            return r ? (r[1] = t) : this.data.push([e, t]), this;
          },
          get(e) {
            var t;
            return null == (t = this.data.find((t) => t[0] === e))
              ? void 0
              : t[1];
          },
          delete(e) {
            let t = this.data.findIndex((t) => t[0] === e);
            return -1 !== t && (this.data.splice(t, 1), !0);
          },
          clear() {
            this.data.splice(0);
          },
          get size() {
            return this.data.length;
          },
          toJSON() {
            return new Map(this.data);
          },
          forEach(e) {
            this.data.forEach((t) => {
              e(t[1], t[0], this);
            });
          },
          keys() {
            return this.data.map((e) => e[0]).values();
          },
          values() {
            return this.data.map((e) => e[1]).values();
          },
          entries() {
            return new Map(this.data).entries();
          },
          get [Symbol.toStringTag]() {
            return "Map";
          },
          [Symbol.iterator]() {
            return this.entries();
          },
        });
        return (
          Object.defineProperties(t, {
            data: { enumerable: !1 },
            size: { enumerable: !1 },
            toJSON: { enumerable: !1 },
          }),
          Object.seal(t),
          t
        );
      }
    },
    71075: (e, t, r) => {
      "use strict";
      r.d(t, { h: () => a, j: () => n });
      let i = (e) =>
          JSON.stringify(e, (e, t) =>
            "bigint" == typeof t ? t.toString() + "n" : t
          ),
        s = (e) =>
          JSON.parse(
            e.replace(
              /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g,
              '$1"$2n"$3'
            ),
            (e, t) =>
              "string" == typeof t && t.match(/^\d+n$/)
                ? BigInt(t.substring(0, t.length - 1))
                : t
          );
      function n(e) {
        if ("string" != typeof e)
          throw Error(`Cannot safe json parse value of type ${typeof e}`);
        try {
          return s(e);
        } catch (t) {
          return e;
        }
      }
      function a(e) {
        return "string" == typeof e ? e : i(e) || "";
      }
    },
    73504: (e, t, r) => {
      "use strict";
      function i() {
        let e,
          t,
          r = new Promise((r, i) => {
            (e = r), (t = i);
          });
        function i(e) {
          Object.assign(r, e), delete r.resolve, delete r.reject;
        }
        return (
          (r.status = "pending"),
          r.catch(() => {}),
          (r.resolve = (t) => {
            i({ status: "fulfilled", value: t }), e(t);
          }),
          (r.reject = (e) => {
            i({ status: "rejected", reason: e }), t(e);
          }),
          r
        );
      }
      r.d(t, { T: () => i });
    },
    74623: (e, t, r) => {
      "use strict";
      r.d(t, { j: () => o });
      var i = r(43708),
        s = r(70799),
        n = r(92555);
      let a = (0, i.BX)({
          walletImages: {},
          networkImages: {},
          chainImages: {},
          connectorImages: {},
          tokenImages: {},
          currencyImages: {},
        }),
        o = (0, n.X)({
          state: a,
          subscribeNetworkImages: (e) =>
            (0, i.B1)(a.networkImages, () => e(a.networkImages)),
          subscribeKey: (e, t) => (0, s.u$)(a, e, t),
          subscribe: (e) => (0, i.B1)(a, () => e(a)),
          setWalletImage(e, t) {
            a.walletImages[e] = t;
          },
          setNetworkImage(e, t) {
            a.networkImages[e] = t;
          },
          setChainImage(e, t) {
            a.chainImages[e] = t;
          },
          setConnectorImage(e, t) {
            a.connectorImages = { ...a.connectorImages, [e]: t };
          },
          setTokenImage(e, t) {
            a.tokenImages[e] = t;
          },
          setCurrencyImage(e, t) {
            a.currencyImages[e] = t;
          },
        });
    },
    75376: (e, t, r) => {
      "use strict";
      r.d(t, { t: () => l });
      var i = r(11076),
        s = r(11501),
        n = r(90906),
        a = r(6193),
        o = r(1405);
      let c = {
          createBalance(e, t) {
            let r = {
              name: e.metadata.name || "",
              symbol: e.metadata.symbol || "",
              decimals: e.metadata.decimals || 0,
              value: e.metadata.value || 0,
              price: e.metadata.price || 0,
              iconUrl: e.metadata.iconUrl || "",
            };
            return {
              name: r.name,
              symbol: r.symbol,
              chainId: t,
              address:
                "native" === e.address
                  ? void 0
                  : this.convertAddressToCAIP10Address(e.address, t),
              value: r.value,
              price: r.price,
              quantity: {
                decimals: r.decimals.toString(),
                numeric: this.convertHexToBalance({
                  hex: e.balance,
                  decimals: r.decimals,
                }),
              },
              iconUrl: r.iconUrl,
            };
          },
          convertHexToBalance: ({ hex: e, decimals: t }) =>
            (0, o.J)(BigInt(e), t),
          convertAddressToCAIP10Address: (e, t) => `${t}:${e}`,
          createCAIP2ChainId: (e, t) => `${t}:${parseInt(e, 16)}`,
          getChainIdHexFromCAIP2ChainId(e) {
            let t = e.split(":");
            if (t.length < 2 || !t[1]) return "0x0";
            let r = parseInt(t[1], 10);
            return isNaN(r) ? "0x0" : `0x${r.toString(16)}`;
          },
          isWalletGetAssetsResponse(e) {
            return (
              "object" == typeof e &&
              null !== e &&
              Object.values(e).every(
                (e) => Array.isArray(e) && e.every((e) => this.isValidAsset(e))
              )
            );
          },
          isValidAsset: (e) =>
            "object" == typeof e &&
            null !== e &&
            "string" == typeof e.address &&
            "string" == typeof e.balance &&
            ("ERC20" === e.type || "NATIVE" === e.type) &&
            "object" == typeof e.metadata &&
            null !== e.metadata &&
            "string" == typeof e.metadata.name &&
            "string" == typeof e.metadata.symbol &&
            "number" == typeof e.metadata.decimals &&
            "number" == typeof e.metadata.price &&
            "string" == typeof e.metadata.iconUrl,
        },
        l = {
          async getMyTokensWithBalance(e) {
            let t = i.U.state.address,
              r = n.W.state.activeCaipNetwork;
            if (!t || !r) return [];
            if ("eip155" === r.chainNamespace) {
              let e = await this.getEIP155Balances(t, r);
              if (e) return this.filterLowQualityTokens(e);
            }
            let a = await s.T.getBalance(t, r.caipNetworkId, e);
            return this.filterLowQualityTokens(a.balances);
          },
          async getEIP155Balances(e, t) {
            try {
              let r = c.getChainIdHexFromCAIP2ChainId(t.caipNetworkId),
                i = await a.x.getCapabilities(e);
              if (!i?.[r]?.assetDiscovery?.supported) return null;
              let s = await a.x.walletGetAssets({
                account: e,
                chainFilter: [r],
              });
              if (!c.isWalletGetAssetsResponse(s)) return null;
              return (s[r] || []).map((e) =>
                c.createBalance(e, t.caipNetworkId)
              );
            } catch (e) {
              return null;
            }
          },
          filterLowQualityTokens: (e) =>
            e.filter((e) => "0" !== e.quantity.decimals),
          mapBalancesToSwapTokens: (e) =>
            e?.map((e) => ({
              ...e,
              address: e?.address
                ? e.address
                : n.W.getActiveNetworkTokenAddress(),
              decimals: parseInt(e.quantity.decimals, 10),
              logoUri: e.iconUrl,
              eip2612: !1,
            })) || [],
        };
    },
    75483: (e, t, r) => {
      "use strict";
      r.d(t, { M: () => s });
      let i = !1;
      async function s(e, t = {}) {
        let r;
        if (i) return [];
        (i = !0),
          e.setState((e) => ({
            ...e,
            status: e.current ? "reconnecting" : "connecting",
          }));
        let n = [];
        if (t.connectors?.length)
          for (let r of t.connectors) {
            let t;
            (t = "function" == typeof r ? e._internal.connectors.setup(r) : r),
              n.push(t);
          }
        else n.push(...e.connectors);
        try {
          r = await e.storage?.getItem("recentConnectorId");
        } catch {}
        let a = {};
        for (let [, t] of e.state.connections) a[t.connector.id] = 1;
        r && (a[r] = 0);
        let o =
            Object.keys(a).length > 0
              ? [...n].sort((e, t) => (a[e.id] ?? 10) - (a[t.id] ?? 10))
              : n,
          c = !1,
          l = [],
          u = [];
        for (let t of o) {
          let r = await t.getProvider().catch(() => void 0);
          if (!r || u.some((e) => e === r) || !(await t.isAuthorized()))
            continue;
          let i = await t.connect({ isReconnecting: !0 }).catch(() => null);
          i &&
            (t.emitter.off("connect", e._internal.events.connect),
            t.emitter.on("change", e._internal.events.change),
            t.emitter.on("disconnect", e._internal.events.disconnect),
            e.setState((e) => {
              let r = new Map(c ? e.connections : new Map()).set(t.uid, {
                accounts: i.accounts,
                chainId: i.chainId,
                connector: t,
              });
              return { ...e, current: c ? e.current : t.uid, connections: r };
            }),
            l.push({ accounts: i.accounts, chainId: i.chainId, connector: t }),
            u.push(r),
            (c = !0));
        }
        return (
          ("reconnecting" === e.state.status ||
            "connecting" === e.state.status) &&
            (c
              ? e.setState((e) => ({ ...e, status: "connected" }))
              : e.setState((e) => ({
                  ...e,
                  connections: new Map(),
                  current: null,
                  status: "disconnected",
                }))),
          (i = !1),
          l
        );
      }
    },
    76610: (e, t, r) => {
      "use strict";
      r.d(t, { Db: () => a, oU: () => o, tM: () => n });
      var i = r(49509);
      let s =
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_SECURE_SITE_ORIGIN
            : void 0) || "https://secure.walletconnect.org",
        n = [
          {
            label: "Coinbase",
            name: "coinbase",
            feeRange: "1-2%",
            url: "",
            supportedChains: ["eip155"],
          },
          {
            label: "Meld.io",
            name: "meld",
            feeRange: "1-2%",
            url: "https://meldcrypto.com",
            supportedChains: ["eip155", "solana"],
          },
        ],
        a = "WXETMuFUQmqqybHuRkSgxv:25B8LJHSfpG6LVjR2ytU5Cwh7Z4Sch2ocoU",
        o = {
          FOUR_MINUTES_MS: 24e4,
          TEN_SEC_MS: 1e4,
          FIVE_SEC_MS: 5e3,
          THREE_SEC_MS: 3e3,
          ONE_SEC_MS: 1e3,
          SECURE_SITE: s,
          SECURE_SITE_DASHBOARD: `${s}/dashboard`,
          SECURE_SITE_FAVICON: `${s}/images/favicon.png`,
          RESTRICTED_TIMEZONES: [
            "ASIA/SHANGHAI",
            "ASIA/URUMQI",
            "ASIA/CHONGQING",
            "ASIA/HARBIN",
            "ASIA/KASHGAR",
            "ASIA/MACAU",
            "ASIA/HONG_KONG",
            "ASIA/MACAO",
            "ASIA/BEIJING",
            "ASIA/HARBIN",
          ],
          WC_COINBASE_PAY_SDK_CHAINS: [
            "ethereum",
            "arbitrum",
            "polygon",
            "berachain",
            "avalanche-c-chain",
            "optimism",
            "celo",
            "base",
          ],
          WC_COINBASE_PAY_SDK_FALLBACK_CHAIN: "ethereum",
          WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP: {
            Ethereum: "ethereum",
            "Arbitrum One": "arbitrum",
            Polygon: "polygon",
            Berachain: "berachain",
            Avalanche: "avalanche-c-chain",
            "OP Mainnet": "optimism",
            Celo: "celo",
            Base: "base",
          },
          WC_COINBASE_ONRAMP_APP_ID: "bf18c88d-495a-463b-b249-0b9d3656cf5e",
          SWAP_SUGGESTED_TOKENS: [
            "ETH",
            "UNI",
            "1INCH",
            "AAVE",
            "SOL",
            "ADA",
            "AVAX",
            "DOT",
            "LINK",
            "NITRO",
            "GAIA",
            "MILK",
            "TRX",
            "NEAR",
            "GNO",
            "WBTC",
            "DAI",
            "WETH",
            "USDC",
            "USDT",
            "ARB",
            "BAL",
            "BICO",
            "CRV",
            "ENS",
            "MATIC",
            "OP",
          ],
          SWAP_POPULAR_TOKENS: [
            "ETH",
            "UNI",
            "1INCH",
            "AAVE",
            "SOL",
            "ADA",
            "AVAX",
            "DOT",
            "LINK",
            "NITRO",
            "GAIA",
            "MILK",
            "TRX",
            "NEAR",
            "GNO",
            "WBTC",
            "DAI",
            "WETH",
            "USDC",
            "USDT",
            "ARB",
            "BAL",
            "BICO",
            "CRV",
            "ENS",
            "MATIC",
            "OP",
            "METAL",
            "DAI",
            "CHAMP",
            "WOLF",
            "SALE",
            "BAL",
            "BUSD",
            "MUST",
            "BTCpx",
            "ROUTE",
            "HEX",
            "WELT",
            "amDAI",
            "VSQ",
            "VISION",
            "AURUM",
            "pSP",
            "SNX",
            "VC",
            "LINK",
            "CHP",
            "amUSDT",
            "SPHERE",
            "FOX",
            "GIDDY",
            "GFC",
            "OMEN",
            "OX_OLD",
            "DE",
            "WNT",
          ],
          BALANCE_SUPPORTED_CHAINS: ["eip155", "solana"],
          SWAP_SUPPORTED_NETWORKS: [
            "eip155:1",
            "eip155:42161",
            "eip155:10",
            "eip155:324",
            "eip155:8453",
            "eip155:56",
            "eip155:137",
            "eip155:100",
            "eip155:43114",
            "eip155:250",
            "eip155:8217",
            "eip155:1313161554",
          ],
          NAMES_SUPPORTED_CHAIN_NAMESPACES: ["eip155"],
          ONRAMP_SUPPORTED_CHAIN_NAMESPACES: ["eip155", "solana"],
          ACTIVITY_ENABLED_CHAIN_NAMESPACES: ["eip155"],
          NATIVE_TOKEN_ADDRESS: {
            eip155: "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
            solana: "So11111111111111111111111111111111111111111",
            polkadot: "0x",
            bip122: "0x",
            cosmos: "0x",
          },
          CONVERT_SLIPPAGE_TOLERANCE: 1,
          CONNECT_LABELS: {
            MOBILE: "Open and continue in the wallet app",
            WEB: "Open and continue in the wallet app",
          },
          SEND_SUPPORTED_NAMESPACES: ["eip155", "solana"],
          DEFAULT_REMOTE_FEATURES: {
            swaps: ["1inch"],
            onramp: ["coinbase", "meld"],
            email: !0,
            socials: [
              "google",
              "x",
              "discord",
              "farcaster",
              "github",
              "apple",
              "facebook",
            ],
            activity: !0,
            reownBranding: !0,
          },
          DEFAULT_REMOTE_FEATURES_DISABLED: {
            email: !1,
            socials: !1,
            swaps: !1,
            onramp: !1,
            activity: !1,
            reownBranding: !1,
          },
          DEFAULT_FEATURES: {
            receive: !0,
            send: !0,
            emailShowWallets: !0,
            connectorTypeOrder: [
              "walletConnect",
              "recent",
              "injected",
              "featured",
              "custom",
              "external",
              "recommended",
            ],
            analytics: !0,
            allWallets: !0,
            legalCheckbox: !1,
            smartSessions: !1,
            collapseWallets: !1,
            walletFeaturesOrder: ["onramp", "swaps", "receive", "send"],
            connectMethodsOrder: void 0,
            pay: !1,
          },
          DEFAULT_SOCIALS: [
            "google",
            "x",
            "farcaster",
            "discord",
            "apple",
            "github",
            "facebook",
          ],
          DEFAULT_ACCOUNT_TYPES: {
            bip122: "payment",
            eip155: "smartAccount",
            polkadot: "eoa",
            solana: "eoa",
          },
          ADAPTER_TYPES: {
            UNIVERSAL: "universal",
            SOLANA: "solana",
            WAGMI: "wagmi",
            ETHERS: "ethers",
            ETHERS5: "ethers5",
            BITCOIN: "bitcoin",
          },
        };
    },
    76631: (e, t, r) => {
      "use strict";
      r.d(t, { f: () => g });
      var i = r(43708),
        s = r(70799);
      let n = {
        convertEVMChainIdToCoinType(e) {
          if (e >= 0x80000000) throw Error("Invalid chainId");
          return (0x80000000 | e) >>> 0;
        },
      };
      var a = r(5582),
        o = r(92555),
        c = r(11076),
        l = r(11501),
        u = r(90906),
        d = r(6193),
        h = r(54252),
        p = r(19628);
      let f = (0, i.BX)({ suggestions: [], loading: !1 }),
        g = (0, o.X)({
          state: f,
          subscribe: (e) => (0, i.B1)(f, () => e(f)),
          subscribeKey: (e, t) => (0, s.u$)(f, e, t),
          async resolveName(e) {
            try {
              return await l.T.lookupEnsName(e);
            } catch (e) {
              throw Error(
                e?.reasons?.[0]?.description || "Error resolving name"
              );
            }
          },
          async isNameRegistered(e) {
            try {
              return await l.T.lookupEnsName(e), !0;
            } catch {
              return !1;
            }
          },
          async getSuggestions(e) {
            try {
              return (
                (f.loading = !0),
                (f.suggestions = []),
                (f.suggestions =
                  (await l.T.getEnsNameSuggestions(e)).suggestions.map((e) => ({
                    ...e,
                    name: e.name,
                  })) || []),
                f.suggestions
              );
            } catch (e) {
              throw Error(
                g.parseEnsApiError(e, "Error fetching name suggestions")
              );
            } finally {
              f.loading = !1;
            }
          },
          async getNamesForAddress(e) {
            try {
              if (!u.W.state.activeCaipNetwork) return [];
              let t = a.i.getEnsFromCacheForAddress(e);
              if (t) return t;
              let r = await l.T.reverseLookupEnsName({ address: e });
              return (
                a.i.updateEnsCache({
                  address: e,
                  ens: r,
                  timestamp: Date.now(),
                }),
                r
              );
            } catch (e) {
              throw Error(
                g.parseEnsApiError(e, "Error fetching names for address")
              );
            }
          },
          async registerName(e) {
            let t = u.W.state.activeCaipNetwork;
            if (!t) throw Error("Network not found");
            let r = c.U.state.address,
              i = h.a.getAuthConnector();
            if (!r || !i) throw Error("Address or auth connector not found");
            f.loading = !0;
            try {
              let i = JSON.stringify({
                name: e,
                attributes: {},
                timestamp: Math.floor(Date.now() / 1e3),
              });
              p.I.pushTransactionStack({
                onCancel() {
                  p.I.replace("RegisterAccountName");
                },
              });
              let s = await d.x.signMessage(i);
              f.loading = !1;
              let a = t.id;
              if (!a) throw Error("Network not found");
              let o = n.convertEVMChainIdToCoinType(Number(a));
              await l.T.registerEnsName({
                coinType: o,
                address: r,
                signature: s,
                message: i,
              }),
                c.U.setProfileName(e, t.chainNamespace),
                p.I.replace("RegisterAccountNameSuccess");
            } catch (r) {
              let t = g.parseEnsApiError(r, `Error registering name ${e}`);
              throw (p.I.replace("RegisterAccountName"), Error(t));
            } finally {
              f.loading = !1;
            }
          },
          validateName: (e) => /^[a-zA-Z0-9-]{4,}$/u.test(e),
          parseEnsApiError: (e, t) => e?.reasons?.[0]?.description || t,
        });
    },
    77136: (e, t, r) => {
      "use strict";
      r.d(t, { eL: () => i, pj: () => n, sz: () => s });
      let i = { gwei: 9, wei: 18 },
        s = { ether: -9, wei: 9 },
        n = { ether: -18, gwei: -9 };
    },
    77508: (e, t, r) => {
      "use strict";
      r.d(t, {
        JW: () => I,
        XX: () => q,
        c0: () => S,
        ge: () => F,
        qy: () => A,
        s6: () => N,
      });
      let i = globalThis,
        s = i.trustedTypes,
        n = s ? s.createPolicy("lit-html", { createHTML: (e) => e }) : void 0,
        a = "$lit$",
        o = `lit$${Math.random().toFixed(9).slice(2)}$`,
        c = "?" + o,
        l = `<${c}>`,
        u = document,
        d = () => u.createComment(""),
        h = (e) =>
          null === e || ("object" != typeof e && "function" != typeof e),
        p = Array.isArray,
        f = (e) => p(e) || "function" == typeof e?.[Symbol.iterator],
        g = "[ 	\n\f\r]",
        m = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
        y = /-->/g,
        b = />/g,
        w = RegExp(
          `>|${g}(?:([^\\s"'>=/]+)(${g}*=${g}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`,
          "g"
        ),
        v = /'/g,
        E = /"/g,
        _ = /^(?:script|style|textarea|title)$/i,
        C =
          (e) =>
          (t, ...r) => ({ _$litType$: e, strings: t, values: r }),
        A = C(1),
        I = C(2),
        S = (C(3), Symbol.for("lit-noChange")),
        N = Symbol.for("lit-nothing"),
        T = new WeakMap(),
        O = u.createTreeWalker(u, 129);
      function x(e, t) {
        if (!p(e) || !e.hasOwnProperty("raw"))
          throw Error("invalid template strings array");
        return void 0 !== n ? n.createHTML(t) : t;
      }
      let P = (e, t) => {
        let r = e.length - 1,
          i = [],
          s,
          n = 2 === t ? "<svg>" : 3 === t ? "<math>" : "",
          c = m;
        for (let t = 0; t < r; t++) {
          let r = e[t],
            u,
            d,
            h = -1,
            p = 0;
          for (
            ;
            p < r.length && ((c.lastIndex = p), null !== (d = c.exec(r)));

          )
            (p = c.lastIndex),
              c === m
                ? "!--" === d[1]
                  ? (c = y)
                  : void 0 !== d[1]
                  ? (c = b)
                  : void 0 !== d[2]
                  ? (_.test(d[2]) && (s = RegExp("</" + d[2], "g")), (c = w))
                  : void 0 !== d[3] && (c = w)
                : c === w
                ? ">" === d[0]
                  ? ((c = s ?? m), (h = -1))
                  : void 0 === d[1]
                  ? (h = -2)
                  : ((h = c.lastIndex - d[2].length),
                    (u = d[1]),
                    (c = void 0 === d[3] ? w : '"' === d[3] ? E : v))
                : c === E || c === v
                ? (c = w)
                : c === y || c === b
                ? (c = m)
                : ((c = w), (s = void 0));
          let f = c === w && e[t + 1].startsWith("/>") ? " " : "";
          n +=
            c === m
              ? r + l
              : h >= 0
              ? (i.push(u), r.slice(0, h) + a + r.slice(h) + o + f)
              : r + o + (-2 === h ? t : f);
        }
        return [
          x(
            e,
            n +
              (e[r] || "<?>") +
              (2 === t ? "</svg>" : 3 === t ? "</math>" : "")
          ),
          i,
        ];
      };
      class R {
        constructor({ strings: e, _$litType$: t }, r) {
          let i;
          this.parts = [];
          let n = 0,
            l = 0,
            u = e.length - 1,
            h = this.parts,
            [p, f] = P(e, t);
          if (
            ((this.el = R.createElement(p, r)),
            (O.currentNode = this.el.content),
            2 === t || 3 === t)
          ) {
            let e = this.el.content.firstChild;
            e.replaceWith(...e.childNodes);
          }
          for (; null !== (i = O.nextNode()) && h.length < u; ) {
            if (1 === i.nodeType) {
              if (i.hasAttributes())
                for (let e of i.getAttributeNames())
                  if (e.endsWith(a)) {
                    let t = f[l++],
                      r = i.getAttribute(e).split(o),
                      s = /([.?@])?(.*)/.exec(t);
                    h.push({
                      type: 1,
                      index: n,
                      name: s[2],
                      strings: r,
                      ctor:
                        "." === s[1]
                          ? M
                          : "?" === s[1]
                          ? j
                          : "@" === s[1]
                          ? $
                          : L,
                    }),
                      i.removeAttribute(e);
                  } else
                    e.startsWith(o) &&
                      (h.push({ type: 6, index: n }), i.removeAttribute(e));
              if (_.test(i.tagName)) {
                let e = i.textContent.split(o),
                  t = e.length - 1;
                if (t > 0) {
                  i.textContent = s ? s.emptyScript : "";
                  for (let r = 0; r < t; r++)
                    i.append(e[r], d()),
                      O.nextNode(),
                      h.push({ type: 2, index: ++n });
                  i.append(e[t], d());
                }
              }
            } else if (8 === i.nodeType)
              if (i.data === c) h.push({ type: 2, index: n });
              else {
                let e = -1;
                for (; -1 !== (e = i.data.indexOf(o, e + 1)); )
                  h.push({ type: 7, index: n }), (e += o.length - 1);
              }
            n++;
          }
        }
        static createElement(e, t) {
          let r = u.createElement("template");
          return (r.innerHTML = e), r;
        }
      }
      function k(e, t, r = e, i) {
        if (t === S) return t;
        let s = void 0 !== i ? r._$Co?.[i] : r._$Cl,
          n = h(t) ? void 0 : t._$litDirective$;
        return (
          s?.constructor !== n &&
            (s?._$AO?.(!1),
            void 0 === n ? (s = void 0) : (s = new n(e))._$AT(e, r, i),
            void 0 !== i ? ((r._$Co ??= [])[i] = s) : (r._$Cl = s)),
          void 0 !== s && (t = k(e, s._$AS(e, t.values), s, i)),
          t
        );
      }
      class D {
        constructor(e, t) {
          (this._$AV = []),
            (this._$AN = void 0),
            (this._$AD = e),
            (this._$AM = t);
        }
        get parentNode() {
          return this._$AM.parentNode;
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        u(e) {
          let {
              el: { content: t },
              parts: r,
            } = this._$AD,
            i = (e?.creationScope ?? u).importNode(t, !0);
          O.currentNode = i;
          let s = O.nextNode(),
            n = 0,
            a = 0,
            o = r[0];
          for (; void 0 !== o; ) {
            if (n === o.index) {
              let t;
              2 === o.type
                ? (t = new U(s, s.nextSibling, this, e))
                : 1 === o.type
                ? (t = new o.ctor(s, o.name, o.strings, this, e))
                : 6 === o.type && (t = new B(s, this, e)),
                this._$AV.push(t),
                (o = r[++a]);
            }
            n !== o?.index && ((s = O.nextNode()), n++);
          }
          return (O.currentNode = u), i;
        }
        p(e) {
          let t = 0;
          for (let r of this._$AV)
            void 0 !== r &&
              (void 0 !== r.strings
                ? (r._$AI(e, r, t), (t += r.strings.length - 2))
                : r._$AI(e[t])),
              t++;
        }
      }
      class U {
        get _$AU() {
          return this._$AM?._$AU ?? this._$Cv;
        }
        constructor(e, t, r, i) {
          (this.type = 2),
            (this._$AH = N),
            (this._$AN = void 0),
            (this._$AA = e),
            (this._$AB = t),
            (this._$AM = r),
            (this.options = i),
            (this._$Cv = i?.isConnected ?? !0);
        }
        get parentNode() {
          let e = this._$AA.parentNode,
            t = this._$AM;
          return void 0 !== t && 11 === e?.nodeType && (e = t.parentNode), e;
        }
        get startNode() {
          return this._$AA;
        }
        get endNode() {
          return this._$AB;
        }
        _$AI(e, t = this) {
          h((e = k(this, e, t)))
            ? e === N || null == e || "" === e
              ? (this._$AH !== N && this._$AR(), (this._$AH = N))
              : e !== this._$AH && e !== S && this._(e)
            : void 0 !== e._$litType$
            ? this.$(e)
            : void 0 !== e.nodeType
            ? this.T(e)
            : f(e)
            ? this.k(e)
            : this._(e);
        }
        O(e) {
          return this._$AA.parentNode.insertBefore(e, this._$AB);
        }
        T(e) {
          this._$AH !== e && (this._$AR(), (this._$AH = this.O(e)));
        }
        _(e) {
          this._$AH !== N && h(this._$AH)
            ? (this._$AA.nextSibling.data = e)
            : this.T(u.createTextNode(e)),
            (this._$AH = e);
        }
        $(e) {
          let { values: t, _$litType$: r } = e,
            i =
              "number" == typeof r
                ? this._$AC(e)
                : (void 0 === r.el &&
                    (r.el = R.createElement(x(r.h, r.h[0]), this.options)),
                  r);
          if (this._$AH?._$AD === i) this._$AH.p(t);
          else {
            let e = new D(i, this),
              r = e.u(this.options);
            e.p(t), this.T(r), (this._$AH = e);
          }
        }
        _$AC(e) {
          let t = T.get(e.strings);
          return void 0 === t && T.set(e.strings, (t = new R(e))), t;
        }
        k(e) {
          p(this._$AH) || ((this._$AH = []), this._$AR());
          let t = this._$AH,
            r,
            i = 0;
          for (let s of e)
            i === t.length
              ? t.push(
                  (r = new U(this.O(d()), this.O(d()), this, this.options))
                )
              : (r = t[i]),
              r._$AI(s),
              i++;
          i < t.length &&
            (this._$AR(r && r._$AB.nextSibling, i), (t.length = i));
        }
        _$AR(e = this._$AA.nextSibling, t) {
          for (this._$AP?.(!1, !0, t); e && e !== this._$AB; ) {
            let t = e.nextSibling;
            e.remove(), (e = t);
          }
        }
        setConnected(e) {
          void 0 === this._$AM && ((this._$Cv = e), this._$AP?.(e));
        }
      }
      class L {
        get tagName() {
          return this.element.tagName;
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        constructor(e, t, r, i, s) {
          (this.type = 1),
            (this._$AH = N),
            (this._$AN = void 0),
            (this.element = e),
            (this.name = t),
            (this._$AM = i),
            (this.options = s),
            r.length > 2 || "" !== r[0] || "" !== r[1]
              ? ((this._$AH = Array(r.length - 1).fill(new String())),
                (this.strings = r))
              : (this._$AH = N);
        }
        _$AI(e, t = this, r, i) {
          let s = this.strings,
            n = !1;
          if (void 0 === s)
            (n = !h((e = k(this, e, t, 0))) || (e !== this._$AH && e !== S)) &&
              (this._$AH = e);
          else {
            let i,
              a,
              o = e;
            for (e = s[0], i = 0; i < s.length - 1; i++)
              (a = k(this, o[r + i], t, i)) === S && (a = this._$AH[i]),
                (n ||= !h(a) || a !== this._$AH[i]),
                a === N ? (e = N) : e !== N && (e += (a ?? "") + s[i + 1]),
                (this._$AH[i] = a);
          }
          n && !i && this.j(e);
        }
        j(e) {
          e === N
            ? this.element.removeAttribute(this.name)
            : this.element.setAttribute(this.name, e ?? "");
        }
      }
      class M extends L {
        constructor() {
          super(...arguments), (this.type = 3);
        }
        j(e) {
          this.element[this.name] = e === N ? void 0 : e;
        }
      }
      class j extends L {
        constructor() {
          super(...arguments), (this.type = 4);
        }
        j(e) {
          this.element.toggleAttribute(this.name, !!e && e !== N);
        }
      }
      class $ extends L {
        constructor(e, t, r, i, s) {
          super(e, t, r, i, s), (this.type = 5);
        }
        _$AI(e, t = this) {
          if ((e = k(this, e, t, 0) ?? N) === S) return;
          let r = this._$AH,
            i =
              (e === N && r !== N) ||
              e.capture !== r.capture ||
              e.once !== r.once ||
              e.passive !== r.passive,
            s = e !== N && (r === N || i);
          i && this.element.removeEventListener(this.name, this, r),
            s && this.element.addEventListener(this.name, this, e),
            (this._$AH = e);
        }
        handleEvent(e) {
          "function" == typeof this._$AH
            ? this._$AH.call(this.options?.host ?? this.element, e)
            : this._$AH.handleEvent(e);
        }
      }
      class B {
        constructor(e, t, r) {
          (this.element = e),
            (this.type = 6),
            (this._$AN = void 0),
            (this._$AM = t),
            (this.options = r);
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        _$AI(e) {
          k(this, e);
        }
      }
      let F = {
          M: a,
          P: o,
          A: c,
          C: 1,
          L: P,
          R: D,
          D: f,
          V: k,
          I: U,
          H: L,
          N: j,
          U: $,
          B: M,
          F: B,
        },
        W = i.litHtmlPolyfillSupport;
      W?.(R, U), (i.litHtmlVersions ??= []).push("3.3.0");
      let q = (e, t, r) => {
        let i = r?.renderBefore ?? t,
          s = i._$litPart$;
        if (void 0 === s) {
          let e = r?.renderBefore ?? null;
          i._$litPart$ = s = new U(t.insertBefore(d(), e), e, void 0, r ?? {});
        }
        return s._$AI(e), s;
      };
    },
    77752: (e, t, r) => {
      "use strict";
      r.d(t, {
        HF: () => l,
        aj: () => o,
        gC: () => a,
        nM: () => n,
        nk: () => s,
        xU: () => c,
      });
      var i = r(95782);
      class s extends i.C {
        constructor() {
          super("Chain not configured."),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "ChainNotConfiguredError",
            });
        }
      }
      class n extends i.C {
        constructor() {
          super("Connector already connected."),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "ConnectorAlreadyConnectedError",
            });
        }
      }
      class a extends i.C {
        constructor() {
          super("Connector not connected."),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "ConnectorNotConnectedError",
            });
        }
      }
      i.C;
      class o extends i.C {
        constructor({ address: e, connector: t }) {
          super(`Account "${e}" not found for connector "${t.name}".`),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "ConnectorAccountNotFoundError",
            });
        }
      }
      class c extends i.C {
        constructor({ connectionChainId: e, connectorChainId: t }) {
          super(
            `The current chain of the connector (id: ${t}) does not match the connection's chain (id: ${e}).`,
            {
              metaMessages: [
                `Current Chain ID:  ${t}`,
                `Expected Chain ID: ${e}`,
              ],
            }
          ),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "ConnectorChainMismatchError",
            });
        }
      }
      class l extends i.C {
        constructor({ connector: e }) {
          super(`Connector "${e.name}" unavailable while reconnecting.`, {
            details:
              "During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uid`. All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored. This error commonly occurs for connectors that asynchronously inject after reconnection has already started.",
          }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "ConnectorUnavailableReconnectingError",
            });
        }
      }
    },
    78519: (e, t, r) => {
      "use strict";
      function i(
        e,
        { errorInstance: t = Error("timed out"), timeout: r, signal: i }
      ) {
        return new Promise((s, n) => {
          (async () => {
            let a;
            try {
              let o = new AbortController();
              r > 0 &&
                (a = setTimeout(() => {
                  i ? o.abort() : n(t);
                }, r)),
                s(await e({ signal: o?.signal || null }));
            } catch (e) {
              e?.name === "AbortError" && n(t), n(e);
            } finally {
              clearTimeout(a);
            }
          })();
        });
      }
      r.d(t, { w: () => i });
    },
    79183: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => i });
      let i = (e, t, r) =>
        JSON.stringify(
          e,
          (e, r) => {
            let i = "bigint" == typeof r ? r.toString() : r;
            return "function" == typeof t ? t(e, i) : i;
          },
          r
        );
    },
    79277: (e, t, r) => {
      "use strict";
      r.d(t, { h: () => c });
      var i = r(43708),
        s = r(70799),
        n = r(92555),
        a = r(96641);
      let o = (0, i.BX)({ message: "", variant: "info", open: !1 }),
        c = (0, n.X)({
          state: o,
          subscribeKey: (e, t) => (0, s.u$)(o, e, t),
          open(e, t) {
            let { debug: r } = a.H.state,
              { shortMessage: i, longMessage: s } = e;
            r && ((o.message = i), (o.variant = t), (o.open = !0)),
              s && console.error("function" == typeof s ? s() : s);
          },
          close() {
            (o.open = !1), (o.message = ""), (o.variant = "info");
          },
        });
    },
    80844: (e, t, r) => {
      "use strict";
      r.d(t, { Af: () => p, ZJ: () => l, aT: () => h });
      var i = r(7441),
        s = r(32840),
        n = r(36984),
        a = r(27493),
        o = r(67622);
      let c = new TextEncoder();
      function l(e, t = {}) {
        var r, i;
        return "number" == typeof e || "bigint" == typeof e
          ? ((r = e), (i = t), h((0, o.cK)(r, i)))
          : "boolean" == typeof e
          ? (function (e, t = {}) {
              let r = new Uint8Array(1);
              return ((r[0] = Number(e)), "number" == typeof t.size)
                ? ((0, a.Sl)(r, { size: t.size }),
                  (0, n.eV)(r, { size: t.size }))
                : r;
            })(e, t)
          : (0, s.q)(e)
          ? h(e, t)
          : p(e, t);
      }
      let u = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
      function d(e) {
        return e >= u.zero && e <= u.nine
          ? e - u.zero
          : e >= u.A && e <= u.F
          ? e - (u.A - 10)
          : e >= u.a && e <= u.f
          ? e - (u.a - 10)
          : void 0;
      }
      function h(e, t = {}) {
        let r = e;
        t.size &&
          ((0, a.Sl)(r, { size: t.size }),
          (r = (0, n.eV)(r, { dir: "right", size: t.size })));
        let s = r.slice(2);
        s.length % 2 && (s = `0${s}`);
        let o = s.length / 2,
          c = new Uint8Array(o);
        for (let e = 0, t = 0; e < o; e++) {
          let r = d(s.charCodeAt(t++)),
            n = d(s.charCodeAt(t++));
          if (void 0 === r || void 0 === n)
            throw new i.C(
              `Invalid byte sequence ("${s[t - 2]}${s[t - 1]}" in "${s}").`
            );
          c[e] = 16 * r + n;
        }
        return c;
      }
      function p(e, t = {}) {
        let r = c.encode(e);
        return "number" == typeof t.size
          ? ((0, a.Sl)(r, { size: t.size }),
            (0, n.eV)(r, { dir: "right", size: t.size }))
          : r;
      }
    },
    80977: (e, t, r) => {
      "use strict";
      r.d(t, { L: () => c });
      var i = r(60500),
        s = r(11076),
        n = r(90906),
        a = r(54252),
        o = r(19628);
      let c = {
        onSwitchNetwork({ network: e, ignoreSwitchConfirmation: t = !1 }) {
          let r = n.W.state.activeCaipNetwork,
            c = o.I.state.data;
          if (e.id === r?.id) return;
          let l = s.U.getCaipAddress(n.W.state.activeChain),
            u = e.chainNamespace !== n.W.state.activeChain,
            d = s.U.getCaipAddress(e.chainNamespace),
            h =
              a.a.getConnectorId(n.W.state.activeChain) ===
              i.o.CONNECTOR_ID.AUTH,
            p = i.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.find(
              (t) => t === e.chainNamespace
            );
          t || (h && p)
            ? o.I.push("SwitchNetwork", { ...c, network: e })
            : l && u && !d
            ? o.I.push("SwitchActiveChain", {
                switchToChain: e.chainNamespace,
                navigateTo: "Connect",
                navigateWithReplace: !0,
                network: e,
              })
            : o.I.push("SwitchNetwork", { ...c, network: e });
        },
      };
    },
    81379: (e, t, r) => {
      "use strict";
      r.d(t, {
        CL: () => c,
        D5: () => u,
        Di: () => h,
        G1: () => x,
        Gi: () => l,
        L5: () => I,
        MI: () => R,
        RV: () => _,
        Sf: () => E,
        WT: () => S,
        XU: () => o,
        YW: () => g,
        ab: () => m,
        bq: () => d,
        cg: () => T,
        ch: () => A,
        hA: () => p,
        hl: () => N,
        jz: () => P,
        qZ: () => f,
        s0: () => y,
        sV: () => v,
        uL: () => O,
        vx: () => w,
        xQ: () => b,
        xq: () => C,
      });
      var i = r(7441),
        s = r(90557);
      class n extends i.C {
        constructor(
          e,
          { code: t, docsPath: r, metaMessages: i, name: n, shortMessage: a }
        ) {
          super(a, {
            cause: e,
            docsPath: r,
            metaMessages: i || e?.metaMessages,
            name: n || "RpcError",
          }),
            Object.defineProperty(this, "code", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.name = n || e.name),
            (this.code = e instanceof s.J8 ? e.code : t ?? -1);
        }
      }
      class a extends n {
        constructor(e, t) {
          super(e, t),
            Object.defineProperty(this, "data", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.data = t.data);
        }
      }
      class o extends n {
        constructor(e) {
          super(e, {
            code: o.code,
            name: "ParseRpcError",
            shortMessage:
              "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.",
          });
        }
      }
      Object.defineProperty(o, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32700,
      });
      class c extends n {
        constructor(e) {
          super(e, {
            code: c.code,
            name: "InvalidRequestRpcError",
            shortMessage: "JSON is not a valid request object.",
          });
        }
      }
      Object.defineProperty(c, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32600,
      });
      class l extends n {
        constructor(e, { method: t } = {}) {
          super(e, {
            code: l.code,
            name: "MethodNotFoundRpcError",
            shortMessage: `The method${
              t ? ` "${t}"` : ""
            } does not exist / is not available.`,
          });
        }
      }
      Object.defineProperty(l, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32601,
      });
      class u extends n {
        constructor(e) {
          super(e, {
            code: u.code,
            name: "InvalidParamsRpcError",
            shortMessage:
              "Invalid parameters were provided to the RPC method.\nDouble check you have provided the correct parameters.",
          });
        }
      }
      Object.defineProperty(u, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32602,
      });
      class d extends n {
        constructor(e) {
          super(e, {
            code: d.code,
            name: "InternalRpcError",
            shortMessage: "An internal error was received.",
          });
        }
      }
      Object.defineProperty(d, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32603,
      });
      class h extends n {
        constructor(e) {
          super(e, {
            code: h.code,
            name: "InvalidInputRpcError",
            shortMessage:
              "Missing or invalid parameters.\nDouble check you have provided the correct parameters.",
          });
        }
      }
      Object.defineProperty(h, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32e3,
      });
      class p extends n {
        constructor(e) {
          super(e, {
            code: p.code,
            name: "ResourceNotFoundRpcError",
            shortMessage: "Requested resource not found.",
          }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "ResourceNotFoundRpcError",
            });
        }
      }
      Object.defineProperty(p, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32001,
      });
      class f extends n {
        constructor(e) {
          super(e, {
            code: f.code,
            name: "ResourceUnavailableRpcError",
            shortMessage: "Requested resource not available.",
          });
        }
      }
      Object.defineProperty(f, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32002,
      });
      class g extends n {
        constructor(e) {
          super(e, {
            code: g.code,
            name: "TransactionRejectedRpcError",
            shortMessage: "Transaction creation failed.",
          });
        }
      }
      Object.defineProperty(g, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32003,
      });
      class m extends n {
        constructor(e, { method: t } = {}) {
          super(e, {
            code: m.code,
            name: "MethodNotSupportedRpcError",
            shortMessage: `Method${t ? ` "${t}"` : ""} is not supported.`,
          });
        }
      }
      Object.defineProperty(m, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32004,
      });
      class y extends n {
        constructor(e) {
          super(e, {
            code: y.code,
            name: "LimitExceededRpcError",
            shortMessage: "Request exceeds defined limit.",
          });
        }
      }
      Object.defineProperty(y, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32005,
      });
      class b extends n {
        constructor(e) {
          super(e, {
            code: b.code,
            name: "JsonRpcVersionUnsupportedError",
            shortMessage: "Version of JSON-RPC protocol is not supported.",
          });
        }
      }
      Object.defineProperty(b, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32006,
      });
      class w extends a {
        constructor(e) {
          super(e, {
            code: w.code,
            name: "UserRejectedRequestError",
            shortMessage: "User rejected the request.",
          });
        }
      }
      Object.defineProperty(w, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4001,
      });
      class v extends a {
        constructor(e) {
          super(e, {
            code: v.code,
            name: "UnauthorizedProviderError",
            shortMessage:
              "The requested method and/or account has not been authorized by the user.",
          });
        }
      }
      Object.defineProperty(v, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4100,
      });
      class E extends a {
        constructor(e, { method: t } = {}) {
          super(e, {
            code: E.code,
            name: "UnsupportedProviderMethodError",
            shortMessage: `The Provider does not support the requested method${
              t ? ` " ${t}"` : ""
            }.`,
          });
        }
      }
      Object.defineProperty(E, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4200,
      });
      class _ extends a {
        constructor(e) {
          super(e, {
            code: _.code,
            name: "ProviderDisconnectedError",
            shortMessage: "The Provider is disconnected from all chains.",
          });
        }
      }
      Object.defineProperty(_, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4900,
      });
      class C extends a {
        constructor(e) {
          super(e, {
            code: C.code,
            name: "ChainDisconnectedError",
            shortMessage:
              "The Provider is not connected to the requested chain.",
          });
        }
      }
      Object.defineProperty(C, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4901,
      });
      class A extends a {
        constructor(e) {
          super(e, {
            code: A.code,
            name: "SwitchChainError",
            shortMessage: "An error occurred when attempting to switch chain.",
          });
        }
      }
      Object.defineProperty(A, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4902,
      });
      class I extends a {
        constructor(e) {
          super(e, {
            code: I.code,
            name: "UnsupportedNonOptionalCapabilityError",
            shortMessage:
              "This Wallet does not support a capability that was not marked as optional.",
          });
        }
      }
      Object.defineProperty(I, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5700,
      });
      class S extends a {
        constructor(e) {
          super(e, {
            code: S.code,
            name: "UnsupportedChainIdError",
            shortMessage:
              "This Wallet does not support the requested chain ID.",
          });
        }
      }
      Object.defineProperty(S, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5710,
      });
      class N extends a {
        constructor(e) {
          super(e, {
            code: N.code,
            name: "DuplicateIdError",
            shortMessage: "There is already a bundle submitted with this ID.",
          });
        }
      }
      Object.defineProperty(N, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5720,
      });
      class T extends a {
        constructor(e) {
          super(e, {
            code: T.code,
            name: "UnknownBundleIdError",
            shortMessage: "This bundle id is unknown / has not been submitted",
          });
        }
      }
      Object.defineProperty(T, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5730,
      });
      class O extends a {
        constructor(e) {
          super(e, {
            code: O.code,
            name: "BundleTooLargeError",
            shortMessage:
              "The call bundle is too large for the Wallet to process.",
          });
        }
      }
      Object.defineProperty(O, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5740,
      });
      class x extends a {
        constructor(e) {
          super(e, {
            code: x.code,
            name: "AtomicReadyWalletRejectedUpgradeError",
            shortMessage:
              "The Wallet can support atomicity after an upgrade, but the user rejected the upgrade.",
          });
        }
      }
      Object.defineProperty(x, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5750,
      });
      class P extends a {
        constructor(e) {
          super(e, {
            code: P.code,
            name: "AtomicityNotSupportedError",
            shortMessage:
              "The wallet does not support atomic execution but the request requires it.",
          });
        }
      }
      Object.defineProperty(P, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5760,
      });
      class R extends n {
        constructor(e) {
          super(e, {
            name: "UnknownRpcError",
            shortMessage: "An unknown RPC error occurred.",
          });
        }
      }
    },
    81757: (e, t, r) => {
      "use strict";
      r.d(t, { P: () => o });
      var i = r(65003),
        s = r(35883);
      let n = /^0x[a-fA-F0-9]{40}$/,
        a = new i.A(8192);
      function o(e, t) {
        let { strict: r = !0 } = t ?? {},
          i = `${e}.${r}`;
        if (a.has(i)) return a.get(i);
        let o =
          !!n.test(e) && (e.toLowerCase() === e || !r || (0, s.o)(e) === e);
        return a.set(i, o), o;
      }
    },
    82922: (e, t, r) => {
      "use strict";
      r.d(t, { _: () => et });
      var i = r(60500),
        s = r(22492),
        n = r(54252),
        a = r(6193),
        o = r(32836),
        c = r(36665),
        l = r(65819),
        u = r(76610),
        d = r(11076),
        h = r(90906),
        p = r(96641),
        f = r(35558),
        g = r(7478),
        m = r(5582),
        y = r(79277),
        b = r(23140),
        w = r(99836),
        v = r(28307),
        E = r(29386),
        _ = r(519),
        C = r(45312),
        A = r(62862),
        I = r(50254),
        S = r(45714),
        N = r(26343),
        T = r(11501),
        O = r(76631),
        x = r(34735),
        P = r(43520),
        R = r(68319),
        k = r(45954),
        D = r(33806),
        U = r(5517),
        L = r(19628);
      function M(e, t) {
        return n.a.getConnectorId(e) === t;
      }
      r(95842), r(26128);
      var j = r(98782),
        $ = r(52515),
        B = r(31811),
        F = r(19655);
      let W = {
        createLogger(e, t = "error") {
          let r = (0, F.iP)({ level: t }),
            { logger: i } = (0, F.D5)({ opts: r });
          return (
            (i.error = (...t) => {
              for (let r of t) if (r instanceof Error) return void e(r, ...t);
              e(void 0, ...t);
            }),
            i
          );
        },
      };
      var q = r(42552),
        H = r(67622),
        z = r(99843),
        V = r(2568),
        K = r(28362);
      class G extends z.X {
        setUniversalProvider(e) {
          this.addConnector(
            new V.F({
              provider: e,
              caipNetworks: this.getCaipNetworks(),
              namespace: this.namespace,
            })
          );
        }
        async connect(e) {
          return Promise.resolve({
            id: "WALLET_CONNECT",
            type: "WALLET_CONNECT",
            chainId: Number(e.chainId),
            provider: this.provider,
            address: "",
          });
        }
        async disconnect() {
          try {
            let e = this.getWalletConnectConnector();
            await e.disconnect();
          } catch (e) {
            console.warn("UniversalAdapter:disconnect - error", e);
          }
        }
        async getAccounts({ namespace: e }) {
          let t = this.provider;
          return Promise.resolve({
            accounts: (
              t?.session?.namespaces?.[e]?.accounts
                ?.map((e) => {
                  let [, , t] = e.split(":");
                  return t;
                })
                .filter((e, t, r) => r.indexOf(e) === t) || []
            ).map((t) =>
              f.w.createAccount(e, t, "bip122" === e ? "payment" : "eoa")
            ),
          });
        }
        async syncConnectors() {
          return Promise.resolve();
        }
        async getBalance(e) {
          if (
            !(
              e.caipNetwork &&
              u.oU.BALANCE_SUPPORTED_CHAINS.includes(
                e.caipNetwork?.chainNamespace
              )
            ) ||
            e.caipNetwork?.testnet
          )
            return {
              balance: "0.00",
              symbol: e.caipNetwork?.nativeCurrency.symbol || "",
            };
          if (
            d.U.state.balanceLoading &&
            e.chainId === h.W.state.activeCaipNetwork?.id
          )
            return {
              balance: d.U.state.balance || "0.00",
              symbol: d.U.state.balanceSymbol || "",
            };
          let t = (await d.U.fetchTokenBalance()).find(
            (t) =>
              t.chainId === `${e.caipNetwork?.chainNamespace}:${e.chainId}` &&
              t.symbol === e.caipNetwork?.nativeCurrency.symbol
          );
          return {
            balance: t?.quantity.numeric || "0.00",
            symbol: t?.symbol || e.caipNetwork?.nativeCurrency.symbol || "",
          };
        }
        async signMessage(e) {
          let { provider: t, message: r, address: s } = e;
          if (!t)
            throw Error("UniversalAdapter:signMessage - provider is undefined");
          let n = "";
          return {
            signature:
              h.W.state.activeCaipNetwork?.chainNamespace === i.o.CHAIN.SOLANA
                ? (
                    await t.request(
                      {
                        method: "solana_signMessage",
                        params: {
                          message: q.A.encode(new TextEncoder().encode(r)),
                          pubkey: s,
                        },
                      },
                      h.W.state.activeCaipNetwork?.caipNetworkId
                    )
                  ).signature
                : await t.request(
                    { method: "personal_sign", params: [r, s] },
                    h.W.state.activeCaipNetwork?.caipNetworkId
                  ),
          };
        }
        async estimateGas() {
          return Promise.resolve({ gas: BigInt(0) });
        }
        async sendTransaction() {
          return Promise.resolve({ hash: "" });
        }
        walletGetAssets(e) {
          return Promise.resolve({});
        }
        async writeContract() {
          return Promise.resolve({ hash: "" });
        }
        parseUnits() {
          return 0n;
        }
        formatUnits() {
          return "0";
        }
        async getCapabilities() {
          return Promise.resolve({});
        }
        async grantPermissions() {
          return Promise.resolve({});
        }
        async revokePermissions() {
          return Promise.resolve("0x");
        }
        async syncConnection() {
          return Promise.resolve({
            id: "WALLET_CONNECT",
            type: "WALLET_CONNECT",
            chainId: 1,
            provider: this.provider,
            address: "",
          });
        }
        async switchNetwork(e) {
          let { caipNetwork: t } = e,
            r = this.getWalletConnectConnector();
          if (t.chainNamespace === i.o.CHAIN.EVM)
            try {
              await r.provider?.request({
                method: "wallet_switchEthereumChain",
                params: [{ chainId: (0, H.nj)(t.id) }],
              });
            } catch (e) {
              if (
                e.code === K.E.ERROR_CODE_UNRECOGNIZED_CHAIN_ID ||
                e.code === K.E.ERROR_INVALID_CHAIN_ID ||
                e.code === K.E.ERROR_CODE_DEFAULT ||
                e?.data?.originalError?.code ===
                  K.E.ERROR_CODE_UNRECOGNIZED_CHAIN_ID
              )
                try {
                  await r.provider?.request({
                    method: "wallet_addEthereumChain",
                    params: [
                      {
                        chainId: (0, H.nj)(t.id),
                        rpcUrls: [t?.rpcUrls.chainDefault?.http],
                        chainName: t.name,
                        nativeCurrency: t.nativeCurrency,
                        blockExplorerUrls: [t.blockExplorers?.default.url],
                      },
                    ],
                  });
                } catch (e) {
                  throw Error("Chain is not supported");
                }
            }
          r.provider.setDefaultChain(t.caipNetworkId);
        }
        getWalletConnectProvider() {
          let e = this.connectors.find((e) => "WALLET_CONNECT" === e.type);
          return e?.provider;
        }
      }
      let Y = [
          "email",
          "socials",
          "swaps",
          "onramp",
          "activity",
          "reownBranding",
        ],
        Z = {
          email: {
            apiFeatureName: "social_login",
            localFeatureName: "email",
            returnType: !1,
            isLegacy: !1,
            isAvailableOnBasic: !1,
            processApi: (e) => {
              if (!e?.config) return !1;
              let t = e.config;
              return !!e.isEnabled && t.includes("email");
            },
            processFallback: (e) =>
              void 0 === e ? u.oU.DEFAULT_REMOTE_FEATURES.email : !!e,
          },
          socials: {
            apiFeatureName: "social_login",
            localFeatureName: "socials",
            returnType: !1,
            isLegacy: !1,
            isAvailableOnBasic: !1,
            processApi: (e) => {
              if (!e?.config) return !1;
              let t = e.config;
              return (
                !!e.isEnabled && t.length > 0 && t.filter((e) => "email" !== e)
              );
            },
            processFallback: (e) =>
              void 0 === e
                ? u.oU.DEFAULT_REMOTE_FEATURES.socials
                : "boolean" == typeof e
                ? !!e && u.oU.DEFAULT_REMOTE_FEATURES.socials
                : e,
          },
          swaps: {
            apiFeatureName: "swap",
            localFeatureName: "swaps",
            returnType: !1,
            isLegacy: !1,
            isAvailableOnBasic: !1,
            processApi: (e) => {
              if (!e?.config) return !1;
              let t = e.config;
              return !!e.isEnabled && t.length > 0 && t;
            },
            processFallback: (e) =>
              void 0 === e
                ? u.oU.DEFAULT_REMOTE_FEATURES.swaps
                : "boolean" == typeof e
                ? !!e && u.oU.DEFAULT_REMOTE_FEATURES.swaps
                : e,
          },
          onramp: {
            apiFeatureName: "onramp",
            localFeatureName: "onramp",
            returnType: !1,
            isLegacy: !1,
            isAvailableOnBasic: !1,
            processApi: (e) => {
              if (!e?.config) return !1;
              let t = e.config;
              return !!e.isEnabled && t.length > 0 && t;
            },
            processFallback: (e) =>
              void 0 === e
                ? u.oU.DEFAULT_REMOTE_FEATURES.onramp
                : "boolean" == typeof e
                ? !!e && u.oU.DEFAULT_REMOTE_FEATURES.onramp
                : e,
          },
          activity: {
            apiFeatureName: "activity",
            localFeatureName: "history",
            returnType: !1,
            isLegacy: !0,
            isAvailableOnBasic: !1,
            processApi: (e) => !!e.isEnabled,
            processFallback: (e) =>
              void 0 === e ? u.oU.DEFAULT_REMOTE_FEATURES.activity : !!e,
          },
          reownBranding: {
            apiFeatureName: "reown_branding",
            localFeatureName: "reownBranding",
            returnType: !1,
            isLegacy: !1,
            isAvailableOnBasic: !1,
            processApi: (e) => !!e.isEnabled,
            processFallback: (e) =>
              void 0 === e ? u.oU.DEFAULT_REMOTE_FEATURES.reownBranding : !!e,
          },
        },
        J = {
          localSettingsOverridden: new Set(),
          getApiConfig: (e, t) => t?.find((t) => t.id === e),
          addWarning(e, t) {
            if (void 0 !== e) {
              let e = Z[t],
                r = e.isLegacy
                  ? `"features.${e.localFeatureName}" (now "${t}")`
                  : `"features.${t}"`;
              this.localSettingsOverridden.add(r);
            }
          },
          processFeature(e, t, r, i, s) {
            let n = Z[e],
              a = t[n.localFeatureName];
            if (s && !n.isAvailableOnBasic) return !1;
            if (i) {
              let t = this.getApiConfig(n.apiFeatureName, r);
              return t?.config === null
                ? this.processFallbackFeature(e, a)
                : !!t?.config &&
                    (void 0 !== a && this.addWarning(a, e),
                    this.processApiFeature(e, t));
            }
            return this.processFallbackFeature(e, a);
          },
          processApiFeature: (e, t) => Z[e].processApi(t),
          processFallbackFeature: (e, t) => Z[e].processFallback(t),
          async fetchRemoteFeatures(e) {
            let t = e.basic ?? !1,
              r = e.features || {};
            this.localSettingsOverridden.clear();
            let i = null,
              s = !1;
            try {
              s = null != (i = await l.N.fetchProjectConfig());
            } catch (e) {
              console.warn(
                "[Reown Config] Failed to fetch remote project configuration. Using local/default values.",
                e
              );
            }
            let n =
              s && !t
                ? u.oU.DEFAULT_REMOTE_FEATURES
                : u.oU.DEFAULT_REMOTE_FEATURES_DISABLED;
            try {
              for (let e of Y) {
                let a = this.processFeature(e, r, i, s, t);
                Object.assign(n, { [e]: a });
              }
            } catch (e) {
              return (
                console.warn(
                  "[Reown Config] Failed to process the configuration from Cloud. Using default values.",
                  e
                ),
                u.oU.DEFAULT_REMOTE_FEATURES
              );
            }
            if (s && this.localSettingsOverridden.size > 0) {
              let e = `Your local configuration for ${Array.from(
                this.localSettingsOverridden
              ).join(
                ", "
              )} was ignored because a remote configuration was successfully fetched. Please manage these features via your project dashboard on dashboard.reown.com.`;
              y.h.open(
                {
                  shortMessage: "Local configuration ignored",
                  longMessage: `[Reown Config Notice] ${e}`,
                },
                "warning"
              );
            }
            return n;
          },
        };
      var X = r(27882);
      class Q {
        constructor(e) {
          (this.chainNamespaces = []),
            (this.remoteFeatures = {}),
            (this.reportedAlertErrors = {}),
            (this.getCaipNetwork = (e, t) => {
              if (e) {
                let r = h.W.getNetworkData(e)?.requestedCaipNetworks?.find(
                  (e) => e.id === t
                );
                if (r) return r;
                let i = h.W.getNetworkData(e)?.caipNetwork;
                if (i) return i;
                let s = h.W.getRequestedCaipNetworks(e);
                return s.filter((t) => t.chainNamespace === e)?.[0];
              }
              return h.W.state.activeCaipNetwork || this.defaultCaipNetwork;
            }),
            (this.getCaipNetworkId = () => {
              let e = this.getCaipNetwork();
              if (e) return e.id;
            }),
            (this.getCaipNetworks = (e) => h.W.getCaipNetworks(e)),
            (this.getActiveChainNamespace = () => h.W.state.activeChain),
            (this.setRequestedCaipNetworks = (e, t) => {
              h.W.setRequestedCaipNetworks(e, t);
            }),
            (this.getApprovedCaipNetworkIds = () =>
              h.W.getAllApprovedCaipNetworkIds()),
            (this.getCaipAddress = (e) =>
              h.W.state.activeChain !== e && e
                ? h.W.getAccountProp("caipAddress", e)
                : h.W.state.activeCaipAddress),
            (this.setClientId = (e) => {
              T.T.setClientId(e);
            }),
            (this.getProvider = (e) => E.A.getProvider(e)),
            (this.getProviderType = (e) => E.A.getProviderId(e)),
            (this.getPreferredAccountType = (e) =>
              d.U.state.preferredAccountTypes?.[e]),
            (this.setCaipAddress = (e, t) => {
              d.U.setCaipAddress(e, t),
                e && p.H.state.enableEmbedded && this.close();
            }),
            (this.setBalance = (e, t, r) => {
              d.U.setBalance(e, t, r);
            }),
            (this.setProfileName = (e, t) => {
              d.U.setProfileName(e, t);
            }),
            (this.setProfileImage = (e, t) => {
              d.U.setProfileImage(e, t);
            }),
            (this.setUser = (e, t) => {
              d.U.setUser(e, t);
            }),
            (this.resetAccount = (e) => {
              d.U.resetAccount(e);
            }),
            (this.setCaipNetwork = (e) => {
              h.W.setActiveCaipNetwork(e);
            }),
            (this.setCaipNetworkOfNamespace = (e, t) => {
              h.W.setChainNetworkData(t, { caipNetwork: e });
            }),
            (this.setAllAccounts = (e, t) => {
              d.U.setAllAccounts(e, t),
                p.H.setHasMultipleAddresses(e?.length > 1);
            }),
            (this.setStatus = (e, t) => {
              d.U.setStatus(e, t),
                n.a.isConnected()
                  ? m.i.setConnectionStatus("connected")
                  : m.i.setConnectionStatus("disconnected");
            }),
            (this.getAddressByChainNamespace = (e) =>
              h.W.getAccountProp("address", e)),
            (this.setConnectors = (e) => {
              let t = [...n.a.state.allConnectors, ...e];
              n.a.setConnectors(t);
            }),
            (this.setConnections = (e, t) => {
              a.x.setConnections(e, t);
            }),
            (this.fetchIdentity = (e) => T.T.fetchIdentity(e)),
            (this.getReownName = (e) => O.f.getNamesForAddress(e)),
            (this.getConnectors = () => n.a.getConnectors()),
            (this.getConnectorImage = (e) => x.$.getConnectorImage(e)),
            (this.setConnectedWalletInfo = (e, t) => {
              let r = E.A.getProviderId(t),
                i = e ? { ...e, type: r } : void 0;
              d.U.setConnectedWalletInfo(i, t);
            }),
            (this.getIsConnectedState = () => !!h.W.state.activeCaipAddress),
            (this.addAddressLabel = (e, t, r) => {
              d.U.addAddressLabel(e, t, r);
            }),
            (this.removeAddressLabel = (e, t) => {
              d.U.removeAddressLabel(e, t);
            }),
            (this.getAddress = (e) =>
              h.W.state.activeChain !== e && e
                ? h.W.getAccountProp("address", e)
                : d.U.state.address),
            (this.setApprovedCaipNetworksData = (e) =>
              h.W.setApprovedCaipNetworksData(e)),
            (this.resetNetwork = (e) => {
              h.W.resetNetwork(e);
            }),
            (this.addConnector = (e) => {
              n.a.addConnector(e);
            }),
            (this.resetWcConnection = () => {
              a.x.resetWcConnection();
            }),
            (this.setAddressExplorerUrl = (e, t) => {
              d.U.setAddressExplorerUrl(e, t);
            }),
            (this.setSmartAccountDeployed = (e, t) => {
              d.U.setSmartAccountDeployed(e, t);
            }),
            (this.setSmartAccountEnabledNetworks = (e, t) => {
              h.W.setSmartAccountEnabledNetworks(e, t);
            }),
            (this.setPreferredAccountType = (e, t) => {
              d.U.setPreferredAccountType(e, t);
            }),
            (this.setEIP6963Enabled = (e) => {
              p.H.setEIP6963Enabled(e);
            }),
            (this.handleUnsafeRPCRequest = () => {
              this.isOpen()
                ? this.isTransactionStackEmpty() ||
                  this.redirect("ApproveTransaction")
                : this.open({ view: "ApproveTransaction" });
            }),
            (this.options = e),
            (this.version = e.sdkVersion),
            (this.caipNetworks = this.extendCaipNetworks(e)),
            (this.chainNamespaces = this.getChainNamespacesSet(
              e.adapters,
              this.caipNetworks
            )),
            (this.defaultCaipNetwork = this.extendDefaultCaipNetwork(e)),
            (this.chainAdapters = this.createAdapters(e.adapters)),
            (this.readyPromise = this.initialize(e));
        }
        getChainNamespacesSet(e, t) {
          let r = e?.map((e) => e.namespace).filter((e) => !!e);
          return r?.length
            ? [...new Set(r)]
            : [...new Set(t?.map((e) => e.chainNamespace))];
        }
        async initialize(e) {
          this.initializeProjectSettings(e),
            this.initControllers(e),
            await this.initChainAdapters(),
            this.sendInitializeEvent(e),
            await this.syncExistingConnection(),
            (this.remoteFeatures = await J.fetchRemoteFeatures(e)),
            p.H.setRemoteFeatures(this.remoteFeatures),
            this.remoteFeatures.onramp &&
              P.aG.setOnrampProviders(this.remoteFeatures.onramp),
            (p.H.state.remoteFeatures?.email ||
              (Array.isArray(p.H.state.remoteFeatures?.socials) &&
                p.H.state.remoteFeatures?.socials.length > 0)) &&
              (await this.checkAllowedOrigins());
        }
        async checkAllowedOrigins() {
          let e = await l.N.fetchAllowedOrigins();
          if (e && f.w.isClient()) {
            let t = window.location.origin;
            X.kl.isOriginAllowed(t, e, X.E1.DEFAULT_ALLOWED_ANCESTORS) ||
              y.h.open(v.R.ALERT_ERRORS.INVALID_APP_CONFIGURATION, "error");
          } else y.h.open(v.R.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
        }
        sendInitializeEvent(e) {
          let { ...t } = e;
          delete t.adapters,
            delete t.universalProvider,
            o.E.sendEvent({
              type: "track",
              event: "INITIALIZE",
              properties: {
                ...t,
                networks: e.networks.map((e) => e.id),
                siweConfig: { options: e.siweConfig?.options || {} },
              },
            });
        }
        initControllers(e) {
          this.initializeOptionsController(e),
            this.initializeChainController(e),
            this.initializeThemeController(e),
            this.initializeConnectionController(e),
            this.initializeConnectorController();
        }
        initializeThemeController(e) {
          e.themeMode && g.W.setThemeMode(e.themeMode),
            e.themeVariables && g.W.setThemeVariables(e.themeVariables);
        }
        initializeChainController(e) {
          if (!this.connectionControllerClient || !this.networkControllerClient)
            throw Error(
              "ConnectionControllerClient and NetworkControllerClient must be set"
            );
          h.W.initialize(e.adapters ?? [], this.caipNetworks, {
            connectionControllerClient: this.connectionControllerClient,
            networkControllerClient: this.networkControllerClient,
          });
          let t = this.getDefaultNetwork();
          t && h.W.setActiveCaipNetwork(t);
        }
        initializeConnectionController(e) {
          a.x.setWcBasic(e.basic ?? !1);
        }
        initializeConnectorController() {
          n.a.initialize(this.chainNamespaces);
        }
        initializeProjectSettings(e) {
          p.H.setProjectId(e.projectId), p.H.setSdkVersion(e.sdkVersion);
        }
        initializeOptionsController(e) {
          p.H.setDebug(!1 !== e.debug),
            p.H.setEnableWalletConnect(!1 !== e.enableWalletConnect),
            p.H.setEnableWalletGuide(!1 !== e.enableWalletGuide),
            p.H.setEnableWallets(!1 !== e.enableWallets),
            p.H.setEIP6963Enabled(!1 !== e.enableEIP6963),
            p.H.setEnableNetworkSwitch(!1 !== e.enableNetworkSwitch),
            p.H.setEnableAuthLogger(!1 !== e.enableAuthLogger),
            p.H.setCustomRpcUrls(e.customRpcUrls),
            p.H.setEnableEmbedded(e.enableEmbedded),
            p.H.setAllWallets(e.allWallets),
            p.H.setIncludeWalletIds(e.includeWalletIds),
            p.H.setExcludeWalletIds(e.excludeWalletIds),
            p.H.setFeaturedWalletIds(e.featuredWalletIds),
            p.H.setTokens(e.tokens),
            p.H.setTermsConditionsUrl(e.termsConditionsUrl),
            p.H.setPrivacyPolicyUrl(e.privacyPolicyUrl),
            p.H.setCustomWallets(e.customWallets),
            p.H.setFeatures(e.features),
            p.H.setAllowUnsupportedChain(e.allowUnsupportedChain),
            p.H.setUniversalProviderConfigOverride(
              e.universalProviderConfigOverride
            ),
            p.H.setPreferUniversalLinks(e.experimental_preferUniversalLinks),
            p.H.setDefaultAccountTypes(e.defaultAccountTypes);
          let t = m.i.getPreferredAccountTypes() || {},
            r = { ...p.H.state.defaultAccountTypes, ...t };
          d.U.setPreferredAccountTypes(r);
          let s = this.getDefaultMetaData();
          if (
            (!e.metadata && s && (e.metadata = s),
            p.H.setMetadata(e.metadata),
            p.H.setDisableAppend(e.disableAppend),
            p.H.setEnableEmbedded(e.enableEmbedded),
            p.H.setSIWX(e.siwx),
            !e.projectId)
          )
            return void y.h.open(
              v.R.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED,
              "error"
            );
          if (
            e.adapters?.find((e) => e.namespace === i.o.CHAIN.EVM) &&
            e.siweConfig
          ) {
            if (e.siwx)
              throw Error("Cannot set both `siweConfig` and `siwx` options");
            p.H.setSIWX(e.siweConfig.mapToSIWX());
          }
        }
        getDefaultMetaData() {
          return f.w.isClient()
            ? {
                name:
                  document.getElementsByTagName("title")?.[0]?.textContent ||
                  "",
                description:
                  document.querySelector('meta[property="og:description"]')
                    ?.content || "",
                url: window.location.origin,
                icons: [
                  document.querySelector('link[rel~="icon"]')?.href || "",
                ],
              }
            : null;
        }
        setUnsupportedNetwork(e) {
          let t = this.getActiveChainNamespace();
          if (t) {
            let r = B.R.getUnsupportedNetwork(`${t}:${e}`);
            h.W.setActiveCaipNetwork(r);
          }
        }
        getDefaultNetwork() {
          return B.R.getCaipNetworkFromStorage(this.defaultCaipNetwork);
        }
        extendCaipNetwork(e, t) {
          return B.R.extendCaipNetwork(e, {
            customNetworkImageUrls: t.chainImages,
            projectId: t.projectId,
          });
        }
        extendCaipNetworks(e) {
          return B.R.extendCaipNetworks(e.networks, {
            customNetworkImageUrls: e.chainImages,
            customRpcUrls: e.customRpcUrls,
            projectId: e.projectId,
          });
        }
        extendDefaultCaipNetwork(e) {
          let t = e.networks.find((t) => t.id === e.defaultNetwork?.id);
          return t
            ? B.R.extendCaipNetwork(t, {
                customNetworkImageUrls: e.chainImages,
                customRpcUrls: e.customRpcUrls,
                projectId: e.projectId,
              })
            : void 0;
        }
        async disconnectNamespace(e) {
          try {
            let t = this.getAdapter(e),
              r = E.A.getProvider(e),
              i = E.A.getProviderId(e),
              { caipAddress: s } = h.W.getAccountData(e) || {};
            this.setLoading(!0, e),
              s &&
                t?.disconnect &&
                (await t.disconnect({ provider: r, providerType: i })),
              m.i.removeConnectedNamespace(e),
              E.A.resetChain(e),
              this.setUser(void 0, e),
              this.setStatus("disconnected", e),
              this.setConnectedWalletInfo(void 0, e),
              n.a.removeConnectorId(e),
              h.W.resetAccount(e),
              h.W.resetNetwork(e),
              this.setLoading(!1, e);
          } catch (t) {
            throw (
              (this.setLoading(!1, e),
              Error(`Failed to disconnect chain ${e}: ${t.message}`))
            );
          }
        }
        createClients() {
          (this.connectionControllerClient = {
            connectWalletConnect: async () => {
              let e = h.W.state.activeChain,
                t = this.getAdapter(e),
                r = this.getCaipNetwork(e)?.id;
              if (!t) throw Error("Adapter not found");
              let i = await t.connectWalletConnect(r);
              this.close(),
                this.setClientId(i?.clientId || null),
                m.i.setConnectedNamespaces([...h.W.state.chains.keys()]),
                this.chainNamespaces.forEach((e) => {
                  n.a.setConnectorId(w.o.CONNECTOR_TYPE_WALLET_CONNECT, e);
                }),
                await this.syncWalletConnectAccount();
            },
            connectExternal: async ({
              id: e,
              info: t,
              type: r,
              provider: i,
              chain: s,
              caipNetwork: n,
              socialUri: a,
            }) => {
              let o = h.W.state.activeChain,
                c = s || o,
                l = this.getAdapter(c);
              if (s && s !== o && !n) {
                let e = this.getCaipNetworks().find(
                  (e) => e.chainNamespace === s
                );
                e && this.setCaipNetwork(e);
              }
              if (!l) throw Error("Adapter not found");
              let u = this.getCaipNetwork(c),
                p = await l.connect({
                  id: e,
                  info: t,
                  type: r,
                  provider: i,
                  socialUri: a,
                  chainId: n?.id || u?.id,
                  rpcUrl:
                    n?.rpcUrls?.default?.http?.[0] ||
                    u?.rpcUrls?.default?.http?.[0],
                });
              if (!p) return;
              m.i.addConnectedNamespace(c),
                this.syncProvider({ ...p, chainNamespace: c });
              let f = d.U.state.allAccounts,
                { accounts: g } =
                  f?.length > 0
                    ? { accounts: [...f] }
                    : await l.getAccounts({ namespace: c, id: e });
              this.setAllAccounts(g, c),
                this.setStatus("connected", c),
                this.syncConnectedWalletInfo(c);
            },
            reconnectExternal: async ({
              id: e,
              info: t,
              type: r,
              provider: i,
            }) => {
              let s = h.W.state.activeChain,
                n = this.getAdapter(s);
              n?.reconnect &&
                (await n?.reconnect({
                  id: e,
                  info: t,
                  type: r,
                  provider: i,
                  chainId: this.getCaipNetwork()?.id,
                }),
                m.i.addConnectedNamespace(s),
                this.syncConnectedWalletInfo(s));
            },
            disconnect: async (e) => {
              let t = (function (e) {
                let t = Array.from(h.W.state.chains.keys()),
                  r = [];
                return (
                  e
                    ? (r.push([e, h.W.state.chains.get(e)]),
                      M(e, i.o.CONNECTOR_ID.WALLET_CONNECT)
                        ? t.forEach((t) => {
                            t !== e &&
                              M(t, i.o.CONNECTOR_ID.WALLET_CONNECT) &&
                              r.push([t, h.W.state.chains.get(t)]);
                          })
                        : M(e, i.o.CONNECTOR_ID.AUTH) &&
                          t.forEach((t) => {
                            t !== e &&
                              M(t, i.o.CONNECTOR_ID.AUTH) &&
                              r.push([t, h.W.state.chains.get(t)]);
                          }))
                    : (r = Array.from(h.W.state.chains.entries())),
                  r
                );
              })(e);
              try {
                let r = await Promise.allSettled(
                  t.map(async ([e]) => this.disconnectNamespace(e))
                );
                R.R.resetSend(),
                  a.x.resetWcConnection(),
                  await k.U.clearSessions(),
                  n.a.setFilterByNamespace(void 0);
                let i = r.filter((e) => "rejected" === e.status);
                if (i.length > 0)
                  throw Error(i.map((e) => e.reason.message).join(", "));
                m.i.deleteConnectedSocialProvider(),
                  o.E.sendEvent({
                    type: "track",
                    event: "DISCONNECT_SUCCESS",
                    properties: { namespace: e || "all" },
                  });
              } catch (e) {
                throw Error(`Failed to disconnect chains: ${e.message}`);
              }
            },
            checkInstalled: (e) =>
              e
                ? e.some((e) => !!window.ethereum?.[String(e)])
                : !!window.ethereum,
            signMessage: async (e) => {
              let t = this.getAdapter(h.W.state.activeChain),
                r = await t?.signMessage({
                  message: e,
                  address: d.U.state.address,
                  provider: E.A.getProvider(h.W.state.activeChain),
                });
              return r?.signature || "";
            },
            sendTransaction: async (e) => {
              let t = e.chainNamespace;
              if (u.oU.SEND_SUPPORTED_NAMESPACES.includes(t)) {
                let r = this.getAdapter(h.W.state.activeChain),
                  i = E.A.getProvider(t),
                  s = await r?.sendTransaction({
                    ...e,
                    caipNetwork: this.getCaipNetwork(),
                    provider: i,
                  });
                return s?.hash || "";
              }
              return "";
            },
            estimateGas: async (e) => {
              if (e.chainNamespace === i.o.CHAIN.EVM) {
                let t = this.getAdapter(h.W.state.activeChain),
                  r = E.A.getProvider(h.W.state.activeChain),
                  i = this.getCaipNetwork();
                if (!i) throw Error("CaipNetwork is undefined");
                let s = await t?.estimateGas({
                  ...e,
                  provider: r,
                  caipNetwork: i,
                });
                return s?.gas || 0n;
              }
              return 0n;
            },
            getEnsAvatar: async () => (
              await this.syncIdentity({
                address: d.U.state.address,
                chainId: Number(this.getCaipNetwork()?.id),
                chainNamespace: h.W.state.activeChain,
              }),
              d.U.state.profileImage || !1
            ),
            getEnsAddress: async (e) => await X.kl.resolveReownName(e),
            writeContract: async (e) => {
              let t = this.getAdapter(h.W.state.activeChain),
                r = this.getCaipNetwork(),
                i = this.getCaipAddress(),
                s = E.A.getProvider(h.W.state.activeChain);
              if (!r || !i)
                throw Error("CaipNetwork or CaipAddress is undefined");
              let n = await t?.writeContract({
                ...e,
                caipNetwork: r,
                provider: s,
                caipAddress: i,
              });
              return n?.hash;
            },
            parseUnits: (e, t) => {
              let r = this.getAdapter(h.W.state.activeChain);
              return r?.parseUnits({ value: e, decimals: t }) ?? 0n;
            },
            formatUnits: (e, t) => {
              let r = this.getAdapter(h.W.state.activeChain);
              return r?.formatUnits({ value: e, decimals: t }) ?? "0";
            },
            getCapabilities: async (e) => {
              let t = this.getAdapter(h.W.state.activeChain);
              return await t?.getCapabilities(e);
            },
            grantPermissions: async (e) => {
              let t = this.getAdapter(h.W.state.activeChain);
              return await t?.grantPermissions(e);
            },
            revokePermissions: async (e) => {
              let t = this.getAdapter(h.W.state.activeChain);
              return t?.revokePermissions ? await t.revokePermissions(e) : "0x";
            },
            walletGetAssets: async (e) => {
              let t = this.getAdapter(h.W.state.activeChain);
              return (await t?.walletGetAssets(e)) ?? {};
            },
            updateBalance: (e) => {
              let t = this.getCaipNetwork(e);
              t &&
                d.U.state.address &&
                this.updateNativeBalance(d.U.state.address, t?.id, e);
            },
          }),
            (this.networkControllerClient = {
              switchCaipNetwork: async (e) => await this.switchCaipNetwork(e),
              getApprovedCaipNetworksData: async () =>
                this.getApprovedCaipNetworksData(),
            }),
            a.x.setClient(this.connectionControllerClient);
        }
        getApprovedCaipNetworksData() {
          if (
            E.A.getProviderId(h.W.state.activeChain) ===
            w.o.CONNECTOR_TYPE_WALLET_CONNECT
          ) {
            let e = this.universalProvider?.session?.namespaces;
            return {
              supportsAllNetworks:
                this.universalProvider?.session?.peer?.metadata.name ===
                "MetaMask Wallet",
              approvedCaipNetworkIds: this.getChainsFromNamespaces(e),
            };
          }
          return { supportsAllNetworks: !0, approvedCaipNetworkIds: [] };
        }
        async switchCaipNetwork(e) {
          if (!e) return;
          let t = e.chainNamespace;
          if (this.getAddressByChainNamespace(e.chainNamespace)) {
            let r = E.A.getProvider(t),
              i = E.A.getProviderId(t);
            if (e.chainNamespace === h.W.state.activeChain) {
              let s = this.getAdapter(t);
              await s?.switchNetwork({
                caipNetwork: e,
                provider: r,
                providerType: i,
              });
            } else if (
              (this.setCaipNetwork(e), i === w.o.CONNECTOR_TYPE_WALLET_CONNECT)
            )
              this.syncWalletConnectAccount();
            else {
              let r = this.getAddressByChainNamespace(t);
              r &&
                this.syncAccount({
                  address: r,
                  chainId: e.id,
                  chainNamespace: t,
                });
            }
          } else this.setCaipNetwork(e);
        }
        getChainsFromNamespaces(e = {}) {
          return Object.values(e).flatMap((e) =>
            Array.from(
              new Set([
                ...(e.chains || []),
                ...e.accounts.map((e) => {
                  let { chainId: t, chainNamespace: r } =
                    S.C.parseCaipAddress(e);
                  return `${r}:${t}`;
                }),
              ])
            )
          );
        }
        createAdapters(e) {
          return (
            this.createClients(),
            this.chainNamespaces.reduce((t, r) => {
              let i = e?.find((e) => e.namespace === r);
              return (
                i
                  ? (i.construct({
                      namespace: r,
                      projectId: this.options?.projectId,
                      networks: this.getCaipNetworks(),
                    }),
                    (t[r] = i))
                  : (t[r] = new G({
                      namespace: r,
                      networks: this.getCaipNetworks(),
                    })),
                t
              );
            }, {})
          );
        }
        async initChainAdapter(e) {
          this.onConnectors(e),
            this.listenAdapter(e),
            await this.chainAdapters?.[e].syncConnectors(this.options, this),
            await this.createUniversalProviderForAdapter(e);
        }
        async initChainAdapters() {
          await Promise.all(
            this.chainNamespaces.map(async (e) => {
              await this.initChainAdapter(e);
            })
          );
        }
        onConnectors(e) {
          let t = this.getAdapter(e);
          t?.on("connectors", this.setConnectors.bind(this));
        }
        listenAdapter(e) {
          let t = this.getAdapter(e);
          if (!t) return;
          let r = m.i.getConnectionStatus();
          "connected" === r
            ? this.setStatus("connecting", e)
            : ("disconnected" === r && m.i.clearAddressCache(),
              this.setStatus(r, e)),
            t.on("switchNetwork", ({ address: t, chainId: r }) => {
              let i = this.getCaipNetworks().find(
                  (e) => e.id === r || e.caipNetworkId === r
                ),
                s = h.W.state.activeChain === e,
                n = h.W.getAccountProp("address", e);
              if (i) {
                let r = s && t ? t : n;
                r &&
                  this.syncAccount({
                    address: r,
                    chainId: i.id,
                    chainNamespace: e,
                  });
              } else this.setUnsupportedNetwork(r);
            }),
            t.on("disconnect", this.disconnect.bind(this, e)),
            t.on("connections", (t) => {
              this.setConnections(t, e);
            }),
            t.on("pendingTransactions", () => {
              let e = d.U.state.address,
                t = h.W.state.activeCaipNetwork;
              e && t?.id && this.updateNativeBalance(e, t.id, t.chainNamespace);
            }),
            t.on("accountChanged", ({ address: t, chainId: r }) => {
              let i = h.W.state.activeChain === e;
              i && r
                ? this.syncAccount({
                    address: t,
                    chainId: r,
                    chainNamespace: e,
                  })
                : i && h.W.state.activeCaipNetwork?.id
                ? this.syncAccount({
                    address: t,
                    chainId: h.W.state.activeCaipNetwork?.id,
                    chainNamespace: e,
                  })
                : this.syncAccountInfo(t, r, e),
                this.syncAllAccounts(e);
            });
        }
        async createUniversalProviderForAdapter(e) {
          await this.getUniversalProvider(),
            this.universalProvider &&
              this.chainAdapters?.[e]?.setUniversalProvider?.(
                this.universalProvider
              );
        }
        async syncExistingConnection() {
          await Promise.allSettled(
            this.chainNamespaces.map((e) => this.syncNamespaceConnection(e))
          );
        }
        async syncNamespaceConnection(e) {
          try {
            e === i.o.CHAIN.EVM &&
              f.w.isSafeApp() &&
              n.a.setConnectorId(i.o.CONNECTOR_ID.SAFE, e);
            let t = n.a.getConnectorId(e);
            switch ((this.setStatus("connecting", e), t)) {
              case i.o.CONNECTOR_ID.WALLET_CONNECT:
                await this.syncWalletConnectAccount();
                break;
              case i.o.CONNECTOR_ID.AUTH:
                break;
              default:
                await this.syncAdapterConnection(e);
            }
          } catch (t) {
            console.warn("AppKit couldn't sync existing connection", t),
              this.setStatus("disconnected", e);
          }
        }
        async syncAdapterConnection(e) {
          let t = this.getAdapter(e),
            r = n.a.getConnectorId(e),
            i = this.getCaipNetwork(e),
            s = n.a.getConnectors(e).find((e) => e.id === r);
          try {
            if (!t || !s)
              throw Error(`Adapter or connector not found for namespace ${e}`);
            if (!i?.id) throw Error("CaipNetwork not found");
            let r = await t?.syncConnection({
              namespace: e,
              id: s.id,
              chainId: i.id,
              rpcUrl: i?.rpcUrls?.default?.http?.[0],
            });
            if (r) {
              let i = await t?.getAccounts({ namespace: e, id: s.id });
              i && i.accounts.length > 0
                ? this.setAllAccounts(i.accounts, e)
                : this.setAllAccounts(
                    [f.w.createAccount(e, r.address, "eoa")],
                    e
                  ),
                this.syncProvider({ ...r, chainNamespace: e }),
                await this.syncAccount({ ...r, chainNamespace: e }),
                this.setStatus("connected", e);
            } else this.setStatus("disconnected", e);
          } catch (t) {
            this.setStatus("disconnected", e);
          }
        }
        async syncWalletConnectAccount() {
          let e = this.chainNamespaces.map(async (e) => {
            let t = this.getAdapter(e),
              r =
                this.universalProvider?.session?.namespaces?.[e]?.accounts ||
                [],
              s = h.W.state.activeCaipNetwork?.id,
              a =
                r.find((e) => {
                  let { chainId: t } = S.C.parseCaipAddress(e);
                  return t === s?.toString();
                }) || r[0];
            if (a) {
              let r = S.C.validateCaipAddress(a),
                { chainId: s, address: o } = S.C.parseCaipAddress(r);
              if (
                (E.A.setProviderId(e, w.o.CONNECTOR_TYPE_WALLET_CONNECT),
                this.caipNetworks &&
                  h.W.state.activeCaipNetwork &&
                  t?.namespace !== i.o.CHAIN.EVM)
              ) {
                let r = t?.getWalletConnectProvider({
                  caipNetworks: this.getCaipNetworks(),
                  provider: this.universalProvider,
                  activeCaipNetwork: h.W.state.activeCaipNetwork,
                });
                E.A.setProvider(e, r);
              } else E.A.setProvider(e, this.universalProvider);
              n.a.setConnectorId(i.o.CONNECTOR_ID.WALLET_CONNECT, e),
                m.i.addConnectedNamespace(e),
                this.syncWalletConnectAccounts(e),
                await this.syncAccount({
                  address: o,
                  chainId: s,
                  chainNamespace: e,
                });
            } else this.setStatus("disconnected", e);
            this.syncConnectedWalletInfo(e),
              await h.W.setApprovedCaipNetworksData(e);
          });
          await Promise.all(e);
        }
        syncWalletConnectAccounts(e) {
          let t = this.universalProvider?.session?.namespaces?.[e]?.accounts
            ?.map((e) => {
              let { address: t } = S.C.parseCaipAddress(e);
              return t;
            })
            .filter((e, t, r) => r.indexOf(e) === t);
          t &&
            this.setAllAccounts(
              t.map((t) =>
                f.w.createAccount(e, t, "bip122" === e ? "payment" : "eoa")
              ),
              e
            );
        }
        syncProvider({ type: e, provider: t, id: r, chainNamespace: i }) {
          E.A.setProviderId(i, e),
            E.A.setProvider(i, t),
            n.a.setConnectorId(r, i);
        }
        async syncAllAccounts(e) {
          let t = n.a.getConnectorId(e);
          if (!t) return;
          let r = this.getAdapter(e),
            i = await r?.getAccounts({ namespace: e, id: t });
          i && i.accounts.length > 0 && this.setAllAccounts(i.accounts, e);
        }
        async syncAccount(e) {
          let t = e.chainNamespace === h.W.state.activeChain,
            r = h.W.getCaipNetworkByNamespace(e.chainNamespace, e.chainId),
            { address: s, chainId: n, chainNamespace: a } = e,
            { chainId: o } = m.i.getActiveNetworkProps(),
            c = n || o,
            l =
              h.W.state.activeCaipNetwork?.name ===
              i.o.UNSUPPORTED_NETWORK_NAME,
            u = h.W.getNetworkProp("supportsAllNetworks", a);
          if ((this.setStatus("connected", a), (!l || u) && c)) {
            let e = this.getCaipNetworks().find(
                (e) => e.id.toString() === c.toString()
              ),
              n = this.getCaipNetworks().find((e) => e.chainNamespace === a);
            if (!u && !e && !n) {
              let t = this.getApprovedCaipNetworkIds() || [],
                r = t.find(
                  (e) => S.C.parseCaipNetworkId(e)?.chainId === c.toString()
                ),
                i = t.find(
                  (e) => S.C.parseCaipNetworkId(e)?.chainNamespace === a
                );
              (e = this.getCaipNetworks().find((e) => e.caipNetworkId === r)),
                (n = this.getCaipNetworks().find(
                  (e) =>
                    e.caipNetworkId === i ||
                    ("deprecatedCaipNetworkId" in e &&
                      e.deprecatedCaipNetworkId === i)
                ));
            }
            let o = e || n;
            o?.chainNamespace === h.W.state.activeChain
              ? p.H.state.enableNetworkSwitch &&
                !p.H.state.allowUnsupportedChain &&
                h.W.state.activeCaipNetwork?.name ===
                  i.o.UNSUPPORTED_NETWORK_NAME
                ? h.W.showUnsupportedChainUI()
                : this.setCaipNetwork(o)
              : !t && r && this.setCaipNetworkOfNamespace(r, a),
              this.syncConnectedWalletInfo(a),
              b.y.isLowerCaseMatch(s, d.U.state.address) ||
                this.syncAccountInfo(s, o?.id, a),
              t
                ? await this.syncBalance({
                    address: s,
                    chainId: o?.id,
                    chainNamespace: a,
                  })
                : await this.syncBalance({
                    address: s,
                    chainId: r?.id,
                    chainNamespace: a,
                  });
          }
        }
        async syncAccountInfo(e, t, r) {
          let i = this.getCaipAddress(r),
            s = t || i?.split(":")[1];
          if (!s) return;
          let n = `${r}:${s}:${e}`;
          this.setCaipAddress(n, r),
            await this.syncIdentity({
              address: e,
              chainId: s,
              chainNamespace: r,
            });
        }
        async syncReownName(e, t) {
          try {
            let r = await this.getReownName(e);
            if (r[0]) {
              let e = r[0];
              this.setProfileName(e.name, t);
            } else this.setProfileName(null, t);
          } catch {
            this.setProfileName(null, t);
          }
        }
        syncConnectedWalletInfo(e) {
          let t = n.a.getConnectorId(e),
            r = E.A.getProviderId(e);
          if (
            r === w.o.CONNECTOR_TYPE_ANNOUNCED ||
            r === w.o.CONNECTOR_TYPE_INJECTED
          ) {
            if (t) {
              let r = this.getConnectors().find((e) => e.id === t);
              if (r) {
                let { info: t, name: i, imageUrl: s } = r,
                  n = s || this.getConnectorImage(r);
                this.setConnectedWalletInfo({ name: i, icon: n, ...t }, e);
              }
            }
          } else if (r === w.o.CONNECTOR_TYPE_WALLET_CONNECT) {
            let t = E.A.getProvider(e);
            t?.session &&
              this.setConnectedWalletInfo(
                {
                  ...t.session.peer.metadata,
                  name: t.session.peer.metadata.name,
                  icon: t.session.peer.metadata.icons?.[0],
                },
                e
              );
          } else if (t && t === i.o.CONNECTOR_ID.COINBASE) {
            let t = this.getConnectors().find(
              (e) => e.id === i.o.CONNECTOR_ID.COINBASE
            );
            this.setConnectedWalletInfo(
              { name: "Coinbase Wallet", icon: this.getConnectorImage(t) },
              e
            );
          }
        }
        async syncBalance(e) {
          N.L.getNetworksByNamespace(
            this.getCaipNetworks(),
            e.chainNamespace
          ).find((t) => t.id.toString() === e.chainId?.toString()) &&
            e.chainId &&
            (await this.updateNativeBalance(
              e.address,
              e.chainId,
              e.chainNamespace
            ));
        }
        async ready() {
          await this.readyPromise;
        }
        async updateNativeBalance(e, t, r) {
          let i = this.getAdapter(r),
            s = h.W.getCaipNetworkByNamespace(r, t);
          if (i) {
            let n = await i.getBalance({
              address: e,
              chainId: t,
              caipNetwork: s,
              tokens: this.options.tokens,
            });
            return this.setBalance(n.balance, n.symbol, r), n;
          }
        }
        async initializeUniversalAdapter() {
          let e = W.createLogger((e, ...t) => {
              e && this.handleAlertError(e), console.error(...t);
            }),
            t = {
              projectId: this.options?.projectId,
              metadata: {
                name: this.options?.metadata ? this.options?.metadata.name : "",
                description: this.options?.metadata
                  ? this.options?.metadata.description
                  : "",
                url: this.options?.metadata ? this.options?.metadata.url : "",
                icons: this.options?.metadata
                  ? this.options?.metadata.icons
                  : [""],
              },
              logger: e,
            };
          p.H.setManualWCControl(!!this.options?.manualWCControl),
            (this.universalProvider =
              this.options.universalProvider ?? (await I.A.init(t))),
            this.listenWalletConnect();
        }
        listenWalletConnect() {
          this.universalProvider &&
            (this.universalProvider.on("display_uri", (e) => {
              a.x.setUri(e);
            }),
            this.universalProvider.on("connect", a.x.finalizeWcConnection),
            this.universalProvider.on("disconnect", () => {
              this.chainNamespaces.forEach((e) => {
                this.resetAccount(e);
              }),
                a.x.resetWcConnection();
            }),
            this.universalProvider.on("chainChanged", (e) => {
              let t = this.getCaipNetworks().find((t) => t.id == e),
                r = this.getCaipNetwork();
              if (!t) return void this.setUnsupportedNetwork(e);
              r?.id !== t?.id && this.setCaipNetwork(t);
            }),
            this.universalProvider.on("session_event", (e) => {
              if (X.kl.isSessionEventData(e)) {
                let { name: t, data: r } = e.params.event;
                "accountsChanged" === t &&
                  Array.isArray(r) &&
                  f.w.isCaipAddress(r[0]) &&
                  this.syncAccount(S.C.parseCaipAddress(r[0]));
              }
            }));
        }
        createUniversalProvider() {
          return (
            !this.universalProviderInitPromise &&
              f.w.isClient() &&
              this.options?.projectId &&
              (this.universalProviderInitPromise =
                this.initializeUniversalAdapter()),
            this.universalProviderInitPromise
          );
        }
        async getUniversalProvider() {
          if (!this.universalProvider)
            try {
              await this.createUniversalProvider();
            } catch (e) {
              o.E.sendEvent({
                type: "error",
                event: "INTERNAL_SDK_ERROR",
                properties: {
                  errorType: "UniversalProviderInitError",
                  errorMessage: e instanceof Error ? e.message : "Unknown",
                  uncaught: !1,
                },
              }),
                console.error(
                  "AppKit:getUniversalProvider - Cannot create provider",
                  e
                );
            }
          return this.universalProvider;
        }
        handleAlertError(e) {
          let [t, r] =
              Object.entries(v.R.UniversalProviderErrors).find(
                ([, { message: t }]) => e.message.includes(t)
              ) ?? [],
            { message: i, alertErrorKey: s } = r ?? {};
          if (t && i && !this.reportedAlertErrors[t]) {
            let e = v.R.ALERT_ERRORS[s];
            e && (y.h.open(e, "error"), (this.reportedAlertErrors[t] = !0));
          }
        }
        getAdapter(e) {
          if (e) return this.chainAdapters?.[e];
        }
        createAdapter(e) {
          if (!e) return;
          let t = e.namespace;
          t &&
            (this.createClients(),
            (e.namespace = t),
            e.construct({
              namespace: t,
              projectId: this.options?.projectId,
              networks: this.getCaipNetworks(),
            }),
            this.chainNamespaces.includes(t) || this.chainNamespaces.push(t),
            this.chainAdapters && (this.chainAdapters[t] = e));
        }
        async open(e) {
          return (await this.injectModalUi(),
          e?.uri && a.x.setUri(e.uri),
          e?.arguments && e?.view === "Swap")
            ? D.W.open({ ...e, data: { swap: e.arguments } })
            : D.W.open(e);
        }
        async close() {
          await this.injectModalUi(), D.W.close();
        }
        setLoading(e, t) {
          D.W.setLoading(e, t);
        }
        async disconnect(e) {
          await a.x.disconnect(e);
        }
        getSIWX() {
          return p.H.state.siwx;
        }
        getError() {
          return "";
        }
        getChainId() {
          return h.W.state.activeCaipNetwork?.id;
        }
        async switchNetwork(e) {
          let t = this.getCaipNetworks().find((t) => t.id === e.id);
          if (!t)
            return void y.h.open(
              v.R.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND,
              "error"
            );
          await h.W.switchActiveNetwork(t);
        }
        getWalletProvider() {
          return h.W.state.activeChain
            ? E.A.state.providers[h.W.state.activeChain]
            : null;
        }
        getWalletProviderType() {
          return E.A.getProviderId(h.W.state.activeChain);
        }
        subscribeProviders(e) {
          return E.A.subscribeProviders(e);
        }
        getThemeMode() {
          return g.W.state.themeMode;
        }
        getThemeVariables() {
          return g.W.state.themeVariables;
        }
        setThemeMode(e) {
          g.W.setThemeMode(e), (0, $.JX)(g.W.state.themeMode);
        }
        setTermsConditionsUrl(e) {
          p.H.setTermsConditionsUrl(e);
        }
        setPrivacyPolicyUrl(e) {
          p.H.setPrivacyPolicyUrl(e);
        }
        setThemeVariables(e) {
          g.W.setThemeVariables(e), (0, $.ds)(g.W.state.themeVariables);
        }
        subscribeTheme(e) {
          return g.W.subscribe(e);
        }
        getWalletInfo() {
          return d.U.state.connectedWalletInfo;
        }
        getAccount(e) {
          let t = n.a.getAuthConnector(e),
            r = h.W.getAccountData(e),
            s = h.W.state.activeChain,
            a = m.i.getConnectedConnectorId(e || s);
          if (r)
            return {
              allAccounts: r.allAccounts,
              caipAddress: r.caipAddress,
              address: f.w.getPlainAddress(r.caipAddress),
              isConnected: !!r.caipAddress,
              status: r.status,
              embeddedWalletInfo:
                t && a === i.o.CONNECTOR_ID.AUTH
                  ? {
                      user: r.user
                        ? {
                            ...r.user,
                            username: m.i.getConnectedSocialUsername(),
                          }
                        : void 0,
                      authProvider: r.socialProvider || "email",
                      accountType: r.preferredAccountTypes?.[e || s],
                      isSmartAccountDeployed: !!r.smartAccountDeployed,
                    }
                  : void 0,
            };
        }
        subscribeAccount(e, t) {
          let r = () => {
            let r = this.getAccount(t);
            r && e(r);
          };
          t ? h.W.subscribeChainProp("accountState", r, t) : h.W.subscribe(r),
            n.a.subscribe(r);
        }
        subscribeNetwork(e) {
          return h.W.subscribe(({ activeCaipNetwork: t }) => {
            e({
              caipNetwork: t,
              chainId: t?.id,
              caipNetworkId: t?.caipNetworkId,
            });
          });
        }
        subscribeWalletInfo(e) {
          return d.U.subscribeKey("connectedWalletInfo", e);
        }
        subscribeShouldUpdateToAddress(e) {
          d.U.subscribeKey("shouldUpdateToAddress", e);
        }
        subscribeCaipNetworkChange(e) {
          h.W.subscribeKey("activeCaipNetwork", e);
        }
        getState() {
          return c.z.state;
        }
        subscribeState(e) {
          return c.z.subscribe(e);
        }
        showErrorMessage(e) {
          U.P.showError(e);
        }
        showSuccessMessage(e) {
          U.P.showSuccess(e);
        }
        getEvent() {
          return { ...o.E.state };
        }
        subscribeEvents(e) {
          return o.E.subscribe(e);
        }
        replace(e) {
          L.I.replace(e);
        }
        redirect(e) {
          L.I.push(e);
        }
        popTransactionStack(e) {
          L.I.popTransactionStack(e);
        }
        isOpen() {
          return D.W.state.open;
        }
        isTransactionStackEmpty() {
          return 0 === L.I.state.transactionStack.length;
        }
        static getInstance() {
          return this.instance;
        }
        updateFeatures(e) {
          p.H.setFeatures(e);
        }
        updateRemoteFeatures(e) {
          p.H.setRemoteFeatures(e);
        }
        updateOptions(e) {
          let t = { ...(p.H.state || {}), ...e };
          p.H.setOptions(t);
        }
        setConnectMethodsOrder(e) {
          p.H.setConnectMethodsOrder(e);
        }
        setWalletFeaturesOrder(e) {
          p.H.setWalletFeaturesOrder(e);
        }
        setCollapseWallets(e) {
          p.H.setCollapseWallets(e);
        }
        setSocialsOrder(e) {
          p.H.setSocialsOrder(e);
        }
        getConnectMethodsOrder() {
          return j.A.getConnectOrderMethod(
            p.H.state.features,
            n.a.getConnectors()
          );
        }
        addNetwork(e, t) {
          if (this.chainAdapters && !this.chainAdapters[e])
            throw Error(`Adapter for namespace ${e} doesn't exist`);
          let r = this.extendCaipNetwork(t, this.options);
          this.getCaipNetworks().find((e) => e.id === r.id) ||
            h.W.addNetwork(r);
        }
        removeNetwork(e, t) {
          if (this.chainAdapters && !this.chainAdapters[e])
            throw Error(`Adapter for namespace ${e} doesn't exist`);
          this.getCaipNetworks().find((e) => e.id === t) &&
            h.W.removeNetwork(e, t);
        }
      }
      let ee = !1;
      class et extends Q {
        setupAuthConnectorListeners(e) {
          e.onRpcRequest((t) => {
            _.Q.checkIfRequestExists(t)
              ? _.Q.checkIfRequestIsSafe(t) || this.handleUnsafeRPCRequest()
              : (this.open(),
                console.error(C.Vl.RPC_METHOD_NOT_ALLOWED_MESSAGE, {
                  method: t.method,
                }),
                setTimeout(() => {
                  this.showErrorMessage(C.Vl.RPC_METHOD_NOT_ALLOWED_UI_MESSAGE);
                }, 300),
                e.rejectRpcRequests());
          }),
            e.onRpcError(() => {
              this.isOpen() &&
                (this.isTransactionStackEmpty()
                  ? this.close()
                  : this.popTransactionStack("error"));
            }),
            e.onRpcSuccess((e, t) => {
              let r = _.Q.checkIfRequestIsSafe(t),
                i = d.U.state.address,
                s = h.W.state.activeCaipNetwork;
              r ||
                (i &&
                  s?.id &&
                  this.updateNativeBalance(i, s.id, s.chainNamespace),
                this.isTransactionStackEmpty()
                  ? this.close()
                  : this.popTransactionStack("success"));
            }),
            e.onNotConnected(() => {
              let e = h.W.state.activeChain;
              n.a.getConnectorId(e) === i.o.CONNECTOR_ID.AUTH &&
                (this.setCaipAddress(void 0, e), this.setLoading(!1, e));
            }),
            e.onConnect((e) => {
              let t = h.W.state.activeChain,
                r =
                  t === i.o.CHAIN.EVM
                    ? `eip155:${e.chainId}:${e.address}`
                    : `${e.chainId}:${e.address}`,
                s = p.H.state.defaultAccountTypes[t],
                n = d.U.state.preferredAccountTypes?.[t],
                a = e.preferredAccountType || n || s;
              b.y.isLowerCaseMatch(e.address, d.U.state.address) ||
                this.syncIdentity({
                  address: e.address,
                  chainId: e.chainId,
                  chainNamespace: t,
                }),
                this.setCaipAddress(r, t),
                this.setUser({ ...(d.U.state.user || {}), ...e }, t),
                this.setSmartAccountDeployed(!!e.smartAccountDeployed, t),
                this.setPreferredAccountType(a, t);
              let o = e.accounts?.map((e) =>
                f.w.createAccount(t, e.address, e.type || n || s)
              );
              this.setAllAccounts(
                o || [
                  f.w.createAccount(t, e.address, e.preferredAccountType || a),
                ],
                t
              ),
                this.setLoading(!1, t);
            }),
            e.onSocialConnected(({ userName: e }) => {
              this.setUser(
                { ...(d.U.state.user || {}), username: e },
                h.W.state.activeChain
              );
            }),
            e.onGetSmartAccountEnabledNetworks((e) => {
              this.setSmartAccountEnabledNetworks(e, h.W.state.activeChain);
            }),
            e.onSetPreferredAccount(({ address: e, type: t }) => {
              e && this.setPreferredAccountType(t, h.W.state.activeChain);
            });
        }
        async syncAuthConnector(e, t) {
          let r = i.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(t);
          if (!r) return;
          this.setLoading(!0, t);
          let a = e.getLoginEmailUsed();
          this.setLoading(a, t), a && this.setStatus("connecting", t);
          let o = e.getEmail(),
            c = e.getUsername();
          this.setUser(
            { ...(d.U.state?.user || {}), username: c, email: o },
            t
          ),
            this.setupAuthConnectorListeners(e);
          let { isConnected: l } = await e.isConnected(),
            u = g.W.getSnapshot(),
            f = p.H.getSnapshot();
          await Promise.all([
            e.syncDappData({
              metadata: f.metadata,
              sdkVersion: f.sdkVersion,
              projectId: f.projectId,
              sdkType: f.sdkType,
            }),
            e.syncTheme({
              themeMode: u.themeMode,
              themeVariables: u.themeVariables,
              w3mThemeVariables: (0, s.o)(u.themeVariables, u.themeMode),
            }),
          ]),
            await e.getSmartAccountEnabledNetworks(),
            t &&
              r &&
              (l && this.connectionControllerClient?.connectExternal
                ? (await this.connectionControllerClient?.connectExternal({
                    id: i.o.CONNECTOR_ID.AUTH,
                    info: { name: i.o.CONNECTOR_ID.AUTH },
                    type: w.o.CONNECTOR_TYPE_AUTH,
                    provider: e,
                    chainId: h.W.state.activeCaipNetwork?.id,
                    chain: t,
                  }),
                  this.setStatus("connected", t))
                : n.a.getConnectorId(t) === i.o.CONNECTOR_ID.AUTH &&
                  (this.setStatus("disconnected", t),
                  m.i.removeConnectedNamespace(t))),
            this.setLoading(!1, t);
        }
        async checkExistingTelegramSocialConnection(e) {
          try {
            if (!f.w.isTelegram()) return;
            let t = m.i.getTelegramSocialProvider();
            if (!t || !f.w.isClient()) return;
            let r = new URL(window.location.href).searchParams.get(
              "result_uri"
            );
            if (!r) return;
            d.U.setSocialProvider(t, e), await this.authProvider?.init();
            let i = n.a.getAuthConnector();
            t &&
              i &&
              (this.setLoading(!0, e),
              await a.x.connectExternal(
                { id: i.id, type: i.type, socialUri: r },
                i.chain
              ),
              m.i.setConnectedSocialProvider(t),
              m.i.removeTelegramSocialProvider(),
              o.E.sendEvent({
                type: "track",
                event: "SOCIAL_LOGIN_SUCCESS",
                properties: { provider: t },
              }));
          } catch (t) {
            this.setLoading(!1, e),
              console.error("checkExistingSTelegramocialConnection error", t);
          }
          try {
            let e = new URL(window.location.href);
            e.searchParams.delete("result_uri"),
              window.history.replaceState({}, document.title, e.toString());
          } catch (e) {
            console.error("tma social login failed", e);
          }
        }
        createAuthProvider(e) {
          if (!i.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(e)) return;
          let t = this.remoteFeatures?.email,
            r =
              Array.isArray(this.remoteFeatures?.socials) &&
              this.remoteFeatures.socials.length > 0;
          !this.authProvider &&
            this.options?.projectId &&
            (t || r) &&
            ((this.authProvider = A.v.getInstance({
              projectId: this.options.projectId,
              enableLogger: this.options.enableAuthLogger,
              chainId: this.getCaipNetwork(e)?.caipNetworkId,
              abortController: v.R.EmbeddedWalletAbortController,
              onTimeout: (e) => {
                "iframe_load_failed" === e
                  ? y.h.open(v.R.ALERT_ERRORS.IFRAME_LOAD_FAILED, "error")
                  : "iframe_request_timeout" === e
                  ? y.h.open(v.R.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT, "error")
                  : "unverified_domain" === e &&
                    y.h.open(v.R.ALERT_ERRORS.UNVERIFIED_DOMAIN, "error");
              },
            })),
            c.z.subscribeOpen((e) => {
              !e &&
                this.isTransactionStackEmpty() &&
                this.authProvider?.rejectRpcRequests();
            }),
            this.syncAuthConnector(this.authProvider, e),
            this.checkExistingTelegramSocialConnection(e));
        }
        createAuthProviderForAdapter(e) {
          this.createAuthProvider(e),
            this.authProvider &&
              this.chainAdapters?.[e]?.setAuthProvider?.(this.authProvider);
        }
        initControllers(e) {
          super.initControllers(e),
            this.options.excludeWalletIds &&
              l.N.initializeExcludedWallets({
                ids: this.options.excludeWalletIds,
              });
        }
        async switchCaipNetwork(e) {
          if (!e) return;
          let t = h.W.state.activeChain,
            r = e.chainNamespace,
            s = this.getAddressByChainNamespace(r);
          if (r === t && s) {
            let t = this.getAdapter(r),
              i = E.A.getProvider(r),
              s = E.A.getProviderId(r);
            await t?.switchNetwork({
              caipNetwork: e,
              provider: i,
              providerType: s,
            }),
              this.setCaipNetwork(e);
          } else {
            let n = E.A.getProviderId(t) === w.o.CONNECTOR_TYPE_AUTH,
              a = E.A.getProviderId(r),
              o = a === w.o.CONNECTOR_TYPE_AUTH,
              c = i.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(r);
            if (((n && void 0 === a) || o) && c)
              try {
                if (((h.W.state.activeChain = e.chainNamespace), s)) {
                  let t = this.getAdapter(r);
                  await t?.switchNetwork({
                    caipNetwork: e,
                    provider: this.authProvider,
                    providerType: a,
                  });
                } else
                  await this.connectionControllerClient?.connectExternal?.({
                    id: i.o.CONNECTOR_ID.AUTH,
                    provider: this.authProvider,
                    chain: r,
                    chainId: e.id,
                    type: w.o.CONNECTOR_TYPE_AUTH,
                    caipNetwork: e,
                  });
                this.setCaipNetwork(e);
              } catch (i) {
                let t = this.getAdapter(r);
                await t?.switchNetwork({
                  caipNetwork: e,
                  provider: this.authProvider,
                  providerType: a,
                });
              }
            else
              a === w.o.CONNECTOR_TYPE_WALLET_CONNECT
                ? (this.setCaipNetwork(e), this.syncWalletConnectAccount())
                : (this.setCaipNetwork(e),
                  s &&
                    this.syncAccount({
                      address: s,
                      chainId: e.id,
                      chainNamespace: r,
                    }));
          }
        }
        async initialize(e) {
          await super.initialize(e),
            this.chainNamespaces?.forEach((e) => {
              this.createAuthProviderForAdapter(e);
            }),
            await this.injectModalUi(),
            c.z.set({ initialized: !0 });
        }
        async syncIdentity({ address: e, chainId: t, chainNamespace: r }) {
          let s = `${r}:${t}`,
            n = this.caipNetworks?.find((e) => e.caipNetworkId === s);
          if (r !== i.o.CHAIN.EVM || n?.testnet) {
            this.setProfileName(null, r), this.setProfileImage(null, r);
            return;
          }
          try {
            let { name: t, avatar: i } = await this.fetchIdentity({
              address: e,
              caipNetworkId: s,
            });
            this.setProfileName(t, r), this.setProfileImage(i, r);
          } catch {
            await this.syncReownName(e, r),
              1 !== t && this.setProfileImage(null, r);
          }
        }
        syncConnectedWalletInfo(e) {
          let t = E.A.getProviderId(e);
          if (t === w.o.CONNECTOR_TYPE_AUTH) {
            let r = this.authProvider;
            if (r) {
              let i = m.i.getConnectedSocialProvider() ?? "email",
                s = r.getEmail() ?? r.getUsername();
              this.setConnectedWalletInfo(
                { name: t, identifier: s, social: i },
                e
              );
            }
          } else super.syncConnectedWalletInfo(e);
        }
        async injectModalUi() {
          if (f.w.isClient() && !ee)
            try {
              let e = { ...u.oU.DEFAULT_FEATURES, ...this.options.features },
                t = this.remoteFeatures;
              if (
                (await this.loadModalComponents(e, t),
                f.w.isClient() && !document.querySelector("w3m-modal"))
              ) {
                let e = document.createElement("w3m-modal");
                p.H.state.disableAppend ||
                  p.H.state.enableEmbedded ||
                  document.body.insertAdjacentElement("beforeend", e);
              }
              ee = !0;
            } catch (e) {
              console.error("Error injecting modal UI:", e);
            }
        }
        async loadModalComponents(e, t) {
          if (!f.w.isClient()) return;
          let i = [];
          (t.email || (t.socials && t.socials.length > 0)) &&
            i.push(
              Promise.all([r.e(2626), r.e(2754), r.e(4003)]).then(
                r.bind(r, 14003)
              )
            ),
            t.email &&
              i.push(
                Promise.all([r.e(2626), r.e(2754), r.e(4180)]).then(
                  r.bind(r, 41799)
                )
              ),
            t.socials &&
              i.push(
                Promise.all([r.e(2626), r.e(4146), r.e(2099), r.e(1057)]).then(
                  r.bind(r, 47113)
                )
              ),
            t.swaps &&
              t.swaps.length > 0 &&
              i.push(
                Promise.all([r.e(2626), r.e(2754), r.e(118), r.e(4266)]).then(
                  r.bind(r, 94266)
                )
              ),
            e.send &&
              i.push(
                Promise.all([r.e(2626), r.e(2754), r.e(118), r.e(2077)]).then(
                  r.bind(r, 62077)
                )
              ),
            e.receive &&
              i.push(
                Promise.all([r.e(2626), r.e(4146), r.e(3771)]).then(
                  r.bind(r, 63771)
                )
              ),
            t.onramp &&
              t.onramp.length > 0 &&
              i.push(
                Promise.all([
                  r.e(2626),
                  r.e(2754),
                  r.e(2099),
                  r.e(6989),
                  r.e(2523),
                ]).then(r.bind(r, 92523))
              ),
            t.activity &&
              i.push(
                Promise.all([r.e(2626), r.e(5258), r.e(7450)]).then(
                  r.bind(r, 4597)
                )
              ),
            e.pay &&
              i.push(
                Promise.all([r.e(2626), r.e(9532)]).then(r.bind(r, 29532))
              ),
            await Promise.all([
              ...i,
              Promise.all([
                r.e(2626),
                r.e(2754),
                r.e(4146),
                r.e(2099),
                r.e(6989),
                r.e(5258),
                r.e(5433),
                r.e(605),
              ]).then(r.bind(r, 70605)),
              Promise.all([r.e(2626), r.e(5433), r.e(6071)]).then(
                r.bind(r, 2790)
              ),
            ]);
        }
      }
    },
    85569: (e, t, r) => {
      "use strict";
      r.d(t, { u: () => n });
      var i = r(62739);
      let s = new Map();
      function n({ fn: e, id: t, shouldSplitBatch: r, wait: n = 0, sort: a }) {
        let o = async () => {
            let t = u();
            c();
            let r = t.map(({ args: e }) => e);
            0 !== r.length &&
              e(r)
                .then((e) => {
                  a && Array.isArray(e) && e.sort(a);
                  for (let r = 0; r < t.length; r++) {
                    let { resolve: i } = t[r];
                    i?.([e[r], e]);
                  }
                })
                .catch((e) => {
                  for (let r = 0; r < t.length; r++) {
                    let { reject: i } = t[r];
                    i?.(e);
                  }
                });
          },
          c = () => s.delete(t),
          l = () => u().map(({ args: e }) => e),
          u = () => s.get(t) || [],
          d = (e) => s.set(t, [...u(), e]);
        return {
          flush: c,
          async schedule(e) {
            let { promise: t, resolve: s, reject: a } = (0, i.Y)();
            return (
              (r?.([...l(), e]) && o(), u().length > 0)
                ? d({ args: e, resolve: s, reject: a })
                : (d({ args: e, resolve: s, reject: a }), setTimeout(o, n)),
              t
            );
          },
        };
      }
    },
    86156: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.IWatch = void 0);
      class r {}
      t.IWatch = r;
    },
    86313: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          __assign: () => n,
          __asyncDelegator: () => v,
          __asyncGenerator: () => w,
          __asyncValues: () => E,
          __await: () => b,
          __awaiter: () => u,
          __classPrivateFieldGet: () => I,
          __classPrivateFieldSet: () => S,
          __createBinding: () => h,
          __decorate: () => o,
          __exportStar: () => p,
          __extends: () => s,
          __generator: () => d,
          __importDefault: () => A,
          __importStar: () => C,
          __makeTemplateObject: () => _,
          __metadata: () => l,
          __param: () => c,
          __read: () => g,
          __rest: () => a,
          __spread: () => m,
          __spreadArrays: () => y,
          __values: () => f,
        });
      var i = function (e, t) {
        return (i =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (e, t) {
              e.__proto__ = t;
            }) ||
          function (e, t) {
            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r]);
          })(e, t);
      };
      function s(e, t) {
        function r() {
          this.constructor = e;
        }
        i(e, t),
          (e.prototype =
            null === t
              ? Object.create(t)
              : ((r.prototype = t.prototype), new r()));
      }
      var n = function () {
        return (n =
          Object.assign ||
          function (e) {
            for (var t, r = 1, i = arguments.length; r < i; r++)
              for (var s in (t = arguments[r]))
                Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
            return e;
          }).apply(this, arguments);
      };
      function a(e, t) {
        var r = {};
        for (var i in e)
          Object.prototype.hasOwnProperty.call(e, i) &&
            0 > t.indexOf(i) &&
            (r[i] = e[i]);
        if (null != e && "function" == typeof Object.getOwnPropertySymbols)
          for (
            var s = 0, i = Object.getOwnPropertySymbols(e);
            s < i.length;
            s++
          )
            0 > t.indexOf(i[s]) &&
              Object.prototype.propertyIsEnumerable.call(e, i[s]) &&
              (r[i[s]] = e[i[s]]);
        return r;
      }
      function o(e, t, r, i) {
        var s,
          n = arguments.length,
          a =
            n < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (s = e[o]) &&
              (a = (n < 3 ? s(a) : n > 3 ? s(t, r, a) : s(t, r)) || a);
        return n > 3 && a && Object.defineProperty(t, r, a), a;
      }
      function c(e, t) {
        return function (r, i) {
          t(r, i, e);
        };
      }
      function l(e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
          return Reflect.metadata(e, t);
      }
      function u(e, t, r, i) {
        return new (r || (r = Promise))(function (s, n) {
          function a(e) {
            try {
              c(i.next(e));
            } catch (e) {
              n(e);
            }
          }
          function o(e) {
            try {
              c(i.throw(e));
            } catch (e) {
              n(e);
            }
          }
          function c(e) {
            var t;
            e.done
              ? s(e.value)
              : ((t = e.value) instanceof r
                  ? t
                  : new r(function (e) {
                      e(t);
                    })
                ).then(a, o);
          }
          c((i = i.apply(e, t || [])).next());
        });
      }
      function d(e, t) {
        var r,
          i,
          s,
          n,
          a = {
            label: 0,
            sent: function () {
              if (1 & s[0]) throw s[1];
              return s[1];
            },
            trys: [],
            ops: [],
          };
        return (
          (n = { next: o(0), throw: o(1), return: o(2) }),
          "function" == typeof Symbol &&
            (n[Symbol.iterator] = function () {
              return this;
            }),
          n
        );
        function o(n) {
          return function (o) {
            var c = [n, o];
            if (r) throw TypeError("Generator is already executing.");
            for (; a; )
              try {
                if (
                  ((r = 1),
                  i &&
                    (s =
                      2 & c[0]
                        ? i.return
                        : c[0]
                        ? i.throw || ((s = i.return) && s.call(i), 0)
                        : i.next) &&
                    !(s = s.call(i, c[1])).done)
                )
                  return s;
                switch (((i = 0), s && (c = [2 & c[0], s.value]), c[0])) {
                  case 0:
                  case 1:
                    s = c;
                    break;
                  case 4:
                    return a.label++, { value: c[1], done: !1 };
                  case 5:
                    a.label++, (i = c[1]), (c = [0]);
                    continue;
                  case 7:
                    (c = a.ops.pop()), a.trys.pop();
                    continue;
                  default:
                    if (
                      !(s = (s = a.trys).length > 0 && s[s.length - 1]) &&
                      (6 === c[0] || 2 === c[0])
                    ) {
                      a = 0;
                      continue;
                    }
                    if (3 === c[0] && (!s || (c[1] > s[0] && c[1] < s[3]))) {
                      a.label = c[1];
                      break;
                    }
                    if (6 === c[0] && a.label < s[1]) {
                      (a.label = s[1]), (s = c);
                      break;
                    }
                    if (s && a.label < s[2]) {
                      (a.label = s[2]), a.ops.push(c);
                      break;
                    }
                    s[2] && a.ops.pop(), a.trys.pop();
                    continue;
                }
                c = t.call(e, a);
              } catch (e) {
                (c = [6, e]), (i = 0);
              } finally {
                r = s = 0;
              }
            if (5 & c[0]) throw c[1];
            return { value: c[0] ? c[1] : void 0, done: !0 };
          };
        }
      }
      function h(e, t, r, i) {
        void 0 === i && (i = r), (e[i] = t[r]);
      }
      function p(e, t) {
        for (var r in e)
          "default" === r || t.hasOwnProperty(r) || (t[r] = e[r]);
      }
      function f(e) {
        var t = "function" == typeof Symbol && Symbol.iterator,
          r = t && e[t],
          i = 0;
        if (r) return r.call(e);
        if (e && "number" == typeof e.length)
          return {
            next: function () {
              return (
                e && i >= e.length && (e = void 0),
                { value: e && e[i++], done: !e }
              );
            },
          };
        throw TypeError(
          t ? "Object is not iterable." : "Symbol.iterator is not defined."
        );
      }
      function g(e, t) {
        var r = "function" == typeof Symbol && e[Symbol.iterator];
        if (!r) return e;
        var i,
          s,
          n = r.call(e),
          a = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(i = n.next()).done; )
            a.push(i.value);
        } catch (e) {
          s = { error: e };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (s) throw s.error;
          }
        }
        return a;
      }
      function m() {
        for (var e = [], t = 0; t < arguments.length; t++)
          e = e.concat(g(arguments[t]));
        return e;
      }
      function y() {
        for (var e = 0, t = 0, r = arguments.length; t < r; t++)
          e += arguments[t].length;
        for (var i = Array(e), s = 0, t = 0; t < r; t++)
          for (var n = arguments[t], a = 0, o = n.length; a < o; a++, s++)
            i[s] = n[a];
        return i;
      }
      function b(e) {
        return this instanceof b ? ((this.v = e), this) : new b(e);
      }
      function w(e, t, r) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var i,
          s = r.apply(e, t || []),
          n = [];
        return (
          (i = {}),
          a("next"),
          a("throw"),
          a("return"),
          (i[Symbol.asyncIterator] = function () {
            return this;
          }),
          i
        );
        function a(e) {
          s[e] &&
            (i[e] = function (t) {
              return new Promise(function (r, i) {
                n.push([e, t, r, i]) > 1 || o(e, t);
              });
            });
        }
        function o(e, t) {
          try {
            var r;
            (r = s[e](t)).value instanceof b
              ? Promise.resolve(r.value.v).then(c, l)
              : u(n[0][2], r);
          } catch (e) {
            u(n[0][3], e);
          }
        }
        function c(e) {
          o("next", e);
        }
        function l(e) {
          o("throw", e);
        }
        function u(e, t) {
          e(t), n.shift(), n.length && o(n[0][0], n[0][1]);
        }
      }
      function v(e) {
        var t, r;
        return (
          (t = {}),
          i("next"),
          i("throw", function (e) {
            throw e;
          }),
          i("return"),
          (t[Symbol.iterator] = function () {
            return this;
          }),
          t
        );
        function i(i, s) {
          t[i] = e[i]
            ? function (t) {
                return (r = !r)
                  ? { value: b(e[i](t)), done: "return" === i }
                  : s
                  ? s(t)
                  : t;
              }
            : s;
        }
      }
      function E(e) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var t,
          r = e[Symbol.asyncIterator];
        return r
          ? r.call(e)
          : ((e = f(e)),
            (t = {}),
            i("next"),
            i("throw"),
            i("return"),
            (t[Symbol.asyncIterator] = function () {
              return this;
            }),
            t);
        function i(r) {
          t[r] =
            e[r] &&
            function (t) {
              return new Promise(function (i, s) {
                var n, a, o;
                (n = i),
                  (a = s),
                  (o = (t = e[r](t)).done),
                  Promise.resolve(t.value).then(function (e) {
                    n({ value: e, done: o });
                  }, a);
              });
            };
        }
      }
      function _(e, t) {
        return (
          Object.defineProperty
            ? Object.defineProperty(e, "raw", { value: t })
            : (e.raw = t),
          e
        );
      }
      function C(e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e)
          for (var r in e) Object.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return (t.default = e), t;
      }
      function A(e) {
        return e && e.__esModule ? e : { default: e };
      }
      function I(e, t) {
        if (!t.has(e))
          throw TypeError("attempted to get private field on non-instance");
        return t.get(e);
      }
      function S(e, t, r) {
        if (!t.has(e))
          throw TypeError("attempted to set private field on non-instance");
        return t.set(e, r), r;
      }
    },
    87094: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => s });
      var i = r(32840);
      function s(e) {
        return (0, i.q)(e, { strict: !1 })
          ? Math.ceil((e.length - 2) / 2)
          : e.length;
      }
    },
    87316: (e, t, r) => {
      "use strict";
      r.d(t, { N9: () => $, oR: () => x });
      var i = r(12115);
      let s = function () {
        for (var e, t, r = 0, i = "", s = arguments.length; r < s; r++)
          (e = arguments[r]) &&
            (t = (function e(t) {
              var r,
                i,
                s = "";
              if ("string" == typeof t || "number" == typeof t) s += t;
              else if ("object" == typeof t)
                if (Array.isArray(t)) {
                  var n = t.length;
                  for (r = 0; r < n; r++)
                    t[r] && (i = e(t[r])) && (s && (s += " "), (s += i));
                } else for (i in t) t[i] && (s && (s += " "), (s += i));
              return s;
            })(e)) &&
            (i && (i += " "), (i += t));
        return i;
      };
      !(function (e) {
        if (!e || "undefined" == typeof document) return;
        let t = document.head || document.getElementsByTagName("head")[0],
          r = document.createElement("style");
        (r.type = "text/css"),
          t.firstChild ? t.insertBefore(r, t.firstChild) : t.appendChild(r),
          r.styleSheet
            ? (r.styleSheet.cssText = e)
            : r.appendChild(document.createTextNode(e));
      })(
        ':root{--toastify-color-light: #fff;--toastify-color-dark: #121212;--toastify-color-info: #3498db;--toastify-color-success: #07bc0c;--toastify-color-warning: #f1c40f;--toastify-color-error: hsl(6, 78%, 57%);--toastify-color-transparent: rgba(255, 255, 255, .7);--toastify-icon-color-info: var(--toastify-color-info);--toastify-icon-color-success: var(--toastify-color-success);--toastify-icon-color-warning: var(--toastify-color-warning);--toastify-icon-color-error: var(--toastify-color-error);--toastify-container-width: fit-content;--toastify-toast-width: 320px;--toastify-toast-offset: 16px;--toastify-toast-top: max(var(--toastify-toast-offset), env(safe-area-inset-top));--toastify-toast-right: max(var(--toastify-toast-offset), env(safe-area-inset-right));--toastify-toast-left: max(var(--toastify-toast-offset), env(safe-area-inset-left));--toastify-toast-bottom: max(var(--toastify-toast-offset), env(safe-area-inset-bottom));--toastify-toast-background: #fff;--toastify-toast-padding: 14px;--toastify-toast-min-height: 64px;--toastify-toast-max-height: 800px;--toastify-toast-bd-radius: 6px;--toastify-toast-shadow: 0px 4px 12px rgba(0, 0, 0, .1);--toastify-font-family: sans-serif;--toastify-z-index: 9999;--toastify-text-color-light: #757575;--toastify-text-color-dark: #fff;--toastify-text-color-info: #fff;--toastify-text-color-success: #fff;--toastify-text-color-warning: #fff;--toastify-text-color-error: #fff;--toastify-spinner-color: #616161;--toastify-spinner-color-empty-area: #e0e0e0;--toastify-color-progress-light: linear-gradient(to right, #4cd964, #5ac8fa, #007aff, #34aadc, #5856d6, #ff2d55);--toastify-color-progress-dark: #bb86fc;--toastify-color-progress-info: var(--toastify-color-info);--toastify-color-progress-success: var(--toastify-color-success);--toastify-color-progress-warning: var(--toastify-color-warning);--toastify-color-progress-error: var(--toastify-color-error);--toastify-color-progress-bgo: .2}.Toastify__toast-container{z-index:var(--toastify-z-index);-webkit-transform:translate3d(0,0,var(--toastify-z-index));position:fixed;width:var(--toastify-container-width);box-sizing:border-box;color:#fff;display:flex;flex-direction:column}.Toastify__toast-container--top-left{top:var(--toastify-toast-top);left:var(--toastify-toast-left)}.Toastify__toast-container--top-center{top:var(--toastify-toast-top);left:50%;transform:translate(-50%);align-items:center}.Toastify__toast-container--top-right{top:var(--toastify-toast-top);right:var(--toastify-toast-right);align-items:end}.Toastify__toast-container--bottom-left{bottom:var(--toastify-toast-bottom);left:var(--toastify-toast-left)}.Toastify__toast-container--bottom-center{bottom:var(--toastify-toast-bottom);left:50%;transform:translate(-50%);align-items:center}.Toastify__toast-container--bottom-right{bottom:var(--toastify-toast-bottom);right:var(--toastify-toast-right);align-items:end}.Toastify__toast{--y: 0;position:relative;touch-action:none;width:var(--toastify-toast-width);min-height:var(--toastify-toast-min-height);box-sizing:border-box;margin-bottom:1rem;padding:var(--toastify-toast-padding);border-radius:var(--toastify-toast-bd-radius);box-shadow:var(--toastify-toast-shadow);max-height:var(--toastify-toast-max-height);font-family:var(--toastify-font-family);z-index:0;display:flex;flex:1 auto;align-items:center;word-break:break-word}@media only screen and (max-width: 480px){.Toastify__toast-container{width:100vw;left:env(safe-area-inset-left);margin:0}.Toastify__toast-container--top-left,.Toastify__toast-container--top-center,.Toastify__toast-container--top-right{top:env(safe-area-inset-top);transform:translate(0)}.Toastify__toast-container--bottom-left,.Toastify__toast-container--bottom-center,.Toastify__toast-container--bottom-right{bottom:env(safe-area-inset-bottom);transform:translate(0)}.Toastify__toast-container--rtl{right:env(safe-area-inset-right);left:initial}.Toastify__toast{--toastify-toast-width: 100%;margin-bottom:0;border-radius:0}}.Toastify__toast-container[data-stacked=true]{width:var(--toastify-toast-width)}.Toastify__toast--stacked{position:absolute;width:100%;transform:translate3d(0,var(--y),0) scale(var(--s));transition:transform .3s}.Toastify__toast--stacked[data-collapsed] .Toastify__toast-body,.Toastify__toast--stacked[data-collapsed] .Toastify__close-button{transition:opacity .1s}.Toastify__toast--stacked[data-collapsed=false]{overflow:visible}.Toastify__toast--stacked[data-collapsed=true]:not(:last-child)>*{opacity:0}.Toastify__toast--stacked:after{content:"";position:absolute;left:0;right:0;height:calc(var(--g) * 1px);bottom:100%}.Toastify__toast--stacked[data-pos=top]{top:0}.Toastify__toast--stacked[data-pos=bot]{bottom:0}.Toastify__toast--stacked[data-pos=bot].Toastify__toast--stacked:before{transform-origin:top}.Toastify__toast--stacked[data-pos=top].Toastify__toast--stacked:before{transform-origin:bottom}.Toastify__toast--stacked:before{content:"";position:absolute;left:0;right:0;bottom:0;height:100%;transform:scaleY(3);z-index:-1}.Toastify__toast--rtl{direction:rtl}.Toastify__toast--close-on-click{cursor:pointer}.Toastify__toast-icon{margin-inline-end:10px;width:22px;flex-shrink:0;display:flex}.Toastify--animate{animation-fill-mode:both;animation-duration:.5s}.Toastify--animate-icon{animation-fill-mode:both;animation-duration:.3s}.Toastify__toast-theme--dark{background:var(--toastify-color-dark);color:var(--toastify-text-color-dark)}.Toastify__toast-theme--light,.Toastify__toast-theme--colored.Toastify__toast--default{background:var(--toastify-color-light);color:var(--toastify-text-color-light)}.Toastify__toast-theme--colored.Toastify__toast--info{color:var(--toastify-text-color-info);background:var(--toastify-color-info)}.Toastify__toast-theme--colored.Toastify__toast--success{color:var(--toastify-text-color-success);background:var(--toastify-color-success)}.Toastify__toast-theme--colored.Toastify__toast--warning{color:var(--toastify-text-color-warning);background:var(--toastify-color-warning)}.Toastify__toast-theme--colored.Toastify__toast--error{color:var(--toastify-text-color-error);background:var(--toastify-color-error)}.Toastify__progress-bar-theme--light{background:var(--toastify-color-progress-light)}.Toastify__progress-bar-theme--dark{background:var(--toastify-color-progress-dark)}.Toastify__progress-bar--info{background:var(--toastify-color-progress-info)}.Toastify__progress-bar--success{background:var(--toastify-color-progress-success)}.Toastify__progress-bar--warning{background:var(--toastify-color-progress-warning)}.Toastify__progress-bar--error{background:var(--toastify-color-progress-error)}.Toastify__progress-bar-theme--colored.Toastify__progress-bar--info,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--success,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--warning,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--error{background:var(--toastify-color-transparent)}.Toastify__close-button{color:#fff;position:absolute;top:6px;right:6px;background:transparent;outline:none;border:none;padding:0;cursor:pointer;opacity:.7;transition:.3s ease;z-index:1}.Toastify__toast--rtl .Toastify__close-button{left:6px;right:unset}.Toastify__close-button--light{color:#000;opacity:.3}.Toastify__close-button>svg{fill:currentColor;height:16px;width:14px}.Toastify__close-button:hover,.Toastify__close-button:focus{opacity:1}@keyframes Toastify__trackProgress{0%{transform:scaleX(1)}to{transform:scaleX(0)}}.Toastify__progress-bar{position:absolute;bottom:0;left:0;width:100%;height:100%;z-index:1;opacity:.7;transform-origin:left}.Toastify__progress-bar--animated{animation:Toastify__trackProgress linear 1 forwards}.Toastify__progress-bar--controlled{transition:transform .2s}.Toastify__progress-bar--rtl{right:0;left:initial;transform-origin:right;border-bottom-left-radius:initial}.Toastify__progress-bar--wrp{position:absolute;overflow:hidden;bottom:0;left:0;width:100%;height:5px;border-bottom-left-radius:var(--toastify-toast-bd-radius);border-bottom-right-radius:var(--toastify-toast-bd-radius)}.Toastify__progress-bar--wrp[data-hidden=true]{opacity:0}.Toastify__progress-bar--bg{opacity:var(--toastify-color-progress-bgo);width:100%;height:100%}.Toastify__spinner{width:20px;height:20px;box-sizing:border-box;border:2px solid;border-radius:100%;border-color:var(--toastify-spinner-color-empty-area);border-right-color:var(--toastify-spinner-color);animation:Toastify__spin .65s linear infinite}@keyframes Toastify__bounceInRight{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(3000px,0,0)}60%{opacity:1;transform:translate3d(-25px,0,0)}75%{transform:translate3d(10px,0,0)}90%{transform:translate3d(-5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutRight{20%{opacity:1;transform:translate3d(-20px,var(--y),0)}to{opacity:0;transform:translate3d(2000px,var(--y),0)}}@keyframes Toastify__bounceInLeft{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(-3000px,0,0)}60%{opacity:1;transform:translate3d(25px,0,0)}75%{transform:translate3d(-10px,0,0)}90%{transform:translate3d(5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutLeft{20%{opacity:1;transform:translate3d(20px,var(--y),0)}to{opacity:0;transform:translate3d(-2000px,var(--y),0)}}@keyframes Toastify__bounceInUp{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,3000px,0)}60%{opacity:1;transform:translate3d(0,-20px,0)}75%{transform:translate3d(0,10px,0)}90%{transform:translate3d(0,-5px,0)}to{transform:translateZ(0)}}@keyframes Toastify__bounceOutUp{20%{transform:translate3d(0,calc(var(--y) - 10px),0)}40%,45%{opacity:1;transform:translate3d(0,calc(var(--y) + 20px),0)}to{opacity:0;transform:translate3d(0,-2000px,0)}}@keyframes Toastify__bounceInDown{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,-3000px,0)}60%{opacity:1;transform:translate3d(0,25px,0)}75%{transform:translate3d(0,-10px,0)}90%{transform:translate3d(0,5px,0)}to{transform:none}}@keyframes Toastify__bounceOutDown{20%{transform:translate3d(0,calc(var(--y) - 10px),0)}40%,45%{opacity:1;transform:translate3d(0,calc(var(--y) + 20px),0)}to{opacity:0;transform:translate3d(0,2000px,0)}}.Toastify__bounce-enter--top-left,.Toastify__bounce-enter--bottom-left{animation-name:Toastify__bounceInLeft}.Toastify__bounce-enter--top-right,.Toastify__bounce-enter--bottom-right{animation-name:Toastify__bounceInRight}.Toastify__bounce-enter--top-center{animation-name:Toastify__bounceInDown}.Toastify__bounce-enter--bottom-center{animation-name:Toastify__bounceInUp}.Toastify__bounce-exit--top-left,.Toastify__bounce-exit--bottom-left{animation-name:Toastify__bounceOutLeft}.Toastify__bounce-exit--top-right,.Toastify__bounce-exit--bottom-right{animation-name:Toastify__bounceOutRight}.Toastify__bounce-exit--top-center{animation-name:Toastify__bounceOutUp}.Toastify__bounce-exit--bottom-center{animation-name:Toastify__bounceOutDown}@keyframes Toastify__zoomIn{0%{opacity:0;transform:scale3d(.3,.3,.3)}50%{opacity:1}}@keyframes Toastify__zoomOut{0%{opacity:1}50%{opacity:0;transform:translate3d(0,var(--y),0) scale3d(.3,.3,.3)}to{opacity:0}}.Toastify__zoom-enter{animation-name:Toastify__zoomIn}.Toastify__zoom-exit{animation-name:Toastify__zoomOut}@keyframes Toastify__flipIn{0%{transform:perspective(400px) rotateX(90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotateX(-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotateX(10deg);opacity:1}80%{transform:perspective(400px) rotateX(-5deg)}to{transform:perspective(400px)}}@keyframes Toastify__flipOut{0%{transform:translate3d(0,var(--y),0) perspective(400px)}30%{transform:translate3d(0,var(--y),0) perspective(400px) rotateX(-20deg);opacity:1}to{transform:translate3d(0,var(--y),0) perspective(400px) rotateX(90deg);opacity:0}}.Toastify__flip-enter{animation-name:Toastify__flipIn}.Toastify__flip-exit{animation-name:Toastify__flipOut}@keyframes Toastify__slideInRight{0%{transform:translate3d(110%,0,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInLeft{0%{transform:translate3d(-110%,0,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInUp{0%{transform:translate3d(0,110%,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInDown{0%{transform:translate3d(0,-110%,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideOutRight{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(110%,var(--y),0)}}@keyframes Toastify__slideOutLeft{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(-110%,var(--y),0)}}@keyframes Toastify__slideOutDown{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(0,500px,0)}}@keyframes Toastify__slideOutUp{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(0,-500px,0)}}.Toastify__slide-enter--top-left,.Toastify__slide-enter--bottom-left{animation-name:Toastify__slideInLeft}.Toastify__slide-enter--top-right,.Toastify__slide-enter--bottom-right{animation-name:Toastify__slideInRight}.Toastify__slide-enter--top-center{animation-name:Toastify__slideInDown}.Toastify__slide-enter--bottom-center{animation-name:Toastify__slideInUp}.Toastify__slide-exit--top-left,.Toastify__slide-exit--bottom-left{animation-name:Toastify__slideOutLeft;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--top-right,.Toastify__slide-exit--bottom-right{animation-name:Toastify__slideOutRight;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--top-center{animation-name:Toastify__slideOutUp;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--bottom-center{animation-name:Toastify__slideOutDown;animation-timing-function:ease-in;animation-duration:.3s}@keyframes Toastify__spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}\n'
      );
      var n = (e) => "number" == typeof e && !isNaN(e),
        a = (e) => "string" == typeof e,
        o = (e) => "function" == typeof e,
        c = (e) => a(e) || n(e),
        l = (e) => (a(e) || o(e) ? e : null),
        u = (e, t) => (!1 === e || (n(e) && e > 0) ? e : t),
        d = (e) => (0, i.isValidElement)(e) || a(e) || o(e) || n(e);
      function h(e) {
        let {
          enter: t,
          exit: r,
          appendPosition: s = !1,
          collapse: n = !0,
          collapseDuration: a = 300,
        } = e;
        return function (e) {
          let {
              children: o,
              position: c,
              preventExitTransition: l,
              done: u,
              nodeRef: d,
              isIn: h,
              playToast: p,
            } = e,
            f = s ? "".concat(t, "--").concat(c) : t,
            g = s ? "".concat(r, "--").concat(c) : r,
            m = (0, i.useRef)(0);
          return (
            (0, i.useLayoutEffect)(() => {
              let e = d.current,
                t = f.split(" "),
                r = (i) => {
                  i.target === d.current &&
                    (p(),
                    e.removeEventListener("animationend", r),
                    e.removeEventListener("animationcancel", r),
                    0 === m.current &&
                      "animationcancel" !== i.type &&
                      e.classList.remove(...t));
                };
              e.classList.add(...t),
                e.addEventListener("animationend", r),
                e.addEventListener("animationcancel", r);
            }, []),
            (0, i.useEffect)(() => {
              let e = d.current,
                t = () => {
                  e.removeEventListener("animationend", t),
                    n
                      ? (function (e, t) {
                          let r =
                              arguments.length > 2 && void 0 !== arguments[2]
                                ? arguments[2]
                                : 300,
                            { scrollHeight: i, style: s } = e;
                          requestAnimationFrame(() => {
                            (s.minHeight = "initial"),
                              (s.height = i + "px"),
                              (s.transition = "all ".concat(r, "ms")),
                              requestAnimationFrame(() => {
                                (s.height = "0"),
                                  (s.padding = "0"),
                                  (s.margin = "0"),
                                  setTimeout(t, r);
                              });
                          });
                        })(e, u, a)
                      : u();
                };
              h ||
                (l
                  ? t()
                  : ((m.current = 1),
                    (e.className += " ".concat(g)),
                    e.addEventListener("animationend", t)));
            }, [h]),
            i.createElement(i.Fragment, null, o)
          );
        };
      }
      function p(e, t) {
        return {
          content: f(e.content, e.props),
          containerId: e.props.containerId,
          id: e.props.toastId,
          theme: e.props.theme,
          type: e.props.type,
          data: e.props.data || {},
          isLoading: e.props.isLoading,
          icon: e.props.icon,
          reason: e.removalReason,
          status: t,
        };
      }
      function f(e, t) {
        let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return (0, i.isValidElement)(e) && !a(e.type)
          ? (0, i.cloneElement)(e, {
              closeToast: t.closeToast,
              toastProps: t,
              data: t.data,
              isPaused: r,
            })
          : o(e)
          ? e({
              closeToast: t.closeToast,
              toastProps: t,
              data: t.data,
              isPaused: r,
            })
          : e;
      }
      function g(e) {
        let {
            delay: t,
            isRunning: r,
            closeToast: n,
            type: a = "default",
            hide: c,
            className: l,
            controlledProgress: u,
            progress: d,
            rtl: h,
            isIn: p,
            theme: f,
          } = e,
          g = c || (u && 0 === d),
          m = {
            animationDuration: "".concat(t, "ms"),
            animationPlayState: r ? "running" : "paused",
          };
        u && (m.transform = "scaleX(".concat(d, ")"));
        let y = s(
            "Toastify__progress-bar",
            u
              ? "Toastify__progress-bar--controlled"
              : "Toastify__progress-bar--animated",
            "Toastify__progress-bar-theme--".concat(f),
            "Toastify__progress-bar--".concat(a),
            { "Toastify__progress-bar--rtl": h }
          ),
          b = o(l) ? l({ rtl: h, type: a, defaultClassName: y }) : s(y, l);
        return i.createElement(
          "div",
          { className: "Toastify__progress-bar--wrp", "data-hidden": g },
          i.createElement("div", {
            className:
              "Toastify__progress-bar--bg Toastify__progress-bar-theme--"
                .concat(f, " Toastify__progress-bar--")
                .concat(a),
          }),
          i.createElement("div", {
            role: "progressbar",
            "aria-hidden": g ? "true" : "false",
            "aria-label": "notification timer",
            className: b,
            style: m,
            ...{
              [u && d >= 1 ? "onTransitionEnd" : "onAnimationEnd"]:
                u && d < 1
                  ? null
                  : () => {
                      p && n();
                    },
            },
          })
        );
      }
      var m = 1,
        y = () => "".concat(m++),
        b = new Map(),
        w = [],
        v = new Set(),
        E = (e) => v.forEach((t) => t(e)),
        _ = () => b.size > 0,
        C = (e, t) => {
          var r;
          let { containerId: i } = t;
          return null == (r = b.get(i || 1)) ? void 0 : r.toasts.get(e);
        };
      function A(e, t) {
        var r;
        if (t) return !!(null != (r = b.get(t)) && r.isToastActive(e));
        let i = !1;
        return (
          b.forEach((t) => {
            t.isToastActive(e) && (i = !0);
          }),
          i
        );
      }
      function I(e, t) {
        d(e) &&
          (_() || w.push({ content: e, options: t }),
          b.forEach((r) => {
            r.buildToast(e, t);
          }));
      }
      function S(e, t) {
        b.forEach((r) => {
          (null != t &&
            null != t &&
            t.containerId &&
            (null == t ? void 0 : t.containerId) !== r.id) ||
            r.toggle(e, null == t ? void 0 : t.id);
        });
      }
      function N(e, t) {
        return I(e, t), t.toastId;
      }
      function T(e, t) {
        return {
          ...t,
          type: (t && t.type) || e,
          toastId: t && (a(t.toastId) || n(t.toastId)) ? t.toastId : y(),
        };
      }
      function O(e) {
        return (t, r) => N(t, T(e, r));
      }
      function x(e, t) {
        return N(e, T("default", t));
      }
      (x.loading = (e, t) =>
        N(
          e,
          T("default", {
            isLoading: !0,
            autoClose: !1,
            closeOnClick: !1,
            closeButton: !1,
            draggable: !1,
            ...t,
          })
        )),
        (x.promise = function (e, t, r) {
          let i,
            { pending: s, error: n, success: c } = t;
          s &&
            (i = a(s) ? x.loading(s, r) : x.loading(s.render, { ...r, ...s }));
          let l = {
              isLoading: null,
              autoClose: null,
              closeOnClick: null,
              closeButton: null,
              draggable: null,
            },
            u = (e, t, s) => {
              if (null == t) return void x.dismiss(i);
              let n = { type: e, ...l, ...r, data: s },
                o = a(t) ? { render: t } : t;
              return (
                i ? x.update(i, { ...n, ...o }) : x(o.render, { ...n, ...o }), s
              );
            },
            d = o(e) ? e() : e;
          return (
            d.then((e) => u("success", c, e)).catch((e) => u("error", n, e)), d
          );
        }),
        (x.success = O("success")),
        (x.info = O("info")),
        (x.error = O("error")),
        (x.warning = O("warning")),
        (x.warn = x.warning),
        (x.dark = (e, t) => N(e, T("default", { theme: "dark", ...t }))),
        (x.dismiss = function (e) {
          !(function (e) {
            if (!_()) {
              w = w.filter((t) => null != e && t.options.toastId !== e);
              return;
            }
            if (null == e || c(e))
              b.forEach((t) => {
                t.removeToast(e);
              });
            else if (e && ("containerId" in e || "id" in e)) {
              let t = b.get(e.containerId);
              t
                ? t.removeToast(e.id)
                : b.forEach((t) => {
                    t.removeToast(e.id);
                  });
            }
          })(e);
        }),
        (x.clearWaitingQueue = function () {
          let e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          b.forEach((t) => {
            t.props.limit &&
              (!e.containerId || t.id === e.containerId) &&
              t.clearQueue();
          });
        }),
        (x.isActive = A),
        (x.update = function (e) {
          let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {},
            r = C(e, t);
          if (r) {
            let { props: i, content: s } = r,
              n = {
                delay: 100,
                ...i,
                ...t,
                toastId: t.toastId || e,
                updateId: y(),
              };
            n.toastId !== e && (n.staleId = e);
            let a = n.render || s;
            delete n.render, N(a, n);
          }
        }),
        (x.done = (e) => {
          x.update(e, { progress: 1 });
        }),
        (x.onChange = function (e) {
          return (
            v.add(e),
            () => {
              v.delete(e);
            }
          );
        }),
        (x.play = (e) => S(!0, e)),
        (x.pause = (e) => S(!1, e));
      var P = "undefined" != typeof window ? i.useLayoutEffect : i.useEffect,
        R = (e) => {
          let { theme: t, type: r, isLoading: s, ...n } = e;
          return i.createElement("svg", {
            viewBox: "0 0 24 24",
            width: "100%",
            height: "100%",
            fill:
              "colored" === t
                ? "currentColor"
                : "var(--toastify-icon-color-".concat(r, ")"),
            ...n,
          });
        },
        k = {
          info: function (e) {
            return i.createElement(
              R,
              { ...e },
              i.createElement("path", {
                d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z",
              })
            );
          },
          warning: function (e) {
            return i.createElement(
              R,
              { ...e },
              i.createElement("path", {
                d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z",
              })
            );
          },
          success: function (e) {
            return i.createElement(
              R,
              { ...e },
              i.createElement("path", {
                d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z",
              })
            );
          },
          error: function (e) {
            return i.createElement(
              R,
              { ...e },
              i.createElement("path", {
                d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z",
              })
            );
          },
          spinner: function () {
            return i.createElement("div", { className: "Toastify__spinner" });
          },
        },
        D = (e) => e in k,
        U = (e) => {
          let {
              isRunning: t,
              preventExitTransition: r,
              toastRef: n,
              eventHandlers: a,
              playToast: c,
            } = (function (e) {
              var t, r;
              let [s, n] = (0, i.useState)(!1),
                [a, o] = (0, i.useState)(!1),
                c = (0, i.useRef)(null),
                l = (0, i.useRef)({
                  start: 0,
                  delta: 0,
                  removalDistance: 0,
                  canCloseOnClick: !0,
                  canDrag: !1,
                  didMove: !1,
                }).current,
                {
                  autoClose: u,
                  pauseOnHover: d,
                  closeToast: h,
                  onClick: p,
                  closeOnClick: f,
                } = e;
              function g() {
                n(!0);
              }
              function m() {
                n(!1);
              }
              function y(t) {
                let r = c.current;
                if (l.canDrag && r) {
                  (l.didMove = !0),
                    s && m(),
                    "x" === e.draggableDirection
                      ? (l.delta = t.clientX - l.start)
                      : (l.delta = t.clientY - l.start),
                    l.start !== t.clientX && (l.canCloseOnClick = !1);
                  let i =
                    "x" === e.draggableDirection
                      ? "".concat(l.delta, "px, var(--y)")
                      : "0, calc(".concat(l.delta, "px + var(--y))");
                  (r.style.transform = "translate3d(".concat(i, ",0)")),
                    (r.style.opacity = "".concat(
                      1 - Math.abs(l.delta / l.removalDistance)
                    ));
                }
              }
              function w() {
                document.removeEventListener("pointermove", y),
                  document.removeEventListener("pointerup", w);
                let t = c.current;
                if (l.canDrag && l.didMove && t) {
                  if (
                    ((l.canDrag = !1), Math.abs(l.delta) > l.removalDistance)
                  ) {
                    o(!0), e.closeToast(!0), e.collapseAll();
                    return;
                  }
                  (t.style.transition = "transform 0.2s, opacity 0.2s"),
                    t.style.removeProperty("transform"),
                    t.style.removeProperty("opacity");
                }
              }
              (t = { id: e.toastId, containerId: e.containerId, fn: n }),
                null == (r = b.get(t.containerId || 1)) ||
                  r.setToggle(t.id, t.fn),
                (0, i.useEffect)(() => {
                  if (e.pauseOnFocusLoss)
                    return (
                      document.hasFocus() || m(),
                      window.addEventListener("focus", g),
                      window.addEventListener("blur", m),
                      () => {
                        window.removeEventListener("focus", g),
                          window.removeEventListener("blur", m);
                      }
                    );
                }, [e.pauseOnFocusLoss]);
              let v = {
                onPointerDown: function (t) {
                  if (!0 === e.draggable || e.draggable === t.pointerType) {
                    (l.didMove = !1),
                      document.addEventListener("pointermove", y),
                      document.addEventListener("pointerup", w);
                    let r = c.current;
                    (l.canCloseOnClick = !0),
                      (l.canDrag = !0),
                      (r.style.transition = "none"),
                      "x" === e.draggableDirection
                        ? ((l.start = t.clientX),
                          (l.removalDistance =
                            r.offsetWidth * (e.draggablePercent / 100)))
                        : ((l.start = t.clientY),
                          (l.removalDistance =
                            (r.offsetHeight *
                              (80 === e.draggablePercent
                                ? 1.5 * e.draggablePercent
                                : e.draggablePercent)) /
                            100));
                  }
                },
                onPointerUp: function (t) {
                  let {
                    top: r,
                    bottom: i,
                    left: s,
                    right: n,
                  } = c.current.getBoundingClientRect();
                  "touchend" !== t.nativeEvent.type &&
                  e.pauseOnHover &&
                  t.clientX >= s &&
                  t.clientX <= n &&
                  t.clientY >= r &&
                  t.clientY <= i
                    ? m()
                    : g();
                },
              };
              return (
                u &&
                  d &&
                  ((v.onMouseEnter = m), e.stacked || (v.onMouseLeave = g)),
                f &&
                  (v.onClick = (e) => {
                    p && p(e), l.canCloseOnClick && h(!0);
                  }),
                {
                  playToast: g,
                  pauseToast: m,
                  isRunning: s,
                  preventExitTransition: a,
                  toastRef: c,
                  eventHandlers: v,
                }
              );
            })(e),
            {
              closeButton: l,
              children: u,
              autoClose: d,
              onClick: h,
              type: p,
              hideProgressBar: m,
              closeToast: y,
              transition: w,
              position: v,
              className: E,
              style: _,
              progressClassName: C,
              updateId: A,
              role: I,
              progress: S,
              rtl: N,
              toastId: T,
              deleteToast: O,
              isIn: x,
              isLoading: P,
              closeOnClick: R,
              theme: U,
              ariaLabel: L,
            } = e,
            M = s(
              "Toastify__toast",
              "Toastify__toast-theme--".concat(U),
              "Toastify__toast--".concat(p),
              { "Toastify__toast--rtl": N },
              { "Toastify__toast--close-on-click": R }
            ),
            j = o(E)
              ? E({ rtl: N, position: v, type: p, defaultClassName: M })
              : s(M, E),
            $ = (function (e) {
              let { theme: t, type: r, isLoading: s, icon: n } = e,
                a = null,
                c = { theme: t, type: r };
              return (
                !1 === n ||
                  (o(n)
                    ? (a = n({ ...c, isLoading: s }))
                    : (0, i.isValidElement)(n)
                    ? (a = (0, i.cloneElement)(n, c))
                    : s
                    ? (a = k.spinner())
                    : D(r) && (a = k[r](c))),
                a
              );
            })(e),
            B = !!S || !d,
            F = { closeToast: y, type: p, theme: U },
            W = null;
          return (
            !1 === l ||
              (W = o(l)
                ? l(F)
                : (0, i.isValidElement)(l)
                ? (0, i.cloneElement)(l, F)
                : (function (e) {
                    let { closeToast: t, theme: r, ariaLabel: s = "close" } = e;
                    return i.createElement(
                      "button",
                      {
                        className:
                          "Toastify__close-button Toastify__close-button--".concat(
                            r
                          ),
                        type: "button",
                        onClick: (e) => {
                          e.stopPropagation(), t(!0);
                        },
                        "aria-label": s,
                      },
                      i.createElement(
                        "svg",
                        { "aria-hidden": "true", viewBox: "0 0 14 16" },
                        i.createElement("path", {
                          fillRule: "evenodd",
                          d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z",
                        })
                      )
                    );
                  })(F)),
            i.createElement(
              w,
              {
                isIn: x,
                done: O,
                position: v,
                preventExitTransition: r,
                nodeRef: n,
                playToast: c,
              },
              i.createElement(
                "div",
                {
                  id: T,
                  tabIndex: 0,
                  onClick: h,
                  "data-in": x,
                  className: j,
                  ...a,
                  style: _,
                  ref: n,
                  ...(x && { role: I, "aria-label": L }),
                },
                null != $ &&
                  i.createElement(
                    "div",
                    {
                      className: s("Toastify__toast-icon", {
                        "Toastify--animate-icon Toastify__zoom-enter": !P,
                      }),
                    },
                    $
                  ),
                f(u, e, !t),
                W,
                !e.customProgressBar &&
                  i.createElement(g, {
                    ...(A && !B ? { key: "p-".concat(A) } : {}),
                    rtl: N,
                    theme: U,
                    delay: d,
                    isRunning: t,
                    isIn: x,
                    closeToast: y,
                    hide: m,
                    type: p,
                    className: C,
                    controlledProgress: B,
                    progress: S || 0,
                  })
              )
            )
          );
        },
        L = function (e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          return {
            enter: "Toastify--animate Toastify__".concat(e, "-enter"),
            exit: "Toastify--animate Toastify__".concat(e, "-exit"),
            appendPosition: t,
          };
        },
        M = h(L("bounce", !0));
      h(L("slide", !0)), h(L("zoom")), h(L("flip"));
      var j = {
        position: "top-right",
        transition: M,
        autoClose: 5e3,
        closeButton: !0,
        pauseOnHover: !0,
        pauseOnFocusLoss: !0,
        draggable: "touch",
        draggablePercent: 80,
        draggableDirection: "x",
        role: "alert",
        theme: "light",
        "aria-label": "Notifications Alt+T",
        hotKeys: (e) => e.altKey && "KeyT" === e.code,
      };
      function $(e) {
        let t = { ...j, ...e },
          r = e.stacked,
          [a, c] = (0, i.useState)(!0),
          h = (0, i.useRef)(null),
          {
            getToastToRender: f,
            isToastActive: g,
            count: m,
          } = (function (e) {
            var t;
            let r,
              {
                subscribe: s,
                getSnapshot: a,
                setProps: o,
              } = (0, i.useRef)(
                ((r = e.containerId || 1),
                {
                  subscribe(t) {
                    let i,
                      s,
                      a,
                      o,
                      c,
                      h,
                      f,
                      g,
                      m,
                      y,
                      v,
                      _,
                      C =
                        ((i = 1),
                        (s = 0),
                        (a = []),
                        (o = []),
                        (c = e),
                        (h = new Map()),
                        (f = new Set()),
                        (g = () => {
                          (o = Array.from(h.values())), f.forEach((e) => e());
                        }),
                        (m = (e) => {
                          let { containerId: t, toastId: i, updateId: s } = e,
                            n = h.has(i) && null == s;
                          return (t ? t !== r : 1 !== r) || n;
                        }),
                        (y = (e) => {
                          var t, r;
                          null ==
                            (r = null == (t = e.props) ? void 0 : t.onClose) ||
                            r.call(t, e.removalReason),
                            (e.isActive = !1);
                        }),
                        (v = (e) => {
                          if (null == e) h.forEach(y);
                          else {
                            let t = h.get(e);
                            t && y(t);
                          }
                          g();
                        }),
                        (_ = (e) => {
                          var t, r;
                          let { toastId: i, updateId: s } = e.props,
                            n = null == s;
                          e.staleId && h.delete(e.staleId),
                            (e.isActive = !0),
                            h.set(i, e),
                            g(),
                            E(p(e, n ? "added" : "updated")),
                            n &&
                              (null == (r = (t = e.props).onOpen) || r.call(t));
                        }),
                        {
                          id: r,
                          props: c,
                          observe: (e) => (f.add(e), () => f.delete(e)),
                          toggle: (e, t) => {
                            h.forEach((r) => {
                              var i;
                              (null == t || t === r.props.toastId) &&
                                (null == (i = r.toggle) || i.call(r, e));
                            });
                          },
                          removeToast: v,
                          toasts: h,
                          clearQueue: () => {
                            (s -= a.length), (a = []);
                          },
                          buildToast: (e, t) => {
                            if (m(t)) return;
                            let {
                                toastId: r,
                                updateId: o,
                                data: f,
                                staleId: y,
                                delay: b,
                              } = t,
                              w = null == o;
                            w && s++;
                            let C = {
                              ...c,
                              style: c.toastStyle,
                              key: i++,
                              ...Object.fromEntries(
                                Object.entries(t).filter((e) => {
                                  let [t, r] = e;
                                  return null != r;
                                })
                              ),
                              toastId: r,
                              updateId: o,
                              data: f,
                              isIn: !1,
                              className: l(t.className || c.toastClassName),
                              progressClassName: l(
                                t.progressClassName || c.progressClassName
                              ),
                              autoClose:
                                !t.isLoading && u(t.autoClose, c.autoClose),
                              closeToast(e) {
                                (h.get(r).removalReason = e), v(r);
                              },
                              deleteToast() {
                                let e = h.get(r);
                                if (null != e) {
                                  if (
                                    (E(p(e, "removed")),
                                    h.delete(r),
                                    --s < 0 && (s = 0),
                                    a.length > 0)
                                  )
                                    return void _(a.shift());
                                  g();
                                }
                              },
                            };
                            (C.closeButton = c.closeButton),
                              !1 === t.closeButton || d(t.closeButton)
                                ? (C.closeButton = t.closeButton)
                                : !0 === t.closeButton &&
                                  (C.closeButton =
                                    !d(c.closeButton) || c.closeButton);
                            let A = { content: e, props: C, staleId: y };
                            c.limit && c.limit > 0 && s > c.limit && w
                              ? a.push(A)
                              : n(b)
                              ? setTimeout(() => {
                                  _(A);
                                }, b)
                              : _(A);
                          },
                          setProps(e) {
                            c = e;
                          },
                          setToggle: (e, t) => {
                            let r = h.get(e);
                            r && (r.toggle = t);
                          },
                          isToastActive: (e) => {
                            var t;
                            return null == (t = h.get(e)) ? void 0 : t.isActive;
                          },
                          getSnapshot: () => o,
                        });
                    b.set(r, C);
                    let A = C.observe(t);
                    return (
                      w.forEach((e) => I(e.content, e.options)),
                      (w = []),
                      () => {
                        A(), b.delete(r);
                      }
                    );
                  },
                  setProps(e) {
                    var t;
                    null == (t = b.get(r)) || t.setProps(e);
                  },
                  getSnapshot() {
                    var e;
                    return null == (e = b.get(r)) ? void 0 : e.getSnapshot();
                  },
                })
              ).current;
            o(e);
            let c =
              null == (t = (0, i.useSyncExternalStore)(s, a, a))
                ? void 0
                : t.slice();
            return {
              getToastToRender: function (t) {
                if (!c) return [];
                let r = new Map();
                return (
                  e.newestOnTop && c.reverse(),
                  c.forEach((e) => {
                    let { position: t } = e.props;
                    r.has(t) || r.set(t, []), r.get(t).push(e);
                  }),
                  Array.from(r, (e) => t(e[0], e[1]))
                );
              },
              isToastActive: A,
              count: null == c ? void 0 : c.length,
            };
          })(t),
          { className: y, style: v, rtl: _, containerId: C, hotKeys: S } = t;
        function N() {
          r && (c(!0), x.play());
        }
        return (
          P(() => {
            var e;
            if (r) {
              let r = h.current.querySelectorAll('[data-in="true"]'),
                i = null == (e = t.position) ? void 0 : e.includes("top"),
                s = 0,
                n = 0;
              Array.from(r)
                .reverse()
                .forEach((e, t) => {
                  e.classList.add("Toastify__toast--stacked"),
                    t > 0 && (e.dataset.collapsed = "".concat(a)),
                    e.dataset.pos || (e.dataset.pos = i ? "top" : "bot");
                  let r = s * (a ? 0.2 : 1) + (a ? 0 : 12 * t);
                  e.style.setProperty("--y", "".concat(i ? r : -1 * r, "px")),
                    e.style.setProperty("--g", "".concat(12)),
                    e.style.setProperty("--s", "".concat(1 - (a ? n : 0))),
                    (s += e.offsetHeight),
                    (n += 0.025);
                });
            }
          }, [a, m, r]),
          (0, i.useEffect)(() => {
            function e(e) {
              var t;
              let r = h.current;
              S(e) &&
                (null == (t = r.querySelector('[tabIndex="0"]')) || t.focus(),
                c(!1),
                x.pause()),
                "Escape" === e.key &&
                  (document.activeElement === r ||
                    (null != r && r.contains(document.activeElement))) &&
                  (c(!0), x.play());
            }
            return (
              document.addEventListener("keydown", e),
              () => {
                document.removeEventListener("keydown", e);
              }
            );
          }, [S]),
          i.createElement(
            "section",
            {
              ref: h,
              className: "Toastify",
              id: C,
              onMouseEnter: () => {
                r && (c(!1), x.pause());
              },
              onMouseLeave: N,
              "aria-live": "polite",
              "aria-atomic": "false",
              "aria-relevant": "additions text",
              "aria-label": t["aria-label"],
            },
            f((e, t) => {
              let n,
                a = t.length ? { ...v } : { ...v, pointerEvents: "none" };
              return i.createElement(
                "div",
                {
                  tabIndex: -1,
                  className:
                    ((n = s(
                      "Toastify__toast-container",
                      "Toastify__toast-container--".concat(e),
                      { "Toastify__toast-container--rtl": _ }
                    )),
                    o(y)
                      ? y({ position: e, rtl: _, defaultClassName: n })
                      : s(n, l(y))),
                  "data-stacked": r,
                  style: a,
                  key: "c-".concat(e),
                },
                t.map((e) => {
                  let { content: t, props: s } = e;
                  return i.createElement(
                    U,
                    {
                      ...s,
                      stacked: r,
                      collapseAll: N,
                      isIn: g(s.toastId, s.containerId),
                      key: "t-".concat(s.key),
                    },
                    t
                  );
                })
              );
            })
          )
        );
      }
    },
    87660: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => n });
      var i = r(34250),
        s = r(64997);
      function n(e, t) {
        let { onChange: r } = t;
        return e.subscribe(() => (0, s.s)(e), r, {
          equalityFn(e, t) {
            let { connector: r, ...s } = e,
              { connector: n, ...a } = t;
            return (0, i.b)(s, a) && r?.id === n?.id && r?.uid === n?.uid;
          },
        });
      }
    },
    89101: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      let i = r(86313);
      i.__exportStar(r(10351), t),
        i.__exportStar(r(31498), t),
        i.__exportStar(r(40347), t),
        i.__exportStar(r(64587), t);
    },
    90557: (e, t, r) => {
      "use strict";
      r.d(t, { Ci: () => a, J8: () => o, MU: () => c });
      var i = r(79183),
        s = r(7441),
        n = r(41514);
      class a extends s.C {
        constructor({
          body: e,
          cause: t,
          details: r,
          headers: s,
          status: a,
          url: o,
        }) {
          super("HTTP request failed.", {
            cause: t,
            details: r,
            metaMessages: [
              a && `Status: ${a}`,
              `URL: ${(0, n.I)(o)}`,
              e && `Request body: ${(0, i.A)(e)}`,
            ].filter(Boolean),
            name: "HttpRequestError",
          }),
            Object.defineProperty(this, "body", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "headers", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "status", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "url", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.body = e),
            (this.headers = s),
            (this.status = a),
            (this.url = o);
        }
      }
      s.C;
      class o extends s.C {
        constructor({ body: e, error: t, url: r }) {
          super("RPC Request failed.", {
            cause: t,
            details: t.message,
            metaMessages: [
              `URL: ${(0, n.I)(r)}`,
              `Request body: ${(0, i.A)(e)}`,
            ],
            name: "RpcRequestError",
          }),
            Object.defineProperty(this, "code", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "data", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.code = t.code),
            (this.data = t.data);
        }
      }
      s.C;
      class c extends s.C {
        constructor({ body: e, url: t }) {
          super("The request took too long to respond.", {
            details: "The request timed out.",
            metaMessages: [
              `URL: ${(0, n.I)(t)}`,
              `Request body: ${(0, i.A)(e)}`,
            ],
            name: "TimeoutError",
          });
        }
      }
    },
    90906: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => C });
      var i = r(43708),
        s = r(70799),
        n = r(26343),
        a = r(60500),
        o = r(76610),
        c = r(35558),
        l = r(5582),
        u = r(92555),
        d = r(11076),
        h = r(6193),
        p = r(54252),
        f = r(32836),
        g = r(33806),
        m = r(96641),
        y = r(36665),
        b = r(19628),
        w = r(68319);
      let v = {
          currentTab: 0,
          tokenBalance: [],
          smartAccountDeployed: !1,
          addressLabels: new Map(),
          allAccounts: [],
          user: void 0,
        },
        E = {
          caipNetwork: void 0,
          supportsAllNetworks: !0,
          smartAccountEnabledNetworks: [],
        },
        _ = (0, i.BX)({
          chains: (0, s.zC)(),
          activeCaipAddress: void 0,
          activeChain: void 0,
          activeCaipNetwork: void 0,
          noAdapters: !1,
          universalAdapter: {
            networkControllerClient: void 0,
            connectionControllerClient: void 0,
          },
          isSwitchingNamespace: !1,
        }),
        C = (0, u.X)({
          state: _,
          subscribe: (e) =>
            (0, i.B1)(_, () => {
              e(_);
            }),
          subscribeKey: (e, t) => (0, s.u$)(_, e, t),
          subscribeChainProp(e, t, r) {
            let s;
            return (0, i.B1)(_.chains, () => {
              let i = r || _.activeChain;
              if (i) {
                let r = _.chains.get(i)?.[e];
                s !== r && ((s = r), t(r));
              }
            });
          },
          initialize(e, t, r) {
            let { chainId: s, namespace: n } = l.i.getActiveNetworkProps(),
              a = t?.find((e) => e.id.toString() === s?.toString()),
              o = e.find((e) => e?.namespace === n) || e?.[0],
              c = e.map((e) => e.namespace).filter((e) => void 0 !== e),
              u = new Set(
                m.H.state.enableEmbedded
                  ? [...c]
                  : [...(t?.map((e) => e.chainNamespace) ?? [])]
              );
            (e?.length !== 0 && o) || (_.noAdapters = !0),
              !_.noAdapters &&
                ((_.activeChain = o?.namespace),
                (_.activeCaipNetwork = a),
                C.setChainNetworkData(o?.namespace, { caipNetwork: a }),
                _.activeChain && y.z.set({ activeChain: o?.namespace })),
              u.forEach((e) => {
                let s = t?.filter((t) => t.chainNamespace === e);
                C.state.chains.set(e, {
                  namespace: e,
                  networkState: (0, i.BX)({ ...E, caipNetwork: s?.[0] }),
                  accountState: (0, i.BX)(v),
                  caipNetworks: s ?? [],
                  ...r,
                }),
                  C.setRequestedCaipNetworks(s ?? [], e);
              });
          },
          removeAdapter(e) {
            if (_.activeChain === e) {
              let t = Array.from(_.chains.entries()).find(([t]) => t !== e);
              if (t) {
                let e = t[1]?.caipNetworks?.[0];
                e && C.setActiveCaipNetwork(e);
              }
            }
            _.chains.delete(e);
          },
          addAdapter(
            e,
            { networkControllerClient: t, connectionControllerClient: r },
            i
          ) {
            _.chains.set(e.namespace, {
              namespace: e.namespace,
              networkState: { ...E, caipNetwork: i[0] },
              accountState: v,
              caipNetworks: i,
              connectionControllerClient: r,
              networkControllerClient: t,
            }),
              C.setRequestedCaipNetworks(
                i?.filter((t) => t.chainNamespace === e.namespace) ?? [],
                e.namespace
              );
          },
          addNetwork(e) {
            let t = _.chains.get(e.chainNamespace);
            if (t) {
              let r = [...(t.caipNetworks || [])];
              t.caipNetworks?.find((t) => t.id === e.id) || r.push(e),
                _.chains.set(e.chainNamespace, { ...t, caipNetworks: r }),
                C.setRequestedCaipNetworks(r, e.chainNamespace),
                p.a.filterByNamespace(e.chainNamespace, !0);
            }
          },
          removeNetwork(e, t) {
            let r = _.chains.get(e);
            if (r) {
              let i = _.activeCaipNetwork?.id === t,
                s = [...(r.caipNetworks?.filter((e) => e.id !== t) || [])];
              i &&
                r?.caipNetworks?.[0] &&
                C.setActiveCaipNetwork(r.caipNetworks[0]),
                _.chains.set(e, { ...r, caipNetworks: s }),
                C.setRequestedCaipNetworks(s || [], e),
                0 === s.length && p.a.filterByNamespace(e, !1);
            }
          },
          setAdapterNetworkState(e, t) {
            let r = _.chains.get(e);
            r &&
              ((r.networkState = { ...(r.networkState || E), ...t }),
              _.chains.set(e, r));
          },
          setChainAccountData(e, t, r = !0) {
            if (!e)
              throw Error("Chain is required to update chain account data");
            let i = _.chains.get(e);
            if (i) {
              let r = { ...(i.accountState || v), ...t };
              _.chains.set(e, { ...i, accountState: r }),
                (1 === _.chains.size || _.activeChain === e) &&
                  (t.caipAddress && (_.activeCaipAddress = t.caipAddress),
                  d.U.replaceState(r));
            }
          },
          setChainNetworkData(e, t) {
            if (!e) return;
            let r = _.chains.get(e);
            if (r) {
              let i = { ...(r.networkState || E), ...t };
              _.chains.set(e, { ...r, networkState: i });
            }
          },
          setAccountProp(e, t, r, i = !0) {
            C.setChainAccountData(r, { [e]: t }, i),
              "status" === e &&
                "disconnected" === t &&
                r &&
                p.a.removeConnectorId(r);
          },
          setActiveNamespace(e) {
            _.activeChain = e;
            let t = e ? _.chains.get(e) : void 0,
              r = t?.networkState?.caipNetwork;
            r?.id &&
              e &&
              ((_.activeCaipAddress = t?.accountState?.caipAddress),
              (_.activeCaipNetwork = r),
              C.setChainNetworkData(e, { caipNetwork: r }),
              l.i.setActiveCaipNetworkId(r?.caipNetworkId),
              y.z.set({ activeChain: e, selectedNetworkId: r?.caipNetworkId }));
          },
          setActiveCaipNetwork(e) {
            if (!e) return;
            _.activeChain !== e.chainNamespace && C.setIsSwitchingNamespace(!0);
            let t = _.chains.get(e.chainNamespace);
            (_.activeChain = e.chainNamespace),
              (_.activeCaipNetwork = e),
              C.setChainNetworkData(e.chainNamespace, { caipNetwork: e }),
              t?.accountState?.address
                ? (_.activeCaipAddress = `${e.chainNamespace}:${e.id}:${t?.accountState?.address}`)
                : (_.activeCaipAddress = void 0),
              C.setAccountProp(
                "caipAddress",
                _.activeCaipAddress,
                e.chainNamespace
              ),
              t && d.U.replaceState(t.accountState),
              w.R.resetSend(),
              y.z.set({
                activeChain: _.activeChain,
                selectedNetworkId: _.activeCaipNetwork?.caipNetworkId,
              }),
              l.i.setActiveCaipNetworkId(e.caipNetworkId),
              C.checkIfSupportedNetwork(e.chainNamespace) ||
                !m.H.state.enableNetworkSwitch ||
                m.H.state.allowUnsupportedChain ||
                h.x.state.wcBasic ||
                C.showUnsupportedChainUI();
          },
          addCaipNetwork(e) {
            if (!e) return;
            let t = _.chains.get(e.chainNamespace);
            t && t?.caipNetworks?.push(e);
          },
          async switchActiveNamespace(e) {
            if (!e) return;
            let t = e !== C.state.activeChain,
              r = C.getNetworkData(e)?.caipNetwork,
              i = C.getCaipNetworkByNamespace(e, r?.id);
            t && i && (await C.switchActiveNetwork(i));
          },
          async switchActiveNetwork(e) {
            let t = C.state.chains.get(C.state.activeChain),
              r = !t?.caipNetworks?.some(
                (e) => e.id === _.activeCaipNetwork?.id
              ),
              i = C.getNetworkControllerClient(e.chainNamespace);
            if (i) {
              try {
                await i.switchCaipNetwork(e), r && g.W.close();
              } catch (e) {
                b.I.goBack();
              }
              f.E.sendEvent({
                type: "track",
                event: "SWITCH_NETWORK",
                properties: { network: e.caipNetworkId },
              });
            }
          },
          getNetworkControllerClient(e) {
            let t = e || _.activeChain,
              r = _.chains.get(t);
            if (!r) throw Error("Chain adapter not found");
            if (!r.networkControllerClient)
              throw Error("NetworkController client not set");
            return r.networkControllerClient;
          },
          getConnectionControllerClient(e) {
            let t = e || _.activeChain;
            if (!t)
              throw Error(
                "Chain is required to get connection controller client"
              );
            let r = _.chains.get(t);
            if (!r?.connectionControllerClient)
              throw Error("ConnectionController client not set");
            return r.connectionControllerClient;
          },
          getAccountProp(e, t) {
            let r = _.activeChain;
            if ((t && (r = t), !r)) return;
            let i = _.chains.get(r)?.accountState;
            if (i) return i[e];
          },
          getNetworkProp(e, t) {
            let r = _.chains.get(t)?.networkState;
            if (r) return r[e];
          },
          getRequestedCaipNetworks(e) {
            let t = _.chains.get(e),
              {
                approvedCaipNetworkIds: r = [],
                requestedCaipNetworks: i = [],
              } = t?.networkState || {};
            return c.w.sortRequestedNetworks(r, i);
          },
          getAllRequestedCaipNetworks() {
            let e = [];
            return (
              _.chains.forEach((t) => {
                let r = C.getRequestedCaipNetworks(t.namespace);
                e.push(...r);
              }),
              e
            );
          },
          setRequestedCaipNetworks(e, t) {
            C.setAdapterNetworkState(t, { requestedCaipNetworks: e });
            let r = Array.from(
              new Set(
                C.getAllRequestedCaipNetworks().map((e) => e.chainNamespace)
              )
            );
            p.a.filterByNamespaces(r);
          },
          getAllApprovedCaipNetworkIds() {
            let e = [];
            return (
              _.chains.forEach((t) => {
                let r = C.getApprovedCaipNetworkIds(t.namespace);
                e.push(...r);
              }),
              e
            );
          },
          getActiveCaipNetwork: () => _.activeCaipNetwork,
          getActiveCaipAddress: () => _.activeCaipAddress,
          getApprovedCaipNetworkIds(e) {
            let t = _.chains.get(e);
            return t?.networkState?.approvedCaipNetworkIds || [];
          },
          async setApprovedCaipNetworksData(e) {
            let t = C.getNetworkControllerClient(),
              r = await t?.getApprovedCaipNetworksData();
            C.setAdapterNetworkState(e, {
              approvedCaipNetworkIds: r?.approvedCaipNetworkIds,
              supportsAllNetworks: r?.supportsAllNetworks,
            });
          },
          checkIfSupportedNetwork(e, t) {
            let r = t || _.activeCaipNetwork,
              i = C.getRequestedCaipNetworks(e);
            return !i.length || i?.some((e) => e.id === r?.id);
          },
          checkIfSupportedChainId(e) {
            if (!_.activeChain) return !0;
            let t = C.getRequestedCaipNetworks(_.activeChain);
            return t?.some((t) => t.id === e);
          },
          setSmartAccountEnabledNetworks(e, t) {
            C.setAdapterNetworkState(t, { smartAccountEnabledNetworks: e });
          },
          checkIfSmartAccountEnabled() {
            let e = n.L.caipNetworkIdToNumber(
                _.activeCaipNetwork?.caipNetworkId
              ),
              t = _.activeChain;
            if (!t || !e) return !1;
            let r = C.getNetworkProp("smartAccountEnabledNetworks", t);
            return !!r?.includes(Number(e));
          },
          getActiveNetworkTokenAddress() {
            let e = _.activeCaipNetwork?.chainNamespace || "eip155",
              t = _.activeCaipNetwork?.id || 1,
              r = o.oU.NATIVE_TOKEN_ADDRESS[e];
            return `${e}:${t}:${r}`;
          },
          showUnsupportedChainUI() {
            g.W.open({ view: "UnsupportedChain" });
          },
          checkIfNamesSupported() {
            let e = _.activeCaipNetwork;
            return !!(
              e?.chainNamespace &&
              o.oU.NAMES_SUPPORTED_CHAIN_NAMESPACES.includes(e.chainNamespace)
            );
          },
          resetNetwork(e) {
            C.setAdapterNetworkState(e, {
              approvedCaipNetworkIds: void 0,
              supportsAllNetworks: !0,
              smartAccountEnabledNetworks: [],
            });
          },
          resetAccount(e) {
            if (!e) throw Error("Chain is required to set account prop");
            (_.activeCaipAddress = void 0),
              C.setChainAccountData(e, {
                smartAccountDeployed: !1,
                currentTab: 0,
                caipAddress: void 0,
                address: void 0,
                balance: void 0,
                balanceSymbol: void 0,
                profileName: void 0,
                profileImage: void 0,
                addressExplorerUrl: void 0,
                tokenBalance: [],
                connectedWalletInfo: void 0,
                preferredAccountTypes: void 0,
                socialProvider: void 0,
                socialWindow: void 0,
                farcasterUrl: void 0,
                allAccounts: [],
                user: void 0,
                status: "disconnected",
              }),
              p.a.removeConnectorId(e);
          },
          setIsSwitchingNamespace(e) {
            _.isSwitchingNamespace = e;
          },
          getFirstCaipNetworkSupportsAuthConnector() {
            let e,
              t = [];
            if (
              (_.chains.forEach((e) => {
                a.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.find(
                  (t) => t === e.namespace
                ) &&
                  e.namespace &&
                  t.push(e.namespace);
              }),
              t.length > 0)
            ) {
              let e = t[0];
              return e ? _.chains.get(e)?.caipNetworks?.[0] : void 0;
            }
          },
          getAccountData: (e) =>
            e ? C.state.chains.get(e)?.accountState : d.U.state,
          getNetworkData(e) {
            let t = e || _.activeChain;
            if (t) return C.state.chains.get(t)?.networkState;
          },
          getCaipNetworkByNamespace(e, t) {
            if (!e) return;
            let r = C.state.chains.get(e),
              i = r?.caipNetworks?.find((e) => e.id === t);
            return i || r?.networkState?.caipNetwork || r?.caipNetworks?.[0];
          },
          getRequestedCaipNetworkIds() {
            let e = p.a.state.filterByNamespace;
            return (e ? [_.chains.get(e)] : Array.from(_.chains.values()))
              .flatMap((e) => e?.caipNetworks || [])
              .map((e) => e.caipNetworkId);
          },
          getCaipNetworks: (e) =>
            e ? C.getRequestedCaipNetworks(e) : C.getAllRequestedCaipNetworks(),
        });
    },
    91203: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      let i = r(96595);
      i.__exportStar(r(55252), t), i.__exportStar(r(7488), t);
    },
    91281: (e, t, r) => {
      "use strict";
      function i(e) {
        if (!Number.isSafeInteger(e) || e < 0)
          throw Error("positive integer expected, got " + e);
      }
      function s(e, ...t) {
        if (
          !(
            e instanceof Uint8Array ||
            (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
          )
        )
          throw Error("Uint8Array expected");
        if (t.length > 0 && !t.includes(e.length))
          throw Error(
            "Uint8Array expected of length " + t + ", got length=" + e.length
          );
      }
      function n(e) {
        if ("function" != typeof e || "function" != typeof e.create)
          throw Error("Hash should be wrapped by utils.wrapConstructor");
        i(e.outputLen), i(e.blockLen);
      }
      function a(e, t = !0) {
        if (e.destroyed) throw Error("Hash instance has been destroyed");
        if (t && e.finished)
          throw Error("Hash#digest() has already been called");
      }
      function o(e, t) {
        s(e);
        let r = t.outputLen;
        if (e.length < r)
          throw Error(
            "digestInto() expects output buffer of length at least " + r
          );
      }
      r.d(t, {
        CC: () => a,
        DO: () => s,
        Fe: () => i,
        Ht: () => o,
        sd: () => n,
      });
    },
    92555: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => h, X: () => f });
      var i = r(43708),
        s = r(70799),
        n = r(35558),
        a = r(43359),
        o = r(96641);
      let c = Object.freeze({ enabled: !0, events: [] }),
        l = new a.Z({ baseUrl: n.w.getAnalyticsUrl(), clientId: null }),
        u = (0, i.BX)({ ...c }),
        d = {
          state: u,
          subscribeKey: (e, t) => (0, s.u$)(u, e, t),
          async sendError(e, t) {
            if (!u.enabled) return;
            let r = Date.now();
            if (
              u.events.filter(
                (e) =>
                  r - new Date(e.properties.timestamp || "").getTime() < 6e4
              ).length >= 5
            )
              return;
            let i = {
              type: "error",
              event: t,
              properties: {
                errorType: e.name,
                errorMessage: e.message,
                stackTrace: e.stack,
                timestamp: new Date().toISOString(),
              },
            };
            u.events.push(i);
            try {
              if ("undefined" == typeof window) return;
              let { projectId: r, sdkType: i, sdkVersion: s } = o.H.state;
              await l.post({
                path: "/e",
                params: { projectId: r, st: i, sv: s || "html-wagmi-4.2.2" },
                body: {
                  eventId: n.w.getUUID(),
                  url: window.location.href,
                  domain: window.location.hostname,
                  timestamp: new Date().toISOString(),
                  props: {
                    type: "error",
                    event: t,
                    errorType: e.name,
                    errorMessage: e.message,
                    stackTrace: e.stack,
                  },
                },
              });
            } catch {}
          },
          enable() {
            u.enabled = !0;
          },
          disable() {
            u.enabled = !1;
          },
          clearEvents() {
            u.events = [];
          },
        };
      class h extends Error {
        constructor(e, t, r) {
          super(e),
            (this.name = "AppKitError"),
            (this.category = t),
            (this.originalError = r),
            Object.setPrototypeOf(this, h.prototype);
          let i = !1;
          if (r instanceof Error && "string" == typeof r.stack && r.stack) {
            let e = r.stack,
              t = e.indexOf("\n");
            if (t > -1) {
              let r = e.substring(t + 1);
              (this.stack = `${this.name}: ${this.message}
${r}`),
                (i = !0);
            }
          }
          !i &&
            (Error.captureStackTrace
              ? Error.captureStackTrace(this, h)
              : this.stack || (this.stack = `${this.name}: ${this.message}`));
        }
      }
      function p(e, t) {
        let r =
          e instanceof h
            ? e
            : new h(e instanceof Error ? e.message : String(e), t, e);
        throw (d.sendError(r, r.category), r);
      }
      function f(e, t = "INTERNAL_SDK_ERROR") {
        let r = {};
        return (
          Object.keys(e).forEach((i) => {
            let s = e[i];
            if ("function" == typeof s) {
              let e = s;
              (e =
                "AsyncFunction" === s.constructor.name
                  ? async (...e) => {
                      try {
                        return await s(...e);
                      } catch (e) {
                        return p(e, t);
                      }
                    }
                  : (...e) => {
                      try {
                        return s(...e);
                      } catch (e) {
                        return p(e, t);
                      }
                    }),
                (r[i] = e);
            } else r[i] = s;
          }),
          r
        );
      }
    },
    93813: (e, t, r) => {
      "use strict";
      r.d(t, { L: () => n });
      var i = r(60500),
        s = r(99836);
      let n = {
        ConnectorExplorerIds: {
          [i.o.CONNECTOR_ID.COINBASE]:
            "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
          [i.o.CONNECTOR_ID.COINBASE_SDK]:
            "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
          [i.o.CONNECTOR_ID.SAFE]:
            "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
          [i.o.CONNECTOR_ID.LEDGER]:
            "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927",
          [i.o.CONNECTOR_ID.OKX]:
            "971e689d0a5be527bac79629b4ee9b925e82208e5168b733496a09c0faed0709",
          [s.o.METMASK_CONNECTOR_NAME]:
            "c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96",
          [s.o.TRUST_CONNECTOR_NAME]:
            "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0",
          [s.o.SOLFLARE_CONNECTOR_NAME]:
            "1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79",
          [s.o.PHANTOM_CONNECTOR_NAME]:
            "a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393",
          [s.o.COIN98_CONNECTOR_NAME]:
            "2a3c89040ac3b723a1972a33a125b1db11e258a6975d3a61252cd64e6ea5ea01",
          [s.o.MAGIC_EDEN_CONNECTOR_NAME]:
            "8b830a2b724a9c3fbab63af6f55ed29c9dfa8a55e732dc88c80a196a2ba136c6",
          [s.o.BACKPACK_CONNECTOR_NAME]:
            "2bd8c14e035c2d48f184aaa168559e86b0e3433228d3c4075900a221785019b0",
          [s.o.BITGET_CONNECTOR_NAME]:
            "38f5d18bd8522c244bdd70cb4a68e0e718865155811c043f052fb9f1c51de662",
          [s.o.FRONTIER_CONNECTOR_NAME]:
            "85db431492aa2e8672e93f4ea7acf10c88b97b867b0d373107af63dc4880f041",
          [s.o.XVERSE_CONNECTOR_NAME]:
            "2a87d74ae02e10bdd1f51f7ce6c4e1cc53cd5f2c0b6b5ad0d7b3007d2b13de7b",
          [s.o.LEATHER_CONNECTOR_NAME]:
            "483afe1df1df63daf313109971ff3ef8356ddf1cc4e45877d205eee0b7893a13",
        },
        NetworkImageIds: {
          1: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
          42161: "3bff954d-5cb0-47a0-9a23-d20192e74600",
          43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
          56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
          250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
          10: "ab9c186a-c52f-464b-2906-ca59d760a400",
          137: "41d04d42-da3b-4453-8506-668cc0727900",
          5e3: "e86fae9b-b770-4eea-e520-150e12c81100",
          295: "6a97d510-cac8-4e58-c7ce-e8681b044c00",
          0xaa36a7: "e909ea0a-f92a-4512-c8fc-748044ea6800",
          84532: "a18a7ecd-e307-4360-4746-283182228e00",
          1301: "4eeea7ef-0014-4649-5d1d-07271a80f600",
          130: "2257980a-3463-48c6-cbac-a42d2a956e00",
          10143: "0a728e83-bacb-46db-7844-948f05434900",
          100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
          9001: "f926ff41-260d-4028-635e-91913fc28e00",
          324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
          314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
          4689: "34e68754-e536-40da-c153-6ef2e7188a00",
          1088: "3897a66d-40b9-4833-162f-a2c90531c900",
          1284: "161038da-44ae-4ec7-1208-0ea569454b00",
          1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
          7777777: "845c60df-d429-4991-e687-91ae45791600",
          42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
          8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
          0x4e454152: "3ff73439-a619-4894-9262-4470c773a100",
          2020: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
          2021: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
          80094: "e329c2c9-59b0-4a02-83e4-212ff3779900",
          2741: "fc2427d1-5af9-4a9c-8da5-6f94627cd900",
          "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp":
            "a1b58899-f671-4276-6a5e-56ca5bd59700",
          "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z":
            "a1b58899-f671-4276-6a5e-56ca5bd59700",
          EtWTRABZaYq6iMfeYKouRu166VU2xqa1:
            "a1b58899-f671-4276-6a5e-56ca5bd59700",
          "000000000019d6689c085ae165831e93":
            "0b4838db-0161-4ffe-022d-532bf03dba00",
          "000000000933ea01ad0ee984209779ba":
            "39354064-d79b-420b-065d-f980c4b78200",
        },
        ConnectorImageIds: {
          [i.o.CONNECTOR_ID.COINBASE]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
          [i.o.CONNECTOR_ID.COINBASE_SDK]:
            "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
          [i.o.CONNECTOR_ID.SAFE]: "461db637-8616-43ce-035a-d89b8a1d5800",
          [i.o.CONNECTOR_ID.LEDGER]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
          [i.o.CONNECTOR_ID.WALLET_CONNECT]:
            "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
          [i.o.CONNECTOR_ID.INJECTED]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00",
        },
        ConnectorNamesMap: {
          [i.o.CONNECTOR_ID.INJECTED]: "Browser Wallet",
          [i.o.CONNECTOR_ID.WALLET_CONNECT]: "WalletConnect",
          [i.o.CONNECTOR_ID.COINBASE]: "Coinbase",
          [i.o.CONNECTOR_ID.COINBASE_SDK]: "Coinbase",
          [i.o.CONNECTOR_ID.LEDGER]: "Ledger",
          [i.o.CONNECTOR_ID.SAFE]: "Safe",
        },
        ConnectorTypesMap: {
          [i.o.CONNECTOR_ID.INJECTED]: "INJECTED",
          [i.o.CONNECTOR_ID.WALLET_CONNECT]: "WALLET_CONNECT",
          [i.o.CONNECTOR_ID.EIP6963]: "ANNOUNCED",
          [i.o.CONNECTOR_ID.AUTH]: "AUTH",
        },
        WalletConnectRpcChainIds: [
          1, 5, 0xaa36a7, 10, 420, 42161, 421613, 137, 80001, 42220, 0x4e454152,
          0x4e454153, 56, 97, 43114, 43113, 100, 8453, 84531, 7777777, 999, 324,
          280,
        ],
      };
    },
    94201: (e, t, r) => {
      "use strict";
      r.d(t, { Ty: () => s, u: () => a, xO: () => n });
      var i = r(7441);
      class s extends i.C {
        constructor({ max: e, min: t, signed: r, size: i, value: s }) {
          super(
            `Number "${s}" is not in safe ${
              i ? `${8 * i}-bit ${r ? "signed" : "unsigned"} ` : ""
            }integer range ${e ? `(${t} to ${e})` : `(above ${t})`}`,
            { name: "IntegerOutOfRangeError" }
          );
        }
      }
      class n extends i.C {
        constructor(e) {
          super(
            `Bytes value "${e}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,
            { name: "InvalidBytesBooleanError" }
          );
        }
      }
      i.C, i.C;
      class a extends i.C {
        constructor({ givenSize: e, maxSize: t }) {
          super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`, {
            name: "SizeOverflowError",
          });
        }
      }
    },
    95782: (e, t, r) => {
      "use strict";
      r.d(t, { C: () => c });
      var i,
        s,
        n = r(40194);
      let a = () => `@wagmi/core@${n.r}`;
      var o = function (e, t, r, i) {
        if ("a" === r && !i)
          throw TypeError("Private accessor was defined without a getter");
        if ("function" == typeof t ? e !== t || !i : !t.has(e))
          throw TypeError(
            "Cannot read private member from an object whose class did not declare it"
          );
        return "m" === r ? i : "a" === r ? i.call(e) : i ? i.value : t.get(e);
      };
      class c extends Error {
        get docsBaseUrl() {
          return "https://wagmi.sh/core";
        }
        get version() {
          return a();
        }
        constructor(e, t = {}) {
          super(),
            i.add(this),
            Object.defineProperty(this, "details", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "docsPath", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "metaMessages", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "shortMessage", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "WagmiCoreError",
            });
          let r =
              t.cause instanceof c
                ? t.cause.details
                : t.cause?.message
                ? t.cause.message
                : t.details,
            s = (t.cause instanceof c && t.cause.docsPath) || t.docsPath;
          (this.message = [
            e || "An error occurred.",
            "",
            ...(t.metaMessages ? [...t.metaMessages, ""] : []),
            ...(s
              ? [
                  `Docs: ${this.docsBaseUrl}${s}.html${
                    t.docsSlug ? `#${t.docsSlug}` : ""
                  }`,
                ]
              : []),
            ...(r ? [`Details: ${r}`] : []),
            `Version: ${this.version}`,
          ].join("\n")),
            t.cause && (this.cause = t.cause),
            (this.details = r),
            (this.docsPath = s),
            (this.metaMessages = t.metaMessages),
            (this.shortMessage = e);
        }
        walk(e) {
          return o(this, i, "m", s).call(this, this, e);
        }
      }
      (i = new WeakSet()),
        (s = function e(t, r) {
          return r?.(t)
            ? t
            : t.cause
            ? o(this, i, "m", e).call(this, t.cause, r)
            : t;
        });
    },
    95842: (e, t, r) => {
      "use strict";
      r.d(t, { g: () => p });
      var i = r(60500),
        s = r(96641),
        n = r(5582),
        a = r(65819),
        o = r(35558),
        c = r(6193),
        l = r(90906),
        u = r(54252),
        d = r(23140),
        h = r(98782);
      let p = {
        getConnectorsByType(e, t, r) {
          let { customWallets: i } = s.H.state,
            a = n.i.getRecentWallets(),
            o = h.A.filterOutDuplicateWallets(t),
            c = h.A.filterOutDuplicateWallets(r),
            l = e.filter((e) => "MULTI_CHAIN" === e.type),
            u = e.filter((e) => "ANNOUNCED" === e.type),
            d = e.filter((e) => "INJECTED" === e.type);
          return {
            custom: i,
            recent: a,
            external: e.filter((e) => "EXTERNAL" === e.type),
            multiChain: l,
            announced: u,
            injected: d,
            recommended: o,
            featured: c,
          };
        },
        showConnector(e) {
          let t = e.info?.rdns,
            r =
              !!t &&
              a.N.state.excludedWallets.some((e) => !!e.rdns && e.rdns === t),
            i =
              !!e.name &&
              a.N.state.excludedWallets.some((t) =>
                d.y.isLowerCaseMatch(t.name, e.name)
              );
          if (
            "INJECTED" === e.type &&
            (("Browser Wallet" === e.name &&
              (!o.w.isMobile() ||
                (o.w.isMobile() && !t && !c.x.checkInstalled()))) ||
              r ||
              i)
          )
            return !1;
          return (
            ("ANNOUNCED" !== e.type && "EXTERNAL" !== e.type) || (!r && !i)
          );
        },
        getIsConnectedWithWC: () =>
          Array.from(l.W.state.chains.values()).some(
            (e) =>
              u.a.getConnectorId(e.namespace) ===
              i.o.CONNECTOR_ID.WALLET_CONNECT
          ),
        getConnectorTypeOrder({
          recommended: e,
          featured: t,
          custom: r,
          recent: i,
          announced: n,
          injected: a,
          multiChain: o,
          external: c,
          overriddenConnectors: l = s.H.state.features?.connectorTypeOrder ??
            [],
        }) {
          let u = p.getIsConnectedWithWC(),
            d = [
              {
                type: "walletConnect",
                isEnabled: s.H.state.enableWalletConnect && !u,
              },
              { type: "recent", isEnabled: i.length > 0 },
              { type: "injected", isEnabled: [...a, ...n, ...o].length > 0 },
              { type: "featured", isEnabled: t.length > 0 },
              { type: "custom", isEnabled: r && r.length > 0 },
              { type: "external", isEnabled: c.length > 0 },
              { type: "recommended", isEnabled: e.length > 0 },
            ].filter((e) => e.isEnabled),
            h = new Set(d.map((e) => e.type)),
            f = l
              .filter((e) => h.has(e))
              .map((e) => ({ type: e, isEnabled: !0 })),
            g = d.filter(({ type: e }) => !f.some(({ type: t }) => t === e));
          return Array.from(new Set([...f, ...g].map(({ type: e }) => e)));
        },
      };
    },
    95990: (e, t, r) => {
      "use strict";
      r.d(t, { r: () => c });
      var i = r(98078),
        s = r(54315),
        n = r(19405),
        a = r(35883),
        o = r(77752);
      async function c(e, t = {}) {
        let r;
        if (t.connector) {
          let { connector: i } = t;
          if (
            "reconnecting" === e.state.status &&
            !i.getAccounts &&
            !i.getChainId
          )
            throw new o.HF({ connector: i });
          let [s, n] = await Promise.all([
            i.getAccounts().catch((e) => {
              if (null === t.account) return [];
              throw e;
            }),
            i.getChainId(),
          ]);
          r = { accounts: s, chainId: n, connector: i };
        } else r = e.state.connections.get(e.state.current);
        if (!r) throw new o.gC();
        let l = t.chainId ?? r.chainId,
          u = await r.connector.getChainId();
        if (u !== r.chainId)
          throw new o.xU({ connectionChainId: r.chainId, connectorChainId: u });
        let d = r.connector;
        if (d.getClient) return d.getClient({ chainId: l });
        let h = (0, n.J)(t.account ?? r.accounts[0]);
        if (
          (h && (h.address = (0, a.b)(h.address)),
          t.account &&
            !r.accounts.some(
              (e) => e.toLowerCase() === h.address.toLowerCase()
            ))
        )
          throw new o.aj({ address: h.address, connector: d });
        let p = e.chains.find((e) => e.id === l),
          f = await r.connector.getProvider({ chainId: l });
        return (0, i.U)({
          account: h,
          chain: p,
          name: "Connector Client",
          transport: (e) =>
            (function (e, t = {}) {
              let {
                key: r = "custom",
                methods: i,
                name: n = "Custom Provider",
                retryDelay: a,
              } = t;
              return ({ retryCount: o }) =>
                (0, s.o)({
                  key: r,
                  methods: i,
                  name: n,
                  request: e.request.bind(e),
                  retryCount: t.retryCount ?? o,
                  retryDelay: a,
                  type: "custom",
                });
            })(f)({ ...e, retryCount: 0 }),
        });
      }
    },
    96595: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          __assign: () => n,
          __asyncDelegator: () => v,
          __asyncGenerator: () => w,
          __asyncValues: () => E,
          __await: () => b,
          __awaiter: () => u,
          __classPrivateFieldGet: () => I,
          __classPrivateFieldSet: () => S,
          __createBinding: () => h,
          __decorate: () => o,
          __exportStar: () => p,
          __extends: () => s,
          __generator: () => d,
          __importDefault: () => A,
          __importStar: () => C,
          __makeTemplateObject: () => _,
          __metadata: () => l,
          __param: () => c,
          __read: () => g,
          __rest: () => a,
          __spread: () => m,
          __spreadArrays: () => y,
          __values: () => f,
        });
      var i = function (e, t) {
        return (i =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (e, t) {
              e.__proto__ = t;
            }) ||
          function (e, t) {
            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r]);
          })(e, t);
      };
      function s(e, t) {
        function r() {
          this.constructor = e;
        }
        i(e, t),
          (e.prototype =
            null === t
              ? Object.create(t)
              : ((r.prototype = t.prototype), new r()));
      }
      var n = function () {
        return (n =
          Object.assign ||
          function (e) {
            for (var t, r = 1, i = arguments.length; r < i; r++)
              for (var s in (t = arguments[r]))
                Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
            return e;
          }).apply(this, arguments);
      };
      function a(e, t) {
        var r = {};
        for (var i in e)
          Object.prototype.hasOwnProperty.call(e, i) &&
            0 > t.indexOf(i) &&
            (r[i] = e[i]);
        if (null != e && "function" == typeof Object.getOwnPropertySymbols)
          for (
            var s = 0, i = Object.getOwnPropertySymbols(e);
            s < i.length;
            s++
          )
            0 > t.indexOf(i[s]) &&
              Object.prototype.propertyIsEnumerable.call(e, i[s]) &&
              (r[i[s]] = e[i[s]]);
        return r;
      }
      function o(e, t, r, i) {
        var s,
          n = arguments.length,
          a =
            n < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (s = e[o]) &&
              (a = (n < 3 ? s(a) : n > 3 ? s(t, r, a) : s(t, r)) || a);
        return n > 3 && a && Object.defineProperty(t, r, a), a;
      }
      function c(e, t) {
        return function (r, i) {
          t(r, i, e);
        };
      }
      function l(e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
          return Reflect.metadata(e, t);
      }
      function u(e, t, r, i) {
        return new (r || (r = Promise))(function (s, n) {
          function a(e) {
            try {
              c(i.next(e));
            } catch (e) {
              n(e);
            }
          }
          function o(e) {
            try {
              c(i.throw(e));
            } catch (e) {
              n(e);
            }
          }
          function c(e) {
            var t;
            e.done
              ? s(e.value)
              : ((t = e.value) instanceof r
                  ? t
                  : new r(function (e) {
                      e(t);
                    })
                ).then(a, o);
          }
          c((i = i.apply(e, t || [])).next());
        });
      }
      function d(e, t) {
        var r,
          i,
          s,
          n,
          a = {
            label: 0,
            sent: function () {
              if (1 & s[0]) throw s[1];
              return s[1];
            },
            trys: [],
            ops: [],
          };
        return (
          (n = { next: o(0), throw: o(1), return: o(2) }),
          "function" == typeof Symbol &&
            (n[Symbol.iterator] = function () {
              return this;
            }),
          n
        );
        function o(n) {
          return function (o) {
            var c = [n, o];
            if (r) throw TypeError("Generator is already executing.");
            for (; a; )
              try {
                if (
                  ((r = 1),
                  i &&
                    (s =
                      2 & c[0]
                        ? i.return
                        : c[0]
                        ? i.throw || ((s = i.return) && s.call(i), 0)
                        : i.next) &&
                    !(s = s.call(i, c[1])).done)
                )
                  return s;
                switch (((i = 0), s && (c = [2 & c[0], s.value]), c[0])) {
                  case 0:
                  case 1:
                    s = c;
                    break;
                  case 4:
                    return a.label++, { value: c[1], done: !1 };
                  case 5:
                    a.label++, (i = c[1]), (c = [0]);
                    continue;
                  case 7:
                    (c = a.ops.pop()), a.trys.pop();
                    continue;
                  default:
                    if (
                      !(s = (s = a.trys).length > 0 && s[s.length - 1]) &&
                      (6 === c[0] || 2 === c[0])
                    ) {
                      a = 0;
                      continue;
                    }
                    if (3 === c[0] && (!s || (c[1] > s[0] && c[1] < s[3]))) {
                      a.label = c[1];
                      break;
                    }
                    if (6 === c[0] && a.label < s[1]) {
                      (a.label = s[1]), (s = c);
                      break;
                    }
                    if (s && a.label < s[2]) {
                      (a.label = s[2]), a.ops.push(c);
                      break;
                    }
                    s[2] && a.ops.pop(), a.trys.pop();
                    continue;
                }
                c = t.call(e, a);
              } catch (e) {
                (c = [6, e]), (i = 0);
              } finally {
                r = s = 0;
              }
            if (5 & c[0]) throw c[1];
            return { value: c[0] ? c[1] : void 0, done: !0 };
          };
        }
      }
      function h(e, t, r, i) {
        void 0 === i && (i = r), (e[i] = t[r]);
      }
      function p(e, t) {
        for (var r in e)
          "default" === r || t.hasOwnProperty(r) || (t[r] = e[r]);
      }
      function f(e) {
        var t = "function" == typeof Symbol && Symbol.iterator,
          r = t && e[t],
          i = 0;
        if (r) return r.call(e);
        if (e && "number" == typeof e.length)
          return {
            next: function () {
              return (
                e && i >= e.length && (e = void 0),
                { value: e && e[i++], done: !e }
              );
            },
          };
        throw TypeError(
          t ? "Object is not iterable." : "Symbol.iterator is not defined."
        );
      }
      function g(e, t) {
        var r = "function" == typeof Symbol && e[Symbol.iterator];
        if (!r) return e;
        var i,
          s,
          n = r.call(e),
          a = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(i = n.next()).done; )
            a.push(i.value);
        } catch (e) {
          s = { error: e };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (s) throw s.error;
          }
        }
        return a;
      }
      function m() {
        for (var e = [], t = 0; t < arguments.length; t++)
          e = e.concat(g(arguments[t]));
        return e;
      }
      function y() {
        for (var e = 0, t = 0, r = arguments.length; t < r; t++)
          e += arguments[t].length;
        for (var i = Array(e), s = 0, t = 0; t < r; t++)
          for (var n = arguments[t], a = 0, o = n.length; a < o; a++, s++)
            i[s] = n[a];
        return i;
      }
      function b(e) {
        return this instanceof b ? ((this.v = e), this) : new b(e);
      }
      function w(e, t, r) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var i,
          s = r.apply(e, t || []),
          n = [];
        return (
          (i = {}),
          a("next"),
          a("throw"),
          a("return"),
          (i[Symbol.asyncIterator] = function () {
            return this;
          }),
          i
        );
        function a(e) {
          s[e] &&
            (i[e] = function (t) {
              return new Promise(function (r, i) {
                n.push([e, t, r, i]) > 1 || o(e, t);
              });
            });
        }
        function o(e, t) {
          try {
            var r;
            (r = s[e](t)).value instanceof b
              ? Promise.resolve(r.value.v).then(c, l)
              : u(n[0][2], r);
          } catch (e) {
            u(n[0][3], e);
          }
        }
        function c(e) {
          o("next", e);
        }
        function l(e) {
          o("throw", e);
        }
        function u(e, t) {
          e(t), n.shift(), n.length && o(n[0][0], n[0][1]);
        }
      }
      function v(e) {
        var t, r;
        return (
          (t = {}),
          i("next"),
          i("throw", function (e) {
            throw e;
          }),
          i("return"),
          (t[Symbol.iterator] = function () {
            return this;
          }),
          t
        );
        function i(i, s) {
          t[i] = e[i]
            ? function (t) {
                return (r = !r)
                  ? { value: b(e[i](t)), done: "return" === i }
                  : s
                  ? s(t)
                  : t;
              }
            : s;
        }
      }
      function E(e) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var t,
          r = e[Symbol.asyncIterator];
        return r
          ? r.call(e)
          : ((e = f(e)),
            (t = {}),
            i("next"),
            i("throw"),
            i("return"),
            (t[Symbol.asyncIterator] = function () {
              return this;
            }),
            t);
        function i(r) {
          t[r] =
            e[r] &&
            function (t) {
              return new Promise(function (i, s) {
                var n, a, o;
                (n = i),
                  (a = s),
                  (o = (t = e[r](t)).done),
                  Promise.resolve(t.value).then(function (e) {
                    n({ value: e, done: o });
                  }, a);
              });
            };
        }
      }
      function _(e, t) {
        return (
          Object.defineProperty
            ? Object.defineProperty(e, "raw", { value: t })
            : (e.raw = t),
          e
        );
      }
      function C(e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e)
          for (var r in e) Object.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return (t.default = e), t;
      }
      function A(e) {
        return e && e.__esModule ? e : { default: e };
      }
      function I(e, t) {
        if (!t.has(e))
          throw TypeError("attempted to get private field on non-instance");
        return t.get(e);
      }
      function S(e, t, r) {
        if (!t.has(e))
          throw TypeError("attempted to set private field on non-instance");
        return t.set(e, r), r;
      }
    },
    96641: (e, t, r) => {
      "use strict";
      r.d(t, { H: () => l });
      var i = r(43708),
        s = r(70799),
        n = r(76610),
        a = r(35558);
      let o = {
          getFeatureValue(e, t) {
            let r = t?.[e];
            return void 0 === r ? n.oU.DEFAULT_FEATURES[e] : r;
          },
          filterSocialsByPlatform(e) {
            if (!e || !e.length) return e;
            if (a.w.isTelegram()) {
              if (a.w.isIos()) return e.filter((e) => "google" !== e);
              if (a.w.isMac()) return e.filter((e) => "x" !== e);
              if (a.w.isAndroid())
                return e.filter((e) => !["facebook", "x"].includes(e));
            }
            return e;
          },
        },
        c = (0, i.BX)({
          features: n.oU.DEFAULT_FEATURES,
          projectId: "",
          sdkType: "appkit",
          sdkVersion: "html-wagmi-undefined",
          defaultAccountTypes: n.oU.DEFAULT_ACCOUNT_TYPES,
          enableNetworkSwitch: !0,
          experimental_preferUniversalLinks: !1,
          remoteFeatures: {},
        }),
        l = {
          state: c,
          subscribeKey: (e, t) => (0, s.u$)(c, e, t),
          setOptions(e) {
            Object.assign(c, e);
          },
          setRemoteFeatures(e) {
            if (!e) return;
            let t = { ...c.remoteFeatures, ...e };
            (c.remoteFeatures = t),
              c.remoteFeatures?.socials &&
                (c.remoteFeatures.socials = o.filterSocialsByPlatform(
                  c.remoteFeatures.socials
                ));
          },
          setFeatures(e) {
            if (!e) return;
            c.features || (c.features = n.oU.DEFAULT_FEATURES);
            let t = { ...c.features, ...e };
            c.features = t;
          },
          setProjectId(e) {
            c.projectId = e;
          },
          setCustomRpcUrls(e) {
            c.customRpcUrls = e;
          },
          setAllWallets(e) {
            c.allWallets = e;
          },
          setIncludeWalletIds(e) {
            c.includeWalletIds = e;
          },
          setExcludeWalletIds(e) {
            c.excludeWalletIds = e;
          },
          setFeaturedWalletIds(e) {
            c.featuredWalletIds = e;
          },
          setTokens(e) {
            c.tokens = e;
          },
          setTermsConditionsUrl(e) {
            c.termsConditionsUrl = e;
          },
          setPrivacyPolicyUrl(e) {
            c.privacyPolicyUrl = e;
          },
          setCustomWallets(e) {
            c.customWallets = e;
          },
          setIsSiweEnabled(e) {
            c.isSiweEnabled = e;
          },
          setIsUniversalProvider(e) {
            c.isUniversalProvider = e;
          },
          setSdkVersion(e) {
            c.sdkVersion = e;
          },
          setMetadata(e) {
            c.metadata = e;
          },
          setDisableAppend(e) {
            c.disableAppend = e;
          },
          setEIP6963Enabled(e) {
            c.enableEIP6963 = e;
          },
          setDebug(e) {
            c.debug = e;
          },
          setEnableWalletConnect(e) {
            c.enableWalletConnect = e;
          },
          setEnableWalletGuide(e) {
            c.enableWalletGuide = e;
          },
          setEnableAuthLogger(e) {
            c.enableAuthLogger = e;
          },
          setEnableWallets(e) {
            c.enableWallets = e;
          },
          setPreferUniversalLinks(e) {
            c.experimental_preferUniversalLinks = e;
          },
          setHasMultipleAddresses(e) {
            c.hasMultipleAddresses = e;
          },
          setSIWX(e) {
            c.siwx = e;
          },
          setConnectMethodsOrder(e) {
            c.features = { ...c.features, connectMethodsOrder: e };
          },
          setWalletFeaturesOrder(e) {
            c.features = { ...c.features, walletFeaturesOrder: e };
          },
          setSocialsOrder(e) {
            c.remoteFeatures = { ...c.remoteFeatures, socials: e };
          },
          setCollapseWallets(e) {
            c.features = { ...c.features, collapseWallets: e };
          },
          setEnableEmbedded(e) {
            c.enableEmbedded = e;
          },
          setAllowUnsupportedChain(e) {
            c.allowUnsupportedChain = e;
          },
          setManualWCControl(e) {
            c.manualWCControl = e;
          },
          setEnableNetworkSwitch(e) {
            c.enableNetworkSwitch = e;
          },
          setDefaultAccountTypes(e = {}) {
            Object.entries(e).forEach(([e, t]) => {
              t && (c.defaultAccountTypes[e] = t);
            });
          },
          setUniversalProviderConfigOverride(e) {
            c.universalProviderConfigOverride = e;
          },
          getUniversalProviderConfigOverride: () =>
            c.universalProviderConfigOverride,
          getSnapshot: () => (0, i.P9)(c),
        };
    },
    97265: (e, t, r) => {
      "use strict";
      let i, s, n;
      r.d(t, {
        JX: () => l,
        RF: () => c,
        W5: () => h,
        ck: () => f,
        ds: () => u,
        fD: () => p,
      });
      var a = r(28312),
        o = r(22492);
      function c(e, t) {
        (i = document.createElement("style")),
          (s = document.createElement("style")),
          (n = document.createElement("style")),
          (i.textContent = d(e).core.cssText),
          (s.textContent = d(e).dark.cssText),
          (n.textContent = d(e).light.cssText),
          document.head.appendChild(i),
          document.head.appendChild(s),
          document.head.appendChild(n),
          l(t);
      }
      function l(e) {
        s &&
          n &&
          ("light" === e
            ? (s.removeAttribute("media"), (n.media = "enabled"))
            : (n.removeAttribute("media"), (s.media = "enabled")));
      }
      function u(e) {
        i &&
          s &&
          n &&
          ((i.textContent = d(e).core.cssText),
          (s.textContent = d(e).dark.cssText),
          (n.textContent = d(e).light.cssText));
      }
      function d(e) {
        return {
          core: (0, a.AH)`
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      @keyframes w3m-shake {
        0% {
          transform: scale(1) rotate(0deg);
        }
        20% {
          transform: scale(1) rotate(-1deg);
        }
        40% {
          transform: scale(1) rotate(1.5deg);
        }
        60% {
          transform: scale(1) rotate(-1.5deg);
        }
        80% {
          transform: scale(1) rotate(1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      @keyframes w3m-iframe-fade-out {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      @keyframes w3m-iframe-zoom-in {
        0% {
          transform: translateY(50px);
          opacity: 0;
        }
        100% {
          transform: translateY(0px);
          opacity: 1;
        }
      }
      @keyframes w3m-iframe-zoom-in-mobile {
        0% {
          transform: scale(0.95);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      :root {
        --w3m-modal-width: 360px;
        --w3m-color-mix-strength: ${(0, a.iz)(
          e?.["--w3m-color-mix-strength"]
            ? `${e["--w3m-color-mix-strength"]}%`
            : "0%"
        )};
        --w3m-font-family: ${(0, a.iz)(
          e?.["--w3m-font-family"] ||
            "Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;"
        )};
        --w3m-font-size-master: ${(0, a.iz)(
          e?.["--w3m-font-size-master"] || "10px"
        )};
        --w3m-border-radius-master: ${(0, a.iz)(
          e?.["--w3m-border-radius-master"] || "4px"
        )};
        --w3m-z-index: ${(0, a.iz)(e?.["--w3m-z-index"] || 999)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-mini: calc(var(--w3m-font-size-master) * 0.8);
        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-medium: calc(var(--w3m-font-size-master) * 1.8);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);
        --wui-font-size-title-6: calc(var(--w3m-font-size-master) * 2.2);
        --wui-font-size-medium-title: calc(var(--w3m-font-size-master) * 2.4);
        --wui-font-size-2xl: calc(var(--w3m-font-size-master) * 4);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-2xl: -1.6px;
        --wui-letter-spacing-medium-title: -0.96px;
        --wui-letter-spacing-title-6: -0.88px;
        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-medium: -0.72px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;
        --wui-letter-spacing-mini: -0.16px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;
        --wui-spacing-5xl: 95px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-mdl: 36px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-2lg: 48px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;
        --wui-icon-size-xxl: 28px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-visual-size-size-inherit: inherit;
        --wui-visual-size-sm: 40px;
        --wui-visual-size-md: 55px;
        --wui-visual-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --wui-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-width-network-sm: 36px;
        --wui-width-network-md: 48px;
        --wui-width-network-lg: 86px;

        --wui-height-network-sm: 40px;
        --wui-height-network-md: 54px;
        --wui-height-network-lg: 96px;

        --wui-icon-size-network-xs: 12px;
        --wui-icon-size-network-sm: 16px;
        --wui-icon-size-network-md: 24px;
        --wui-icon-size-network-lg: 42px;

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-success-125: var(--wui-color-success-base-125);

        --wui-color-warning-100: var(--wui-color-warning-base-100);

        --wui-color-error-100: var(--wui-color-error-base-100);
        --wui-color-error-125: var(--wui-color-error-base-125);

        --wui-color-blue-100: var(--wui-color-blue-base-100);
        --wui-color-blue-90: var(--wui-color-blue-base-90);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-wallet-button-bg: var(--wui-wallet-button-bg-base);

        --wui-box-shadow-blue: var(--wui-color-accent-glass-020);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 20%, transparent);

          --wui-color-accent-100: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 100%,
            transparent
          );
          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-color-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-color-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-color-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-300)
          );
          --wui-color-fg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-325)
          );
          --wui-color-fg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-350)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-300)
          );
          --wui-color-bg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-325)
          );
          --wui-color-bg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-350)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-success-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-125)
          );

          --wui-color-warning-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-warning-base-100)
          );

          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );
          --wui-color-blue-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-100)
          );
          --wui-color-blue-90: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-90)
          );
          --wui-color-error-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-125)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );

          --wui-wallet-button-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-wallet-button-bg-base)
          );
        }
      }
    `,
          light: (0, a.AH)`
      :root {
        --w3m-color-mix: ${(0, a.iz)(e?.["--w3m-color-mix"] || "#fff")};
        --w3m-accent: ${(0, a.iz)((0, o.o)(e, "dark")["--w3m-accent"])};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: ${(0, a.iz)(
          (0, o.o)(e, "dark")["--w3m-background"]
        )};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(230, 100%, 67%, 1);
        --wui-color-blueberry-090: hsla(231, 76%, 61%, 1);
        --wui-color-blueberry-080: hsla(230, 59%, 55%, 1);
        --wui-color-blueberry-050: hsla(231, 100%, 70%, 0.1);

        --wui-color-fg-100: #e4e7e7;
        --wui-color-fg-125: #d0d5d5;
        --wui-color-fg-150: #a8b1b1;
        --wui-color-fg-175: #a8b0b0;
        --wui-color-fg-200: #949e9e;
        --wui-color-fg-225: #868f8f;
        --wui-color-fg-250: #788080;
        --wui-color-fg-275: #788181;
        --wui-color-fg-300: #6e7777;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #363636;

        --wui-color-bg-100: #141414;
        --wui-color-bg-125: #191a1a;
        --wui-color-bg-150: #1e1f1f;
        --wui-color-bg-175: #222525;
        --wui-color-bg-200: #272a2a;
        --wui-color-bg-225: #2c3030;
        --wui-color-bg-250: #313535;
        --wui-color-bg-275: #363b3b;
        --wui-color-bg-300: #3b4040;
        --wui-color-bg-325: #252525;
        --wui-color-bg-350: #ffffff;

        --wui-color-success-base-100: #26d962;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f25a67;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(242, 90, 103, 0.01);
        --wui-color-error-glass-002: rgba(242, 90, 103, 0.02);
        --wui-color-error-glass-005: rgba(242, 90, 103, 0.05);
        --wui-color-error-glass-010: rgba(242, 90, 103, 0.1);
        --wui-color-error-glass-015: rgba(242, 90, 103, 0.15);
        --wui-color-error-glass-020: rgba(242, 90, 103, 0.2);
        --wui-color-error-glass-025: rgba(242, 90, 103, 0.25);
        --wui-color-error-glass-030: rgba(242, 90, 103, 0.3);
        --wui-color-error-glass-060: rgba(242, 90, 103, 0.6);
        --wui-color-error-glass-080: rgba(242, 90, 103, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-color-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-color-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-color-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-color-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-color-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-color-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-color-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-color-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-color-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-color-gray-glass-080: rgba(255, 255, 255, 0.8);
        --wui-color-gray-glass-090: rgba(255, 255, 255, 0.9);

        --wui-color-dark-glass-100: rgba(42, 42, 42, 1);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: #1f3a28;
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --w3m-card-embedded-shadow-color: rgb(17 17 18 / 25%);
      }
    `,
          dark: (0, a.AH)`
      :root {
        --w3m-color-mix: ${(0, a.iz)(e?.["--w3m-color-mix"] || "#000")};
        --w3m-accent: ${(0, a.iz)((0, o.o)(e, "light")["--w3m-accent"])};
        --w3m-default: #000;

        --wui-color-modal-bg-base: ${(0, a.iz)(
          (0, o.o)(e, "light")["--w3m-background"]
        )};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(231, 100%, 70%, 1);
        --wui-color-blueberry-090: hsla(231, 97%, 72%, 1);
        --wui-color-blueberry-080: hsla(231, 92%, 74%, 1);

        --wui-color-fg-100: #141414;
        --wui-color-fg-125: #2d3131;
        --wui-color-fg-150: #474d4d;
        --wui-color-fg-175: #636d6d;
        --wui-color-fg-200: #798686;
        --wui-color-fg-225: #828f8f;
        --wui-color-fg-250: #8b9797;
        --wui-color-fg-275: #95a0a0;
        --wui-color-fg-300: #9ea9a9;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #d0d0d0;

        --wui-color-bg-100: #ffffff;
        --wui-color-bg-125: #f5fafa;
        --wui-color-bg-150: #f3f8f8;
        --wui-color-bg-175: #eef4f4;
        --wui-color-bg-200: #eaf1f1;
        --wui-color-bg-225: #e5eded;
        --wui-color-bg-250: #e1e9e9;
        --wui-color-bg-275: #dce7e7;
        --wui-color-bg-300: #d8e3e3;
        --wui-color-bg-325: #f3f3f3;
        --wui-color-bg-350: #202020;

        --wui-color-success-base-100: #26b562;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f05142;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(240, 81, 66, 0.01);
        --wui-color-error-glass-002: rgba(240, 81, 66, 0.02);
        --wui-color-error-glass-005: rgba(240, 81, 66, 0.05);
        --wui-color-error-glass-010: rgba(240, 81, 66, 0.1);
        --wui-color-error-glass-015: rgba(240, 81, 66, 0.15);
        --wui-color-error-glass-020: rgba(240, 81, 66, 0.2);
        --wui-color-error-glass-025: rgba(240, 81, 66, 0.25);
        --wui-color-error-glass-030: rgba(240, 81, 66, 0.3);
        --wui-color-error-glass-060: rgba(240, 81, 66, 0.6);
        --wui-color-error-glass-080: rgba(240, 81, 66, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --wui-color-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-color-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-color-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-color-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-color-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-color-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-color-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-color-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-color-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-color-gray-glass-080: rgba(0, 0, 0, 0.8);
        --wui-color-gray-glass-090: rgba(0, 0, 0, 0.9);

        --wui-color-dark-glass-100: rgba(233, 233, 233, 1);

        --w3m-card-embedded-shadow-color: rgb(224 225 233 / 25%);
      }
    `,
        };
      }
      let h = (0, a.AH)`
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`,
        p = (0, a.AH)`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition:
      color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1),
      box-shadow var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: background-color, color, border, box-shadow, border-radius;
    outline: none;
    border: none;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  wui-flex {
    transition: border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: border-radius;
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-005);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-010);
    }
  }

  button:disabled > wui-icon-box {
    opacity: 0.5;
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`,
        f = (0, a.AH)`
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-blue-100 {
    color: var(--wui-color-blue-100);
  }

  .wui-color-blue-90 {
    color: var(--wui-color-blue-90);
  }

  .wui-color-error-125 {
    color: var(--wui-color-error-125);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-success-125 {
    color: var(--wui-color-success-125);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    color: var(--wui-color-fg-350);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-error-125 {
    background-color: var(--wui-color-error-125);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-success-125 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    background-color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    background-color: var(--wui-color-fg-350);
  }
`;
    },
    98078: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => n });
      var i = r(19405),
        s = r(65368);
      function n(e) {
        let {
            batch: t,
            cacheTime: r = e.pollingInterval ?? 4e3,
            ccipRead: n,
            key: a = "base",
            name: o = "Base Client",
            pollingInterval: c = 4e3,
            type: l = "base",
          } = e,
          u = e.chain,
          d = e.account ? (0, i.J)(e.account) : void 0,
          {
            config: h,
            request: p,
            value: f,
          } = e.transport({ chain: u, pollingInterval: c }),
          g = {
            account: d,
            batch: t,
            cacheTime: r,
            ccipRead: n,
            chain: u,
            key: a,
            name: o,
            pollingInterval: c,
            request: p,
            transport: { ...h, ...f },
            type: l,
            uid: (0, s.L)(),
          };
        return Object.assign(g, {
          extend: (function e(t) {
            return (r) => {
              let i = r(t);
              for (let e in g) delete i[e];
              let s = { ...t, ...i };
              return Object.assign(s, { extend: e(s) });
            };
          })(g),
        });
      }
    },
    98782: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => d });
      var i = r(96641),
        s = r(54252),
        n = r(5582),
        a = r(35558),
        o = r(65819),
        c = r(23140),
        l = r(95842),
        u = r(26128);
      let d = {
        filterOutDuplicatesByRDNS(e) {
          let t = i.H.state.enableEIP6963 ? s.a.state.connectors : [],
            r = n.i.getRecentWallets(),
            o = t.map((e) => e.info?.rdns).filter(Boolean),
            c = r.map((e) => e.rdns).filter(Boolean),
            l = o.concat(c);
          if (l.includes("io.metamask.mobile") && a.w.isMobile()) {
            let e = l.indexOf("io.metamask.mobile");
            l[e] = "io.metamask";
          }
          return e.filter((e) => !l.includes(String(e?.rdns)));
        },
        filterOutDuplicatesByIds(e) {
          let t = s.a.state.connectors.filter(
              (e) => "ANNOUNCED" === e.type || "INJECTED" === e.type
            ),
            r = n.i.getRecentWallets(),
            i = t.map((e) => e.explorerId),
            a = r.map((e) => e.id),
            o = i.concat(a);
          return e.filter((e) => !o.includes(e?.id));
        },
        filterOutDuplicateWallets(e) {
          let t = this.filterOutDuplicatesByRDNS(e);
          return this.filterOutDuplicatesByIds(t);
        },
        markWalletsAsInstalled(e) {
          let { connectors: t } = s.a.state,
            { featuredWalletIds: r } = i.H.state,
            n = t
              .filter((e) => "ANNOUNCED" === e.type)
              .reduce((e, t) => (t.info?.rdns && (e[t.info.rdns] = !0), e), {});
          return e
            .map((e) => ({ ...e, installed: !!e.rdns && !!n[e.rdns ?? ""] }))
            .sort((e, t) => {
              let i = Number(t.installed) - Number(e.installed);
              if (0 !== i) return i;
              if (r?.length) {
                let i = r.indexOf(e.id),
                  s = r.indexOf(t.id);
                if (-1 !== i && -1 !== s) return i - s;
                if (-1 !== i) return -1;
                if (-1 !== s) return 1;
              }
              return 0;
            });
        },
        getConnectOrderMethod(e, t) {
          let r =
              e?.connectMethodsOrder || i.H.state.features?.connectMethodsOrder,
            n = t || s.a.state.connectors;
          if (r) return r;
          let { injected: a, announced: c } = l.g.getConnectorsByType(
              n,
              o.N.state.recommended,
              o.N.state.featured
            ),
            d = a.filter(l.g.showConnector),
            h = c.filter(l.g.showConnector);
          return d.length || h.length
            ? ["wallet", "email", "social"]
            : u.o.DEFAULT_CONNECT_METHOD_ORDER;
        },
        isExcluded(e) {
          let t =
              !!e.rdns &&
              o.N.state.excludedWallets.some((t) => t.rdns === e.rdns),
            r =
              !!e.name &&
              o.N.state.excludedWallets.some((t) =>
                c.y.isLowerCaseMatch(t.name, e.name)
              );
          return t || r;
        },
      };
    },
    99758: function (e) {
      e.exports = function (e, t, r) {
        e = e || {};
        var i = t.prototype,
          s = {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years",
          };
        function n(e, t, r, s) {
          return i.fromToBase(e, t, r, s);
        }
        (r.en.relativeTime = s),
          (i.fromToBase = function (t, i, n, a, o) {
            for (
              var c,
                l,
                u,
                d = n.$locale().relativeTime || s,
                h = e.thresholds || [
                  { l: "s", r: 44, d: "second" },
                  { l: "m", r: 89 },
                  { l: "mm", r: 44, d: "minute" },
                  { l: "h", r: 89 },
                  { l: "hh", r: 21, d: "hour" },
                  { l: "d", r: 35 },
                  { l: "dd", r: 25, d: "day" },
                  { l: "M", r: 45 },
                  { l: "MM", r: 10, d: "month" },
                  { l: "y", r: 17 },
                  { l: "yy", d: "year" },
                ],
                p = h.length,
                f = 0;
              f < p;
              f += 1
            ) {
              var g = h[f];
              g.d && (c = a ? r(t).diff(n, g.d, !0) : n.diff(t, g.d, !0));
              var m = (e.rounding || Math.round)(Math.abs(c));
              if (((u = c > 0), m <= g.r || !g.r)) {
                m <= 1 && f > 0 && (g = h[f - 1]);
                var y = d[g.l];
                o && (m = o("" + m)),
                  (l =
                    "string" == typeof y
                      ? y.replace("%d", m)
                      : y(m, i, g.l, u));
                break;
              }
            }
            if (i) return l;
            var b = u ? d.future : d.past;
            return "function" == typeof b ? b(l) : b.replace("%s", l);
          }),
          (i.to = function (e, t) {
            return n(e, t, this, !0);
          }),
          (i.from = function (e, t) {
            return n(e, t, this);
          });
        var a = function (e) {
          return e.$u ? r.utc() : r();
        };
        (i.toNow = function (e) {
          return this.to(a(this), e);
        }),
          (i.fromNow = function (e) {
            return this.from(a(this), e);
          });
      };
    },
    99836: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => i });
      let i = {
        METMASK_CONNECTOR_NAME: "MetaMask",
        TRUST_CONNECTOR_NAME: "Trust Wallet",
        SOLFLARE_CONNECTOR_NAME: "Solflare",
        PHANTOM_CONNECTOR_NAME: "Phantom",
        COIN98_CONNECTOR_NAME: "Coin98",
        MAGIC_EDEN_CONNECTOR_NAME: "Magic Eden",
        BACKPACK_CONNECTOR_NAME: "Backpack",
        BITGET_CONNECTOR_NAME: "Bitget Wallet",
        FRONTIER_CONNECTOR_NAME: "Frontier",
        XVERSE_CONNECTOR_NAME: "Xverse Wallet",
        LEATHER_CONNECTOR_NAME: "Leather",
        EIP155: "eip155",
        ADD_CHAIN_METHOD: "wallet_addEthereumChain",
        EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
        EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
        CONNECTOR_RDNS_MAP: {
          coinbaseWallet: "com.coinbase.wallet",
          coinbaseWalletSDK: "com.coinbase.wallet",
        },
        CONNECTOR_TYPE_EXTERNAL: "EXTERNAL",
        CONNECTOR_TYPE_WALLET_CONNECT: "WALLET_CONNECT",
        CONNECTOR_TYPE_INJECTED: "INJECTED",
        CONNECTOR_TYPE_ANNOUNCED: "ANNOUNCED",
        CONNECTOR_TYPE_AUTH: "AUTH",
        CONNECTOR_TYPE_MULTI_CHAIN: "MULTI_CHAIN",
        CONNECTOR_TYPE_W3M_AUTH: "ID_AUTH",
      };
    },
    99843: (e, t, r) => {
      "use strict";
      r.d(t, { X: () => c }), r(50254);
      var i = r(60500),
        s = r(90906),
        n = r(11076),
        a = r(93813),
        o = r(2568);
      class c {
        constructor(e) {
          (this.availableConnectors = []),
            (this.eventListeners = new Map()),
            (this.getCaipNetworks = (e) => s.W.getCaipNetworks(e)),
            e && this.construct(e);
        }
        construct(e) {
          (this.projectId = e.projectId),
            (this.namespace = e.namespace),
            (this.adapterType = e.adapterType);
        }
        get connectors() {
          return this.availableConnectors;
        }
        get networks() {
          return this.getCaipNetworks(this.namespace);
        }
        setAuthProvider(e) {
          this.addConnector({
            id: i.o.CONNECTOR_ID.AUTH,
            type: "AUTH",
            name: i.o.CONNECTOR_NAMES.AUTH,
            provider: e,
            imageId: a.L.ConnectorImageIds[i.o.CONNECTOR_ID.AUTH],
            chain: this.namespace,
            chains: [],
          });
        }
        addConnector(...e) {
          let t = new Set();
          (this.availableConnectors = [
            ...e,
            ...this.availableConnectors,
          ].filter((e) => !t.has(e.id) && (t.add(e.id), !0))),
            this.emit("connectors", this.availableConnectors);
        }
        setStatus(e, t) {
          n.U.setStatus(e, t);
        }
        on(e, t) {
          this.eventListeners.has(e) || this.eventListeners.set(e, new Set()),
            this.eventListeners.get(e)?.add(t);
        }
        off(e, t) {
          let r = this.eventListeners.get(e);
          r && r.delete(t);
        }
        removeAllEventListeners() {
          this.eventListeners.forEach((e) => {
            e.clear();
          });
        }
        emit(e, t) {
          let r = this.eventListeners.get(e);
          r && r.forEach((e) => e(t));
        }
        async connectWalletConnect(e) {
          let t = this.getWalletConnectConnector();
          return { clientId: (await t.connectWalletConnect()).clientId };
        }
        async switchNetwork(e) {
          let { caipNetwork: t, providerType: r } = e;
          if (!e.provider) return;
          let i = "provider" in e.provider ? e.provider.provider : e.provider;
          if ("WALLET_CONNECT" === r)
            return void i.setDefaultChain(t.caipNetworkId);
          if (i && "AUTH" === r) {
            let e = n.U.state.preferredAccountTypes?.[t.chainNamespace];
            await i.switchNetwork(t.caipNetworkId);
            let r = await i.getUser({
              chainId: t.caipNetworkId,
              preferredAccountType: e,
            });
            this.emit("switchNetwork", r);
          }
        }
        getWalletConnectConnector() {
          let e = this.connectors.find((e) => e instanceof o.F);
          if (!e) throw Error("WalletConnectConnector not found");
          return e;
        }
      }
    },
  },
]);
